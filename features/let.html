<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="generator" content="rustdoc">
    <title>Let binding</title>

    <link rel="stylesheet" type="text/css" href="../rust-book.css">

    
</head>
<body>
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id='toc'>
<ul class='chapter'>
<li><a href='../README.html'><b>1.</b> Introduction</a>
</li>
<li><a href='../style/README.html'><b>2.</b> Style</a>
<ul class='section'>
<li><a href='../style/whitespace.html'><b>2.1.</b> Whitespace</a>
</li>
<li><a href='../style/comments.html'><b>2.2.</b> Comments</a>
</li>
<li><a href='../style/braces.html'><b>2.3.</b> Braces, semicolons, commas</a>
</li>
<li><a href='../style/naming.html'><b>2.4.</b> Naming</a>
</li>
<li><a href='../style/imports.html'><b>2.5.</b> Imports</a>
</li>
<li><a href='../style/organization.html'><b>2.6.</b> Organization</a>
</li>
</ul>
</li>
<li><a href='../features/README.html'><b>3.</b> Guidelines by Rust feature</a>
<ul class='section'>
<li><a href='../features/let.html'><b>3.1.</b> Let binding</a>
</li>
<li><a href='../features/match.html'><b>3.2.</b> Pattern matching</a>
</li>
<li><a href='../features/loops.html'><b>3.3.</b> Loops</a>
</li>
<li><a href='../features/functions-and-methods/README.html'><b>3.4.</b> Functions and methods</a>
<ul class='section'>
<li><a href='../features/functions-and-methods/input.html'><b>3.4.1.</b> Input</a>
</li>
<li><a href='../features/functions-and-methods/output.html'><b>3.4.2.</b> Output</a>
</li>
<li><a href='../features/functions-and-methods/convenience.html'><b>3.4.3.</b> For convenience</a>
</li>
</ul>
</li>
<li><a href='../features/types/README.html'><b>3.5.</b> Types</a>
<ul class='section'>
<li><a href='../features/types/conversions.html'><b>3.5.1.</b> Conversions</a>
</li>
<li><a href='../features/types/newtype.html'><b>3.5.2.</b> The newtype pattern</a>
</li>
</ul>
</li>
<li><a href='../features/traits/README.html'><b>3.6.</b> Traits</a>
<ul class='section'>
<li><a href='../features/traits/generics.html'><b>3.6.1.</b> For generics</a>
</li>
<li><a href='../features/traits/objects.html'><b>3.6.2.</b> For objects</a>
</li>
<li><a href='../features/traits/overloading.html'><b>3.6.3.</b> For overloading</a>
</li>
<li><a href='../features/traits/extensions.html'><b>3.6.4.</b> For extensions</a>
</li>
<li><a href='../features/traits/reuse.html'><b>3.6.5.</b> For reuse</a>
</li>
<li><a href='../features/traits/common.html'><b>3.6.6.</b> Common traits</a>
</li>
</ul>
</li>
<li><a href='../features/modules.html'><b>3.7.</b> Modules</a>
</li>
<li><a href='../features/crates.html'><b>3.8.</b> Crates</a>
</li>
</ul>
</li>
<li><a href='../ownership/README.html'><b>4.</b> Ownership and resources</a>
<ul class='section'>
<li><a href='../ownership/constructors.html'><b>4.1.</b> Constructors</a>
</li>
<li><a href='../ownership/builders.html'><b>4.2.</b> Builders</a>
</li>
<li><a href='../ownership/destructors.html'><b>4.3.</b> Destructors</a>
</li>
<li><a href='../ownership/raii.html'><b>4.4.</b> RAII</a>
</li>
<li><a href='../ownership/cell-smart.html'><b>4.5.</b> Cells and smart pointers</a>
</li>
</ul>
</li>
<li><a href='../errors/README.html'><b>5.</b> Errors</a>
<ul class='section'>
<li><a href='../errors/signaling.html'><b>5.1.</b> Signaling</a>
</li>
<li><a href='../errors/handling.html'><b>5.2.</b> Handling</a>
</li>
<li><a href='../errors/propagation.html'><b>5.3.</b> Propagation</a>
</li>
<li><a href='../errors/ergonomics.html'><b>5.4.</b> Ergonomics</a>
</li>
</ul>
</li>
<li><a href='../safety/README.html'><b>6.</b> Safety and guarantees</a>
<ul class='section'>
<li><a href='../safety/unsafe.html'><b>6.1.</b> Using unsafe</a>
</li>
<li><a href='../safety/lib-guarantees.html'><b>6.2.</b> Library guarantees</a>
</li>
</ul>
</li>
<li><a href='../testing/README.html'><b>7.</b> Testing</a>
<ul class='section'>
<li><a href='../testing/unit.html'><b>7.1.</b> Unit testing</a>
</li>
</ul>
</li>
<li><a href='../platform.html'><b>8.</b> FFI, platform-specific code</a>
</li>
<li><a href='../changing/README.html'><b>9.</b> APIs for a changing Rust</a>
<ul class='section'>
<li><a href='../changing/pre-1-0.html'><b>9.1.</b> Pre-1.0 changes</a>
</li>
<li><a href='../changing/post-1-0.html'><b>9.2.</b> Post-1.0 changes</a>
</li>
<li><a href='../changing/unclear.html'><b>9.3.</b> Timing unclear</a>
</li>
</ul>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Let binding</h1>
    
<h3 id="always-separately-bind-raii-guards.-[rfc]" class='section-header'><a
                           href="#always-separately-bind-raii-guards.-[rfc]">Always separately bind RAII guards. [RFC]</a></h3>
<p>Prefer</p>
<pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>use_mutex</span>(<span class='ident'>m</span>: <span class='ident'>sync</span>::<span class='ident'>mutex</span>::<span class='ident'>Mutex</span><span class='op'>&lt;</span><span class='ident'>int</span><span class='op'>&gt;</span>) {
    <span class='kw'>let</span> <span class='ident'>guard</span> <span class='op'>=</span> <span class='ident'>m</span>.<span class='ident'>lock</span>();
    <span class='ident'>do_work</span>(<span class='ident'>guard</span>);
    <span class='ident'>drop</span>(<span class='ident'>guard</span>); <span class='comment'>// unlock the lock</span>
    <span class='comment'>// do other work</span>
}
</pre>

<p>over</p>
<pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>use_mutex</span>(<span class='ident'>m</span>: <span class='ident'>sync</span>::<span class='ident'>mutex</span>::<span class='ident'>Mutex</span><span class='op'>&lt;</span><span class='ident'>int</span><span class='op'>&gt;</span>) {
    <span class='ident'>do_work</span>(<span class='ident'>m</span>.<span class='ident'>lock</span>());
    <span class='comment'>// do other work</span>
}
</pre>

<p>As explained in the <a href="../ownership/raii.html">RAII guide</a>, RAII guards are values
that represent ownership of some resource and whose destructor releases the
resource. Because the lifetime of guards are significant, they should always be
explicitly <code>let</code>-bound to make the lifetime clear. Consider using an explicit
<code>drop</code> to release the resource early.</p>

<h3 id="prefer-conditional-expressions-to-deferred-initialization.-[rfc]" class='section-header'><a
                           href="#prefer-conditional-expressions-to-deferred-initialization.-[rfc]">Prefer conditional expressions to deferred initialization. [RFC]</a></h3>
<p>Prefer</p>
<pre class='rust '>
<span class='kw'>let</span> <span class='ident'>foo</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>bar</span> {
    <span class='ident'>Baz</span>  <span class='op'>=&gt;</span> <span class='number'>0</span>,
    <span class='ident'>Quux</span> <span class='op'>=&gt;</span> <span class='number'>1</span>
};
</pre>

<p>over</p>
<pre class='rust '>
<span class='kw'>let</span> <span class='ident'>foo</span>;
<span class='kw'>match</span> <span class='ident'>bar</span> {
    <span class='ident'>Baz</span>  <span class='op'>=&gt;</span> {
        <span class='ident'>foo</span> <span class='op'>=</span> <span class='number'>0</span>;
    }
    <span class='ident'>Quux</span> <span class='op'>=&gt;</span> {
        <span class='ident'>foo</span> <span class='op'>=</span> <span class='number'>1</span>;
    }
}
</pre>

<p>unless the conditions for initialization are too complex to fit into a simple
conditional expression.</p>

<h3 id="use-type-annotations-for-clarification;-prefer-explicit-generics-when-inference-fails.-[rfc]" class='section-header'><a
                           href="#use-type-annotations-for-clarification;-prefer-explicit-generics-when-inference-fails.-[rfc]">Use type annotations for clarification; prefer explicit generics when inference fails. [RFC]</a></h3>
<p>Prefer</p>
<pre class='rust '>
<span class='ident'>s</span>.<span class='ident'>iter</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>*</span> <span class='number'>2</span>)
        .<span class='ident'>collect</span>::<span class='op'>&lt;</span><span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;&gt;</span>()
</pre>

<p>over</p>
<pre class='rust '>
<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>s</span>.<span class='ident'>iter</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>*</span> <span class='number'>2</span>)
                        .<span class='ident'>collect</span>();
</pre>

<p>When the type of a value might be unclear to the <em>reader</em> of the code, consider
explicitly annotating it in a <code>let</code>.</p>

<p>On the other hand, when the type is unclear to the <em>compiler</em>, prefer to specify
the type by explicit generics instantiation, which is usually more clear.</p>

<h3 id="shadowing-[open]" class='section-header'><a
                           href="#shadowing-[open]">Shadowing [OPEN]</a></h3>
<blockquote>
<p><strong>[OPEN]</strong> Repeatedly shadowing a binding is somewhat common in Rust code. We
need to articulate a guideline on when it is appropriate/useful and when not.</p>
</blockquote>

<h3 id="prefer-immutable-bindings.-[rfc]" class='section-header'><a
                           href="#prefer-immutable-bindings.-[rfc]">Prefer immutable bindings. [RFC]</a></h3>
<p>Use <code>mut</code> bindings to signal the span during which a value is mutated:</p>
<pre class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='ident'>Vec</span>::<span class='ident'>new</span>();
<span class='comment'>// push things onto v</span>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='ident'>v</span>;
<span class='comment'>// use v immutably henceforth</span>
</pre>

<h3 id="prefer-to-bind-all-struct-or-tuple-fields.-[rfc]" class='section-header'><a
                           href="#prefer-to-bind-all-struct-or-tuple-fields.-[rfc]">Prefer to bind all <code>struct</code> or tuple fields. [RFC]</a></h3>
<p>When consuming a <code>struct</code> or tuple via a <code>let</code>, bind all of the fields rather
than using <code>..</code> to elide the ones you don&#39;t need. The benefit is that when
fields are added, the compiler will pinpoint all of the places where that type
of value was consumed, which will often need to be adjusted to take the new
field properly into account.</p>

    <script type="text/javascript">
        window.playgroundUrl = "";
    </script>
    </div></div>


</body>
</html>