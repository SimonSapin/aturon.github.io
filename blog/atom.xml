<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Aaron Turon</title>
 <link href="http://aturon.github.io/blog/atom.xml" rel="self"/>
 <link href="http://aturon.github.io/blog/"/>
 <updated>2016-08-26T17:28:19-07:00</updated>
 <id>http://aturon.github.io</id>
 <author>
   <name>Aaron Turon</name>
   <email>aturon@mozilla.com</email>
 </author>

 
 <entry>
   <title>Expanding the Tokio project</title>
   <link href="http://aturon.github.io/blog/2016/08/26/tokio/"/>
   <updated>2016-08-26T00:00:00-07:00</updated>
   <id>http://aturon.github.io/2016/08/26/tokio</id>
   <content type="html">&lt;p&gt;If you&amp;rsquo;ve been following Rust in the last month, you&amp;rsquo;ve probably seen the
announcements of the &lt;a href=&quot;http://aturon.github.io/blog/2016/08/11/futures/&quot;&gt;Futures&lt;/a&gt; library and the &lt;a href=&quot;https://medium.com/@carllerche/announcing-tokio-df6bb4ddb34&quot;&gt;Tokio&lt;/a&gt; framework that sits on
top of it. There&amp;rsquo;s been some confusion about how these projects fit together,
and what the overall story is shaping up to be.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Today, we&amp;rsquo;re happy to announce the formation of the Tokio Core Team, as well
as an overall plan for the two projects and how they fit together&lt;/strong&gt;. The team
consists of Carl Lerche, Alex Crichton, and myself; more on that below.&lt;/p&gt;

&lt;h2 id=&quot;an-early-vision-of-the-i-o-stack&quot;&gt;An early vision of the I/O stack&lt;/h2&gt;

&lt;p&gt;There are three primary levels of abstraction in Tokio:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;At the highest level is a &lt;em&gt;service&lt;/em&gt;, which is where you write a server
application. Following the &lt;a href=&quot;http://finagle.github.io/&quot;&gt;Finagle&lt;/a&gt; model, a service is a simple thing: it&amp;rsquo;s
a function from requests to &lt;em&gt;futures&lt;/em&gt; of responses. This simple model is
incredibly powerful: it separates the implementation of request processing
from the implementation of the underlying protocol, and makes it possible to
factor out an ecosystem of &lt;em&gt;middleware&lt;/em&gt;. All of this seamlessly support async
I/O via futures. Middleware runs the gamut from connection pooling to
retry/timeout logic to logging to load balancing &amp;ndash; all of which can be
written independently from any particular service or protocol. Read
&lt;a href=&quot;https://monkey.org/%7Emarius/funsrv.pdf&quot;&gt;Your Server as a Function&lt;/a&gt; for the inspiration.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/tokio-rs/tokio-service&quot;&gt;tokio-service&lt;/a&gt; crate provides core trait definitions for
  services. Servers that can process particular request/response types (like
  HTTP) are offered as standalone crates. &lt;strong&gt;Building an http server is just a
  matter of writing a function from http requests to futures of http
  responses.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;In the middle are &lt;em&gt;protocols&lt;/em&gt;, like HTTP or Mux. Here, too, there is a lot of
complexity worth factoring out, both at the transport layer and in the
protocol &amp;ldquo;dispatch&amp;rdquo; layer. &lt;strong&gt;The &lt;a href=&quot;https://github.com/tokio-rs/tokio-proto&quot;&gt;tokio-proto&lt;/a&gt; crate provides re-usable
components for building new protocol implementations&lt;/strong&gt;. We expect for there to
be a similar kind of &amp;ldquo;middleware&amp;rdquo; ecosystem at these lower levels.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;At the lowest level is the &lt;em&gt;event loop&lt;/em&gt;, which is where we bridge the OS&amp;rsquo;s I/O
facilities into the world of futures. &lt;strong&gt;The &lt;a href=&quot;https://github.com/tokio-rs/tokio-core&quot;&gt;tokio-core&lt;/a&gt; crate provides a
generic event loop for doing async I/O with futures&lt;/strong&gt;. If you want complete
control, that&amp;rsquo;s the entry point for you; it&amp;rsquo;s particularly useful for cases
that don&amp;rsquo;t fit so nicely into the service model, such as proxy servers.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;In short, we want the Tokio project to be a &amp;ldquo;one stop shop&amp;rdquo; for doing
futures-based I/O&lt;/strong&gt;, whether at the highest level of prebuilt protocols, or
the lowest level of the core event loop.&lt;/p&gt;

&lt;p&gt;In our view, the lowest layers should strive to be zero cost and fully general,
allowing them to be used in a large number of contexts. As you go up the stack,
getting closer to an actual application, things tend to get more specific and
opinionated, and may impose some cost. &lt;a href=&quot;http://aturon.github.io/blog/2016/08/11/futures/&quot;&gt;Futures&lt;/a&gt; themselves are a zero-cost and
very general abstraction in Rust, and the &lt;a href=&quot;https://github.com/tokio-rs/tokio-core&quot;&gt;tokio-core&lt;/a&gt; crate imposes very little
cost. Particular protocol implementations and middleware, on the other hand, can
be more opinionated.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll have a lot more to say about all of these layers (and the ones beneath
them, like futures) in the coming weeks on our various blogs. Stay tuned!&lt;/p&gt;

&lt;h2 id=&quot;a-note-on-project-management&quot;&gt;A note on project management&lt;/h2&gt;

&lt;p&gt;We&amp;rsquo;re following a Rust-like model, starting with a core team that reaches major
decisions through a consensus process. At the moment, this process is fairly
informal: it plays out on the issue tracker, PRs, and gitter channels. But as
the library begins to mature, we plan to move toward an RFC-like process for
major changes. We are eager for the Tokio project to truly be a Rust community
project. It&amp;rsquo;s going to have a lot of stakeholders, and we want to make sure
those stakeholders have a voice just as we do in the Rust project itself.&lt;/p&gt;

&lt;p&gt;As for the core futures library, it remains separate from the Tokio project, in
part because we imagine it heading toward ownership by the rust-lang org in the
relatively near future. (That&amp;rsquo;s a possible eventual path for Tokio as well, but
the road will be much longer.)&lt;/p&gt;

&lt;h2 id=&quot;jumping-in&quot;&gt;Jumping in&lt;/h2&gt;

&lt;p&gt;Tokio is an ambitious project, and it&amp;rsquo;s going to take a strong community to
really get it off the ground.  Many from the Rust community have already jumped
in to contribute, even in these extremely early days; that&amp;rsquo;s helped us get some
of our early-stage integrations going, including &lt;a href=&quot;https://github.com/tokio-rs/tokio-curl&quot;&gt;curl&lt;/a&gt;, &lt;a href=&quot;https://github.com/tokio-rs/tokio-tls&quot;&gt;tls&lt;/a&gt; and
&lt;a href=&quot;https://github.com/tokio-rs/tokio-redis&quot;&gt;redis&lt;/a&gt;. We&amp;rsquo;re also working with Sean McArthur to get a Tokio-integrated &lt;a href=&quot;https://github.com/hyperium/hyper/&quot;&gt;Hyper&lt;/a&gt;
off the ground. If you&amp;rsquo;re interested in any of this, any other integrations, or
the core libraries, we&amp;rsquo;d love to &lt;a href=&quot;https://gitter.im/tokio-rs/tokio&quot;&gt;hear from you&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re coming to RustConf, we&amp;rsquo;ll see you there, either at the
&lt;a href=&quot;https://tokiohacknight.splashthat.com/&quot;&gt;Tokio hack night&lt;/a&gt; or at the talk about futures at RustConf itself. Come say
hello, and join in the fun!&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Zero-cost futures in Rust</title>
   <link href="http://aturon.github.io/blog/2016/08/11/futures/"/>
   <updated>2016-08-11T00:00:00-07:00</updated>
   <id>http://aturon.github.io/2016/08/11/futures</id>
   <content type="html">&lt;p&gt;One of the key gaps in Rust&amp;rsquo;s ecosystem has been a strong story for fast and
productive &lt;em&gt;asynchronous I/O&lt;/em&gt;. We have solid foundations, like the
&lt;a href=&quot;http://github.com/carllerche/mio&quot;&gt;mio&lt;/a&gt; library, but they&amp;rsquo;re very low level: you
have to wire up state machines and juggle callbacks directly.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ve wanted something higher level, with better ergonomics, but also better
&lt;em&gt;composability&lt;/em&gt;, supporting an ecosystem of asynchronous abstractions that all
work together. This story might sound familiar: it&amp;rsquo;s the same goal that&amp;rsquo;s led to
the introduction of &lt;em&gt;futures&lt;/em&gt; (aka promises) in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Futures_and_promises#List_of_implementations&quot;&gt;many languages&lt;/a&gt;,
with some supporting &lt;em&gt;async/await&lt;/em&gt; sugar on top.&lt;/p&gt;

&lt;p&gt;A major tenet of Rust is the ability to build
&lt;a href=&quot;https://blog.rust-lang.org/2015/05/11/traits.html&quot;&gt;zero-cost abstractions&lt;/a&gt;, and
that leads to one additional goal for our async I/O story: ideally, an
abstraction like futures should compile down to something equivalent to the
state-machine-and-callback-juggling code we&amp;rsquo;re writing today (with no additional
runtime overhead).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Over the past couple of months, Alex Crichton and I have developed a
&lt;a href=&quot;https://github.com/alexcrichton/futures-rs&quot;&gt;&lt;em&gt;zero-cost futures library&lt;/em&gt;&lt;/a&gt; for
Rust, one that we believe achieves these goals&lt;/strong&gt;. (Thanks to Carl Lerche, Yehuda
Katz, and Nicholas Matsakis for insights along the way.)&lt;/p&gt;

&lt;p&gt;Today, we&amp;rsquo;re excited to kick off a blog series about the new library. This post
gives the highlights, a few key ideas, and some preliminary
benchmarks. Follow-up posts will showcase how Rust&amp;rsquo;s features come together in
the design of this zero-cost abstraction. And there&amp;rsquo;s already a
&lt;a href=&quot;https://github.com/alexcrichton/futures-rs/blob/master/TUTORIAL.md&quot;&gt;tutorial&lt;/a&gt;
to get you going.&lt;/p&gt;

&lt;h2 id=&quot;why-async-i-o&quot;&gt;Why async I/O?&lt;/h2&gt;

&lt;p&gt;Before delving into futures, it&amp;rsquo;ll be helpful to talk a bit about the past.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start with a simple piece of I/O you might want to perform: reading a
certain number of bytes from a socket. Rust provides a function,
&lt;a href=&quot;https://static.rust-lang.org/doc/master/std/io/trait.Read.html#method.read_exact&quot;&gt;&lt;code&gt;read_exact&lt;/code&gt;&lt;/a&gt;,
to do this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// reads 256 bytes into `my_vec`&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read_exact&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;my_vec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[..&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Quick quiz: what happens if we haven&amp;rsquo;t received enough bytes from the socket yet?&lt;/p&gt;

&lt;p&gt;In today&amp;rsquo;s Rust, the answer is that the current thread blocks, sleeping until
more bytes are available. But that wasn&amp;rsquo;t always the case.&lt;/p&gt;

&lt;p&gt;Early on, Rust had a &amp;ldquo;green threading&amp;rdquo; model, not unlike Go&amp;rsquo;s. You could spin up
a large number of lightweight &lt;em&gt;tasks&lt;/em&gt;, which were then scheduled onto real OS
threads (sometimes called &amp;ldquo;M:N threading&amp;rdquo;). In the green threading model, a
function like &lt;code&gt;read_exact&lt;/code&gt; blocks the current &lt;em&gt;task&lt;/em&gt;, but not the
underlying OS thread; instead, the task scheduler switches to another
task. That&amp;rsquo;s great, because you can scale up to a very large number of tasks,
most of which are blocked, while using only a small number of OS threads.&lt;/p&gt;

&lt;p&gt;The problem is that green threads were
&lt;a href=&quot;https://mail.mozilla.org/pipermail/rust-dev/2013-November/006314.html&quot;&gt;at odds&lt;/a&gt;
with Rust&amp;rsquo;s ambitions to be a true C replacement, with no imposed runtime system
or FFI costs: we were unable to find an implementation strategy that didn&amp;rsquo;t
impose serious global costs. You can read more
&lt;a href=&quot;https://github.com/aturon/rfcs/blob/remove-runtime/active/0000-remove-runtime.md&quot;&gt;in the RFC that removed green threading&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So if we want to handle a large number of simultaneous connections, many of
which are waiting for I/O, but we want to keep the number of OS threads to a
minimum, what else can we do?&lt;/p&gt;

&lt;p&gt;Asynchronous I/O is the answer &amp;ndash; and in fact, it&amp;rsquo;s used to implement green
threading as well.&lt;/p&gt;

&lt;p&gt;In a nutshell, with async I/O you can &lt;em&gt;attempt&lt;/em&gt; an I/O operation without
blocking. If it can&amp;rsquo;t complete immediately, you can retry at some later
point. To make this work, the OS provides tools like
&lt;a href=&quot;https://en.wikipedia.org/wiki/Epoll&quot;&gt;epoll&lt;/a&gt;, allowing you to query which of a
large set of I/O objects are &lt;em&gt;ready&lt;/em&gt; for reading or writing &amp;ndash; which is
essentially the API that &lt;a href=&quot;http://github.com/carllerche/mio&quot;&gt;mio&lt;/a&gt; provides.&lt;/p&gt;

&lt;p&gt;The problem is that there&amp;rsquo;s a lot of painful work tracking all of the I/O events
you&amp;rsquo;re interested in, and dispatching those to the right callbacks (not to
mention programming in a purely callback-driven way). That&amp;rsquo;s one of the key
problems that futures solve.&lt;/p&gt;

&lt;h2 id=&quot;futures&quot;&gt;Futures&lt;/h2&gt;

&lt;p&gt;So what &lt;em&gt;is&lt;/em&gt; a future?&lt;/p&gt;

&lt;p&gt;In essence, a future represents a value that might not be ready yet. Usually,
the future becomes &lt;em&gt;complete&lt;/em&gt; (the value is ready) due to an event happening
somewhere else. While we&amp;rsquo;ve been looking at this from the perspective of basic
I/O, you can use a future to represent a wide range of events, e.g.:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;A database query&lt;/strong&gt; that&amp;rsquo;s executing in a thread pool. When the query finishes,
the future is completed, and its value is the result of the query.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;An RPC invocation&lt;/strong&gt; to a server. When the server replies, the future is
completed, and its value is the server&amp;rsquo;s response.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;A timeout&lt;/strong&gt;. When time is up, the future is completed, and its value is just
&lt;code&gt;()&lt;/code&gt; (the &amp;ldquo;unit&amp;rdquo; value in Rust).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;A long-running CPU-intensive task&lt;/strong&gt;, running on a thread pool. When the task
finishes, the future is completed, and its value is the return value of the
task.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Reading bytes from a socket&lt;/strong&gt;. When the bytes are ready, the future is completed
&amp;ndash; and depending on the buffering strategy, the bytes might be returned
directly, or written as a side-effect into some existing buffer.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And so on. The point is that futures are applicable to asynchronous
events of all shapes and sizes. The asynchrony is reflected in the fact that you
get a &lt;em&gt;future&lt;/em&gt; right away, without blocking, even though the &lt;em&gt;value&lt;/em&gt; the future
represents will become ready only at some unknown time in the&amp;hellip; future.&lt;/p&gt;

&lt;p&gt;In Rust, we represent futures as a
&lt;a href=&quot;http://alexcrichton.com/futures-rs/futures/trait.Future.html&quot;&gt;trait&lt;/a&gt; (i.e., an
interface), roughly:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ... lots more elided ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;Item&lt;/code&gt; type says what kind of value the future will yield once it&amp;rsquo;s complete.&lt;/p&gt;

&lt;p&gt;Going back to our earlier list of examples, we can write several functions
producing different futures (using
&lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/1522&quot;&gt;&lt;code&gt;impl&lt;/code&gt; syntax&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Lookup a row in a table by the given id, yielding the row when finished&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Row&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Makes an RPC call that will yield an i32&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id_rpc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RpcServer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Writes an entire string to a TcpStream, yielding back the stream when finished&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;write_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TcpStream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TcpStream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;All of these functions will return their future &lt;em&gt;immediately&lt;/em&gt;, whether or not
the event the future represents is complete; the functions are
non-blocking.&lt;/p&gt;

&lt;p&gt;Things really start getting interesting with futures when you combine
them. There are endless ways of doing so, e.g.:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://alexcrichton.com/futures-rs/futures/trait.Future.html#method.and_then&quot;&gt;&lt;strong&gt;Sequential composition&lt;/strong&gt;&lt;/a&gt;:
&lt;code&gt;f.and_then(|val| some_new_future(val))&lt;/code&gt;. Gives you a future that executes the
future &lt;code&gt;f&lt;/code&gt;, takes the &lt;code&gt;val&lt;/code&gt; it produces to build another future
&lt;code&gt;some_new_future(val)&lt;/code&gt;, and then executes that future.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://alexcrichton.com/futures-rs/futures/trait.Future.html#method.map&quot;&gt;&lt;strong&gt;Mapping&lt;/strong&gt;&lt;/a&gt;:
&lt;code&gt;f.map(|val| some_new_value(val))&lt;/code&gt;. Gives you a future that
executes the future &lt;code&gt;f&lt;/code&gt; and yields the result of &lt;code&gt;some_new_value(val)&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://alexcrichton.com/futures-rs/futures/trait.Future.html#method.join&quot;&gt;&lt;strong&gt;Joining&lt;/strong&gt;&lt;/a&gt;:
&lt;code&gt;f.join(g)&lt;/code&gt;. Gives you a future that executes the futures &lt;code&gt;f&lt;/code&gt; and
&lt;code&gt;g&lt;/code&gt; in parallel, and completes when &lt;em&gt;both&lt;/em&gt; of them are complete, returning
both of their values.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://alexcrichton.com/futures-rs/futures/trait.Future.html#method.select&quot;&gt;&lt;strong&gt;Selecting&lt;/strong&gt;&lt;/a&gt;:
&lt;code&gt;f.select(g)&lt;/code&gt;. Gives you a future that executes the futures &lt;code&gt;f&lt;/code&gt;
and &lt;code&gt;g&lt;/code&gt; in parallel, and completes when &lt;em&gt;one of&lt;/em&gt; them is complete, returning
its value and the other future. (Want to add a timeout to any future? Just do
a &lt;code&gt;select&lt;/code&gt; of that future and a timeout future!)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As a simple example using the futures above, we might write something like:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;n&quot;&gt;id_rpc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;my_server&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;and_then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;get_row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;and_then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encoded&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;write_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;my_socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;encoded&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;See
&lt;a href=&quot;https://github.com/alexcrichton/futures-rs/blob/master/futures-minihttp/techempower2/src/main.rs&quot;&gt;this code&lt;/a&gt;
for a more fleshed out example.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is non-blocking code that moves through several states: first we do an RPC
call to acquire an ID; then we look up the corresponding row; then we encode it
to json; then we write it to a socket. &lt;strong&gt;Under the hood, this code will compile
down to an actual state machine which progresses via callbacks (with no
overhead)&lt;/strong&gt;, but we get to write it in a style that&amp;rsquo;s not far from simple
&lt;em&gt;blocking&lt;/em&gt; code. (Rustaceans will note that this story is very similar to
&lt;code&gt;Iterator&lt;/code&gt; in the standard library.)  Ergonomic, high-level code that compiles
to state-machine-and-callbacks: that&amp;rsquo;s what we were after!&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s also worth considering that each of the futures being used here might come
from a different library. The futures abstraction allows them to all be combined
seamlessly together.&lt;/p&gt;

&lt;h2 id=&quot;streams&quot;&gt;Streams&lt;/h2&gt;

&lt;p&gt;But wait &amp;ndash; there&amp;rsquo;s more! As you keep pushing on the future &amp;ldquo;combinators&amp;rdquo;,
you&amp;rsquo;re able to not just reach parity with simple blocking code, but to do things
that can be tricky or painful to write otherwise. To see an example, we&amp;rsquo;ll need one
more concept: streams.&lt;/p&gt;

&lt;p&gt;Futures are all about a &lt;em&gt;single&lt;/em&gt; value that will eventually be produced, but
many event sources naturally produce a &lt;em&gt;stream&lt;/em&gt; of values over time. For
example, incoming TCP connections or incoming requests on a socket are both
naturally streams.&lt;/p&gt;

&lt;p&gt;The futures library includes a
&lt;a href=&quot;http://alexcrichton.com/futures-rs/futures/stream/trait.Stream.html&quot;&gt;&lt;code&gt;Stream&lt;/code&gt; trait&lt;/a&gt;
as well, which is very similar to futures, but set up to produce a sequence of
values over time. It has a set of combinators, some of which work with
futures. For example, if &lt;code&gt;s&lt;/code&gt; is a stream, you can write:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;and_then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;some_future&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This code will give you a new stream that works by first pulling a value &lt;code&gt;val&lt;/code&gt;
from &lt;code&gt;s&lt;/code&gt;, then computing &lt;code&gt;some_future(val)&lt;/code&gt; from it, then executing that future
and yielding its value &amp;ndash; then doing it all over again to produce the next value
in the stream.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see a real example:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Given an `input` I/O object create a stream of requests&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requests&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ParseStream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// For each request, run our service&amp;#39;s `process` function to handle the request&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// and generate a response&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;responses&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requests&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;and_then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;service&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Create a new future that&amp;#39;ll write out each response to an `output` I/O object&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;StreamWriter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;responses&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here, we&amp;rsquo;ve written the core of a simple server by operating on streams. It&amp;rsquo;s
not rocket science, but it is a bit exciting to be manipulating values like
&lt;code&gt;responses&lt;/code&gt; that represent the entirety of what the server is producing.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s make things more interesting. Assume the protocol is pipelined, i.e., that
the client can send additional requests on the socket before hearing back from
the ones being processed. We want to actually process the requests sequentially,
but there&amp;rsquo;s an opportunity for some parallelism here: we could read &lt;em&gt;and parse&lt;/em&gt;
a few requests ahead, while the current request is being processed. Doing so is
as easy as inserting one more combinator in the right place:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requests&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ParseStream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;responses&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requests&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;service&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buffered&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &amp;lt;--&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;StreamWriter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;responsesm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The
&lt;a href=&quot;http://alexcrichton.com/futures-rs/futures/stream/trait.Stream.html#method.buffered&quot;&gt;&lt;code&gt;buffered&lt;/code&gt; combinator&lt;/a&gt;
takes a stream of &lt;em&gt;futures&lt;/em&gt; and buffers it by some fixed amount. Buffering the
stream means that it will eagerly pull out more than the requested number of
items, and stash the resulting futures in a buffer for later processing. In this
case, that means that we will read and parse up to 32 extra requests in parallel,
while running &lt;code&gt;process&lt;/code&gt; on the current one.&lt;/p&gt;

&lt;p&gt;These are relatively simple examples of using futures and streams, but hopefully
they convey some sense of how the combinators can empower you to do very
high-level async programming.&lt;/p&gt;

&lt;h2 id=&quot;zero-cost&quot;&gt;Zero cost?&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve claimed a few times that our futures library provides a zero-cost
abstraction, in that it compiles to something very close to the state machine
code you&amp;rsquo;d write by hand. To make that a bit more concrete:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;None of the future combinators impose any allocation. When we do things like
chain uses of &lt;code&gt;and_then&lt;/code&gt;, not only are we not allocating, we are in fact
building up a big &lt;code&gt;enum&lt;/code&gt; that represents the state machine. (There is one
allocation needed per &amp;ldquo;task&amp;rdquo;, which usually works out to one per connection.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;When an event arrives, only one dynamic dispatch is required.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;There are essentially no imposed synchronization costs; if you want to
associate data that lives on your event loop and access it in a
single-threaded way from futures, we give you the tools to do so.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And so on. Later blog posts will get into the details of these claims and show
how we leverage Rust to get to zero cost.&lt;/p&gt;

&lt;p&gt;But the proof is in the pudding. We wrote a simple HTTP server framework,
&lt;a href=&quot;https://github.com/alexcrichton/futures-rs/tree/master/futures-minihttp&quot;&gt;minihttp&lt;/a&gt;,
which supports pipelining and TLS. &lt;strong&gt;This server uses futures at every level of
its implementation, from reading bytes off a socket to processing streams of
requests&lt;/strong&gt;. Besides being a pleasant way to write the server, this provides a
pretty strong stress test for the overhead of the futures abstraction.&lt;/p&gt;

&lt;p&gt;To get a basic assessment of that overhead, we then implemented the
&lt;a href=&quot;https://www.techempower.com/benchmarks/#section=data-r12&amp;amp;hw=peak&amp;amp;test=plaintext&quot;&gt;TechEmpower &amp;ldquo;plaintext&amp;rdquo; benchmark&lt;/a&gt;. This
microbenchmark tests a &amp;ldquo;hello world&amp;rdquo; HTTP server by throwing a huge number of
concurrent and pipelined requests at it. Since the &amp;ldquo;work&amp;rdquo; that the server is
doing to process the requests is trivial, the performance is largely a
reflection of the basic overhead of the server framework (and in our case, the
futures framework).&lt;/p&gt;

&lt;p&gt;TechEmpower is used to compare a very large number of web frameworks across many
different languages. We
&lt;a href=&quot;https://github.com/alexcrichton/futures-rs/blob/master/futures-minihttp/README.md&quot;&gt;compared&lt;/a&gt;
minihttp to a few of the top contenders:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/TechEmpower/FrameworkBenchmarks/tree/master/frameworks/Java/rapidoid&quot;&gt;rapidoid&lt;/a&gt;,
a Java framework, which was the top performer in the last round of official benchmarks.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/TechEmpower/FrameworkBenchmarks/tree/master/frameworks/Go/go-std&quot;&gt;Go&lt;/a&gt;,
an implementation that uses Go&amp;rsquo;s standard library&amp;rsquo;s HTTP support.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/TechEmpower/FrameworkBenchmarks/tree/master/frameworks/Go/fasthttp&quot;&gt;fasthttp&lt;/a&gt;,
a competitor to Go&amp;rsquo;s standard library.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/TechEmpower/FrameworkBenchmarks/tree/master/frameworks/JavaScript/nodejs&quot;&gt;node.js&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here are the results, in number of &amp;ldquo;Hello world!&amp;quot;s served per second on an 8
core Linux machine:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/public/bench-pipelined.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;It seems safe to say that futures are not imposing significant overhead.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;: to provide some extra evidence, we&amp;rsquo;ve
  &lt;a href=&quot;https://github.com/alexcrichton/futures-rs/blob/master/futures-minihttp/README.md&quot;&gt;added a comparison&lt;/a&gt;
  of minihttp against a directly-coded state machine version in Rust (see &amp;quot;raw
  mio&amp;rdquo; in the link). The two are within 0.3% of each other.&lt;/p&gt;

&lt;h2 id=&quot;the-future&quot;&gt;The future&lt;/h2&gt;

&lt;p&gt;Thus concludes our whirlwind introduction to zero-cost futures in Rust. We&amp;rsquo;ll
see more details about the design in the posts to come.&lt;/p&gt;

&lt;p&gt;At this point, the library is quite usable, and pretty thoroughly documented; it
comes with a
&lt;a href=&quot;https://github.com/alexcrichton/futures-rs/blob/master/TUTORIAL.md&quot;&gt;tutorial&lt;/a&gt;
and plenty of examples, including:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a simple &lt;a href=&quot;https://github.com/alexcrichton/futures-rs/blob/master/futures-mio/src/bin/echo.rs&quot;&gt;TCP echo server&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;an efficient
&lt;a href=&quot;https://github.com/alexcrichton/futures-rs/blob/master/futures-socks5/src/main.rs&quot;&gt;SOCKSv5 proxy server&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;minihttp&lt;/code&gt;, a highly-efficient
&lt;a href=&quot;https://github.com/alexcrichton/futures-rs/tree/master/futures-minihttp&quot;&gt;HTTP server&lt;/a&gt;
that supports TLS and uses
&lt;a href=&quot;https://crates.io/crates/httparse&quot;&gt;Hyper&amp;rsquo;s parser&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;an example
&lt;a href=&quot;https://github.com/alexcrichton/futures-rs/tree/master/futures-minihttp/tls-example&quot;&gt;use of minihttp&lt;/a&gt;
for TLS connections,&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;as well as a variety of integrations, e.g. a futures-based interface to
&lt;a href=&quot;http://alexcrichton.com/futures-rs/futures_curl&quot;&gt;curl&lt;/a&gt;. We&amp;rsquo;re actively working
with several people in the Rust community to integrate with their work; if
you&amp;rsquo;re interested, please reach out to Alex or myself!&lt;/p&gt;

&lt;p&gt;If you want to do low-level I/O programming with futures, you can use
&lt;a href=&quot;http://alexcrichton.com/futures-rs/futures_mio&quot;&gt;futures-mio&lt;/a&gt; to do so on top of
mio. We think this is an exciting direction to take async I/O programming in
general in Rust, and follow up posts will go into more detail on the mechanics.&lt;/p&gt;

&lt;p&gt;Alternatively, if you just want to speak HTTP, you can work on top of
&lt;a href=&quot;https://github.com/alexcrichton/futures-rs/tree/master/futures-minihttp&quot;&gt;minihttp&lt;/a&gt;
by providing a &lt;em&gt;service&lt;/em&gt;: a function that takes an HTTP request, and returns a
&lt;em&gt;future&lt;/em&gt; of an HTTP response. This kind of RPC/service abstraction opens the
door to writing a lot of reusable &amp;ldquo;middleware&amp;rdquo; for servers, and has gotten a lot
of traction in Twitter&amp;rsquo;s &lt;a href=&quot;https://twitter.github.io/finagle/&quot;&gt;Finagle&lt;/a&gt; library
for Scala; it&amp;rsquo;s also being used in Facebook&amp;rsquo;s
&lt;a href=&quot;https://github.com/facebook/wangle&quot;&gt;Wangle&lt;/a&gt; library. In the Rust world, there&amp;rsquo;s
already a library called
&lt;a href=&quot;https://medium.com/@carllerche/announcing-tokio-df6bb4ddb34#.g9ugbqg71&quot;&gt;Tokio&lt;/a&gt;
in the works that builds a general service abstraction on our futures library,
and could serve a role similar to Finagle.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s an enormous amount of work ahead:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;First off, we&amp;rsquo;re eager to hear feedback on the core future and stream
abstractions, and there are some specific design details for some combinators
we&amp;rsquo;re unsure about.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Second, while we&amp;rsquo;ve built a number of future abstractions around basic I/O
concepts, there&amp;rsquo;s definitely more room to explore, and we&amp;rsquo;d appreciate help
exploring it.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;More broadly, there are endless futures &amp;ldquo;bindings&amp;rdquo; for various libraries (both
in C and in Rust) to write; if you&amp;rsquo;ve got a library you&amp;rsquo;d like futures bindings
for, we&amp;rsquo;re excited to help!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Thinking more long term, an obvious eventual step would be to explore
&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; notation on top of futures, perhaps in the same way as proposed
in &lt;a href=&quot;https://tc39.github.io/ecmascript-asyncawait/&quot;&gt;Javascript&lt;/a&gt;. But we want to
gain more experience using futures directly as a library, first, before
considering such a step.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Whatever your interests might be, we&amp;rsquo;d love to hear from you &amp;ndash; we&amp;rsquo;re &lt;code&gt;acrichto&lt;/code&gt;
and &lt;code&gt;aturon&lt;/code&gt; on Rust&amp;rsquo;s
&lt;a href=&quot;https://www.rust-lang.org/en-US/community.html&quot;&gt;IRC channels&lt;/a&gt;. Come say hi!&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>The Rust Platform</title>
   <link href="http://aturon.github.io/blog/2016/07/27/rust-platform/"/>
   <updated>2016-07-27T00:00:00-07:00</updated>
   <id>http://aturon.github.io/2016/07/27/rust-platform</id>
   <content type="html">&lt;p&gt;A programming language is much more than its compiler and standard library. It&amp;rsquo;s
a community. Tools. Documentation. An ecosystem. All of these elements affect
how a language feels, its productivity, and its applicability.&lt;/p&gt;

&lt;p&gt;Rust is a very young language &amp;ndash;
&lt;a href=&quot;https://blog.rust-lang.org/2016/05/16/rust-at-one-year.html&quot;&gt;barely a year past 1.0&lt;/a&gt;
&amp;ndash; and building out and maturing the full complement of ecosystem and tooling is
crucial to its success. That building is happening, but sometimes at an
explosive rate that makes it hard to track what&amp;rsquo;s going on, to find the right
library for a task, or to choose between several options that show up on a
&lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; search. It can be hard to coordinate versions of
important libraries that all work well together. We also lack tools to push toward
maturity in a community-wide way, or to incentivize work toward a common
quality standard.&lt;/p&gt;

&lt;p&gt;On the other hand, the core parts of Rust get a &lt;em&gt;tremendous&lt;/em&gt; amount of
focus. But we have tended to be pretty conservative in what is considered
&amp;ldquo;core&amp;rdquo;: today, essentially it&amp;rsquo;s &lt;code&gt;rustc&lt;/code&gt;, &lt;code&gt;cargo&lt;/code&gt;, &lt;code&gt;libstd&lt;/code&gt;/&lt;code&gt;libcore&lt;/code&gt;, and a
couple of other crates. The standard library also takes a deliberately
minimalistic approach, to avoid the well-known pitfalls of large standard
libraries that are versioned with the compiler and quickly stagnate, while the
real action happens in the broader ecosystem (&amp;ldquo;&lt;code&gt;std&lt;/code&gt; is where code goes to die&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;In short, there are batteries out there, but we&amp;rsquo;re failing to include them&lt;/strong&gt; (or
even tell you where to shop for them).&lt;/p&gt;

&lt;p&gt;Can we provide a &amp;ldquo;batteries included&amp;rdquo; experience for Rust that doesn&amp;rsquo;t lead to
stagnation, one that instead works directly with and through the ecosystem,
focusing attention, driving compatibility, and reaching for maturity?&lt;/p&gt;

&lt;p&gt;I think we can, and I want to lay out a plan that&amp;rsquo;s emerged after discussion
with many on the core and subteams.&lt;/p&gt;

&lt;h2 id=&quot;what-is-quot-the-rust-platform-quot&quot;&gt;What is &amp;ldquo;The Rust Platform&amp;rdquo;?&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;I want to say right off the bat that the ideas here draw significant inspiration
from the &lt;a href=&quot;https://en.wikipedia.org/wiki/Haskell_Platform&quot;&gt;Haskell Platform&lt;/a&gt;,
which is working toward similar goals for Haskell.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The basic idea of the Rust Platform is simple:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Distribute a wide range of artifacts in a single &amp;ldquo;Rust Platform Package&amp;rdquo;, including:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The compiler, Cargo, rust-lang crates (e.g. &lt;code&gt;std&lt;/code&gt;, &lt;code&gt;libc&lt;/code&gt;), docs&lt;/li&gt;
&lt;li&gt;Libraries drawn from the wider ecosystem (going beyond rust-lang crates)&lt;/li&gt;
&lt;li&gt;Tools drawn from the wider ecosystem (e.g. &lt;code&gt;rustfmt&lt;/code&gt;,
&lt;a href=&quot;https://blog.rust-lang.org/2016/05/13/rustup.html&quot;&gt;NDKs&lt;/a&gt;, editor plugins,
lints)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.rust-lang.org/2016/05/13/rustup.html&quot;&gt;Cross-compilation targets&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Periodically curate the ecosystem, determining consensus choices for what
artifacts, and at what versions, to distribute.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In general, &lt;a href=&quot;https://blog.rust-lang.org/2016/05/13/rustup.html&quot;&gt;rustup&lt;/a&gt; is
intended to be the primary mechanism for distribution; it&amp;rsquo;s expected that it
will soon replace the guts of our official installers, becoming the primary way
to acquire Rust and related artifacts.&lt;/p&gt;

&lt;p&gt;As you&amp;rsquo;d expect, the real meat here is in the details. It&amp;rsquo;s probably unclear
what it even means to &amp;ldquo;distribute&amp;rdquo; a library, given Cargo&amp;rsquo;s approach to
dependency management. Read on!&lt;/p&gt;

&lt;h2 id=&quot;library-mechanics&quot;&gt;Library mechanics&lt;/h2&gt;

&lt;h3 id=&quot;cargo-metapackages&quot;&gt;Cargo metapackages&lt;/h3&gt;

&lt;p&gt;The most novel part of the proposal is the idea of curating and distributing
crates. &lt;strong&gt;The goal is to provide an experience that feels much like &lt;code&gt;std&lt;/code&gt;, but
provides much greater agility, avoiding the typical pitfalls of large standard
libraries.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The key to making sense of library &amp;ldquo;packaging&amp;rdquo; for Rust is the idea of a
&lt;em&gt;metapackage&lt;/em&gt; for Cargo, which aggregates together a number of library
dependencies as a single name and version. Concretely, this would look like:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dependencies&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;rust-platform&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;2.7&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which is effectively then shorthand for something like:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dependencies&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;mio&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;1.2&amp;quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;regex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;2.0&amp;quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;log&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;1.1&amp;quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;serde&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;3.0&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Meta packages give technical meaning to curation: we can provide assurance that
the crates within a metapackage will all play well together, at the versions
stated.&lt;/p&gt;

&lt;p&gt;With the platform metapackage, we can talk coherently about the &amp;ldquo;Rust Platform
2.0 Series&amp;rdquo; as a chapter in Rust&amp;rsquo;s evolution. After all, core libraries play a
major role in shaping the idioms of a language at a given point of time.
Evolution in these core libraries can have an effect on the experience of the
language rivaling changes to the language itself.&lt;/p&gt;

&lt;p&gt;With those basics out of the way, let&amp;rsquo;s look at the ways that the platform is,
and is not, like a bigger &lt;code&gt;std&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;stability-without-stagnation&quot;&gt;Stability without stagnation&lt;/h3&gt;

&lt;p&gt;The fact that &lt;code&gt;std&lt;/code&gt; is effectively coupled with &lt;code&gt;rustc&lt;/code&gt; means that upgrading the
compiler entails upgrading the standard library, like it or not. That means that
the two need to provide essentially the same
&lt;a href=&quot;http://blog.rust-lang.org/2014/10/30/Stability.html&quot;&gt;backwards-compatibility guarantees&lt;/a&gt;. TL;DR,
it&amp;rsquo;s simply not feasible to do a new, major version of &lt;code&gt;std&lt;/code&gt; with breaking
changes. Moreover, &lt;code&gt;std&lt;/code&gt; is forcibly tied to the Rust release schedule, meaning
that new versions arrive every six weeks, period. Given these constraints, we&amp;rsquo;ve
chosen to take a minimalist route with &lt;code&gt;std&lt;/code&gt;, to avoid accumulating a mass of
deprecated APIs over time.&lt;/p&gt;

&lt;p&gt;With the platform metapackage, things are quite different. On the one hand, we
can provide an experience that &lt;em&gt;feels&lt;/em&gt; a lot like &lt;code&gt;std&lt;/code&gt; (see below for more on
that). But it doesn&amp;rsquo;t suffer from the deficits of &lt;code&gt;std&lt;/code&gt;. Why? It all comes down
to versioning:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Stability&lt;/strong&gt;: Doing a &lt;code&gt;rustup&lt;/code&gt; to the latest platform will never break your
existing code, for one simple reason: existing &lt;code&gt;Cargo.toml&lt;/code&gt; files will be
pinned to a prior version of the platform metapackage, which is fundamentally
just a collection of normal dependencies. So you can upgrade the compiler and
toolchain, but be using an old version of the platform metapackage in perpetuity.
In short, the metapackage version is &lt;em&gt;orthogonal&lt;/em&gt; to the toolchain version.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Without stagnation&lt;/strong&gt;: Because of the versioning orthogonality, we can be
more free to make breaking changes to the platform libraries. That could come
in the form of upgrading to a new major version of one of the platform crates,
or even dropping a crate altogether. These changes are never &lt;em&gt;forced&lt;/em&gt; on users.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;But we can do even better. In practice, while code will continue working with an
old metapackage version, people are going to want to upgrade. We can smooth that
process by allowing metapackage dependencies to be &lt;em&gt;overridden&lt;/em&gt; if they appear
explicitly in the &lt;code&gt;Cargo.toml&lt;/code&gt; file. So, for example, if you say:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dependencies&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;rust-platform&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;2.7&amp;quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;regex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;3.0&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;you&amp;rsquo;re getting the versions stipulated by platform 2.7 in general, but
specifying a different version of &lt;code&gt;regex&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;There are lots of uses for this kind of override. It can allow you to track
progress of a given platform library more aggressively (not just every six
weeks), or to try out a new, experimental major version. Or you can use it to
&lt;em&gt;downgrade&lt;/em&gt; a dependency where you can otherwise transition to a new version of
the platform.&lt;/p&gt;

&lt;h3 id=&quot;approaching-std-ergonomics&quot;&gt;Approaching &lt;code&gt;std&lt;/code&gt; ergonomics&lt;/h3&gt;

&lt;p&gt;There are several steps we can take, above and beyond the idea of a metapackage,
to make the experience of using the Rust Platform libraries approximate using
&lt;code&gt;std&lt;/code&gt; itself.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;cargo new&lt;/code&gt;&lt;/strong&gt;. A simple step: have &lt;code&gt;cargo new&lt;/code&gt; automatically insert a
dependency on the current toolchain&amp;rsquo;s version of the platform.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Global coherence&lt;/strong&gt;. When we assemble a version of the platform, we can do
integration testing against the whole thing, making sure that the libraries
not only compile together, but &lt;em&gt;work&lt;/em&gt; together. Moreover, libraries in the
platform can assume the inclusion of other libraries in the platform, meaning
that example code and documentation can cross-reference between libraries,
with the precise APIs that will be shipped.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Precompilation&lt;/strong&gt;. If we implement metapackages naively, then the first time
you compile something that depends on the platform, you&amp;rsquo;re going to be
compiling some large number of crates that you&amp;rsquo;re not yet using. There are a
few ways we could solve this, but certainly one option would be to provide
binary distribution of the libraries through &lt;code&gt;rustup&lt;/code&gt; &amp;ndash; much like we already
do for &lt;code&gt;std&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;No &lt;code&gt;extern crate&lt;/code&gt;&lt;/strong&gt;. Getting a bit more aggressive, we might drop the need
for &lt;code&gt;extern crate&lt;/code&gt; when using platform crates, giving a truly &lt;code&gt;std&lt;/code&gt;-like
feel. (In general, &lt;code&gt;extern crate&lt;/code&gt; is already redundant with &lt;code&gt;Cargo.toml&lt;/code&gt; for
most use cases, so we might want to take this step broadly, anyway.)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;versioning-and-release-cadence&quot;&gt;Versioning and release cadence&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve already alluded to &amp;ldquo;major versions&amp;rdquo; of the platform in a few senses. Here&amp;rsquo;s
what I&amp;rsquo;m thinking in more detail:&lt;/p&gt;

&lt;p&gt;First off, &lt;code&gt;rustc&lt;/code&gt; itself is separately versioned. Conceivably, the Rust
Platform 5.0 ships with &lt;code&gt;rustc&lt;/code&gt; 1.89. In other words, &lt;strong&gt;a new major version of
the platform does &lt;em&gt;not&lt;/em&gt; imply breaking changes to the language or standard
library&lt;/strong&gt;. As discussed above, the metapackage approach makes it possible to
release new major versions without forcibly breaking any existing code; people
can upgrade their platform dependency orthogonally from the compiler, at their
own pace, in a fine-grained way.&lt;/p&gt;

&lt;p&gt;With that out of the way, here&amp;rsquo;s a plausible versioning scheme and cadence:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A new &lt;strong&gt;minor version&lt;/strong&gt; of the platform is released every six weeks,
essentially subsuming the existing release process. New minor releases should
only include minor version upgrades of libraries and tools (or expansions to
include new libs/tools).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A new &lt;strong&gt;major version&lt;/strong&gt; of the platform is released roughly every 18-24
months. This is the opportunity to move to new major versions of platform
libraries or to drop existing libraries. It also gives us a way to recognize
major shifts in the way you write Rust code, for example by moving to a new
set of libraries that depend on a major new language feature (say,
specialization or HKT).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;More broadly, I see major version releases as a way to lay out a &lt;em&gt;narrative arc&lt;/em&gt;
for Rust, recognizing major new chapters in its development. That&amp;rsquo;s helpful
internally, because it provides medium-term focus toward shipping The Next
Iteration of Rust, which we as a community can rally around. It&amp;rsquo;s also helpful
externally, because people less immediately involved in Rust&amp;rsquo;s development will
have a much easier way to understand the accumulation of major changes that make
up each major release. These ideas are closely tied to the recent
&lt;a href=&quot;http://aturon.github.io/blog/2016/07/05/rfc-refinement/&quot;&gt;Roadmap proposal&lt;/a&gt;,
providing a clear &amp;ldquo;north star&amp;rdquo; toward which quarterly plans can head.&lt;/p&gt;

&lt;h2 id=&quot;two-level-curation&quot;&gt;Two-level curation&lt;/h2&gt;

&lt;p&gt;So far I&amp;rsquo;ve focused on artifacts that officially ship as part of the
platform. Curating at that level is going to be a lot of work, and we&amp;rsquo;ll want to
be quite selective about what&amp;rsquo;s included. (For reference, the
&lt;a href=&quot;https://www.haskell.org/platform/&quot;&gt;Haskell Platform&lt;/a&gt; has about 35 libraries
packaged).&lt;/p&gt;

&lt;p&gt;But there are some additional opportunities for curation. What I&amp;rsquo;d love to see
is a kind of &lt;em&gt;two-level&lt;/em&gt; scheme. Imagine that, somewhere on the Rust home page,
we have a listing of major areas of libraries and tools. Think: &amp;ldquo;Parsing&amp;rdquo;,
&amp;ldquo;Networking&amp;rdquo;, &amp;ldquo;Serialization&amp;rdquo;, &amp;ldquo;Debugging&amp;rdquo;. Under each of these categories, we
have a very small number of immediate links to libraries that are part of the
official platform. But we also have a &amp;ldquo;see more&amp;rdquo; link that provides a more
comprehensive list.&lt;/p&gt;

&lt;p&gt;That leads to two tiers of curation:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Tier one&lt;/strong&gt;: shown on front page; shipped with the platform; highly curated and reviewed; driven
by community consensus; integration tested and cross-referenced with the rest
of the platform.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Tier two&lt;/strong&gt;: shown in &amp;ldquo;see more&amp;rdquo;; lightly curated, according to a clearly
stated set of objective criteria. Things like: platform compatibility; CI;
documentation; API conventions; versioned at 1.0 or above.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;By providing two tiers, we release some of the pressure around being in the
platform proper, and we provide valuable base-level quality curation and
standardization across the ecosystem. The second tier gives us a way to motivate
the ecosystem toward common quality and consistency goals: anyone is welcome to
get their crate on a &amp;ldquo;see more&amp;rdquo; page, but they have to meet a minimum bar
first.&lt;/p&gt;

&lt;h2 id=&quot;the-rust-lang-crates&quot;&gt;The &lt;code&gt;rust-lang&lt;/code&gt; crates&lt;/h2&gt;

&lt;p&gt;One small note: our previous attempt at a kind of &amp;ldquo;extended &lt;code&gt;std&lt;/code&gt;&amp;rdquo; was the
&lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/1242&quot;&gt;rust-lang crates&lt;/a&gt; concept. These
crates are &amp;ldquo;owned&amp;rdquo; by the Rust community, and governed by the RFC process, much
like &lt;code&gt;std&lt;/code&gt;. They&amp;rsquo;re also held to similar quality standards.&lt;/p&gt;

&lt;p&gt;Ultimately, it&amp;rsquo;s proved pretty heavy weight to require full RFCs and central
control over central crates, and so the set of rust-lang crates has grown
slowly. The platform model is more of a &amp;ldquo;federated&amp;rdquo; approach, providing
decentralized ownership and evolution, while periodically trying to pull
together a coherent global story.&lt;/p&gt;

&lt;p&gt;However, I expect the rust-lang crates to stick around, and for the set to
slowly grow over time; there is definitely scope for some very important crates
to be completely &amp;ldquo;owned by the community&amp;rdquo;. These crates would automatically be
part of the platform, having been approved via the RFC process already.&lt;/p&gt;

&lt;h2 id=&quot;open-questions&quot;&gt;Open questions&lt;/h2&gt;

&lt;p&gt;The biggest open question here is: how does curation work? Obviously, it can&amp;rsquo;t
run entirely through the libs team; that doesn&amp;rsquo;t scale, and the team doesn&amp;rsquo;t
have the needed domain expertise anyway.&lt;/p&gt;

&lt;p&gt;What I envision is something that fits into the
&lt;a href=&quot;http://aturon.github.io/blog/2016/07/05/rfc-refinement/&quot;&gt;Roadmap planning proposal&lt;/a&gt;. In
a given quarter, we set out as an initiative to curate crates in a few areas &amp;ndash;
let&amp;rsquo;s say, networking and parsing. During that quarter, the libs team works
closely with the portion of the community actively working in that space, acting
as API consultants and reviewers, and helping shepherd consensus toward a
reasonable selection. There are a lot of details to sort out, but working in an
incremental way (a sort of quarterly round-robin between areas) seems like a
good balance between focus and coverage. But there are a lot of details to sort out.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s also not entirely clear what will need to go into each minor
release. Hopefully it can be kept relatively minimal (e.g., with library/tool
maintainers largely driving the version choice for a given minor release).&lt;/p&gt;

&lt;h2 id=&quot;wrap-up&quot;&gt;Wrap-up&lt;/h2&gt;

&lt;p&gt;Although the mechanics are not all that earth-shattering, I think that
introducing the Rust Platform could have a massive impact on how the Rust
community works, and on what life as a Rust user feels like. It tells a clear
story about Rust&amp;rsquo;s evolution, and lets us rally around that story as we hammer
out the work needed to bring it to life. I&amp;rsquo;m eager to hear what you think!&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Refining Rust's RFCs</title>
   <link href="http://aturon.github.io/blog/2016/07/05/rfc-refinement/"/>
   <updated>2016-07-05T00:00:00-07:00</updated>
   <id>http://aturon.github.io/2016/07/05/rfc-refinement</id>
   <content type="html">&lt;p&gt;At the heart of Rust&amp;rsquo;s open development is the &lt;strong&gt;RFC process&lt;/strong&gt;. Every major
change to the language, compiler, core libraries, tooling, and policy go through
an RFC writeup and consensus-building process. The process served us incredibly
well in clarifying our technical direction on the road to 1.0, and has continued
to be highly active since then, with on average about 2 RFCs merged every week.&lt;/p&gt;

&lt;p&gt;But it&amp;rsquo;s not all roses. There&amp;rsquo;s been a growing sense among both Rust leadership
and the broader community that the RFC process needs some further refinement as
we continue to grow the community. I want to lay out my view of the problems and
sketch some possible solutions, based on extensive discussion and brainstorming
with many others on the team.&lt;/p&gt;

&lt;p&gt;Each idea operates at a different scale (from big-picture to low-level
mechanics), but they are intended to fit together into a whole; each one
supports the others. Ultimately, these should result in a single RFC, but in the
meantime I&amp;rsquo;ll start a discuss thread for each proposal.&lt;/p&gt;

&lt;p&gt;There is a clear common theme to all of the problems I want to raise:
&lt;strong&gt;communication&lt;/strong&gt;. We need to find ways to better scale up lines of
communication around the RFC process, and for Rust core development in general.
There is also a cross-cutting concern: a need to increase our focus
on &lt;strong&gt;mentoring&lt;/strong&gt; and &lt;strong&gt;the path to team membership&lt;/strong&gt;. @wycats has a great saying
about measuring the health of the team structure:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Being a very active contributor who is not yet on a subteam should feel very
close to actually being on that subteam.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Shooting for such a state of affairs has many benefits, not least of which
is increasing the scalability of our community.&lt;/p&gt;

&lt;h2 id=&quot;proposal-roadmap&quot;&gt;Proposal: Roadmap&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://internals.rust-lang.org/t/refining-rfcs-part-1-roadmap/3656/1&quot;&gt;Discuss link&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;the-problem&quot;&gt;The problem&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Lack of clear rallying points&lt;/strong&gt;. One thing that made the run-up to the 1.0
release so exhilarating was the way the release focused our effort: there was a
big overarching goal we were all working toward, which led to a number of fairly
clear-cut subgoals that everyone could pitch in on.&lt;/p&gt;

&lt;p&gt;Since then, though, we&amp;rsquo;ve never had quite as clear of a &amp;ldquo;north star&amp;rdquo;. We&amp;rsquo;ve
communicated some
&lt;a href=&quot;http://blog.rust-lang.org/2015/08/14/Next-year.html&quot;&gt;very high-level plans&lt;/a&gt;,
and had success rallying efforts around self-contained projects like
&lt;a href=&quot;http://blog.rust-lang.org/2016/04/19/MIR.html&quot;&gt;MIR&lt;/a&gt;. But we don&amp;rsquo;t have a
systematic way of rallying our efforts around important goals on a regular
basis. This gap is a shame, because there are many people eager to contribute,
who we should be directing toward common, important goals with good mentoring
opportunities. Likewise, there are lots of people who could provide useful
perspective on goals, or even provide leadership on initiatives, who don&amp;rsquo;t have
an outlet today.&lt;/p&gt;

&lt;p&gt;Relatedly, it can be difficult to contribute at the RFC level. Is the problem
you want to solve a priority for the relevant team or wider community? When it
comes to the core language, there is only so much design work that can be in
flight at once (since it all needs to fit together), so &lt;strong&gt;greater clarity on
priorities and motivations is essential&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;the-proposal&quot;&gt;The proposal&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Idea&lt;/strong&gt;: publish a &lt;em&gt;roadmap&lt;/em&gt; on a regular cadence, e.g. every two release
  cycles (12 weeks).&lt;/p&gt;

&lt;p&gt;The roadmap would contain, at a minimum, a &lt;em&gt;small&lt;/em&gt; set of &amp;ldquo;major initiatives&amp;rdquo; for
that period. An initiative might cover any phase of development, e.g.:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Early investigation&lt;/em&gt;: For example,
&lt;a href=&quot;http://blog.rust-lang.org/2016/05/13/rustup.html&quot;&gt;building out NDK support in rustup&lt;/a&gt;
or exploring implications of various memory model choices.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Design&lt;/em&gt;: For example, working out a revised design for &lt;code&gt;rand&lt;/code&gt; or const generics.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Implementation&lt;/em&gt;: For example, the
&lt;a href=&quot;http://blog.rust-lang.org/2016/04/19/MIR.html&quot;&gt;MIR initiative&lt;/a&gt; or
&lt;a href=&quot;https://internals.rust-lang.org/t/the-rustbuild-feature-thread/3643/&quot;&gt;rustbuild&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Documentation&lt;/em&gt;: For example, focused effort on updating API docs in a portion
of the standard library.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Community&lt;/em&gt;: For example, launching
&lt;a href=&quot;https://github.com/rust-community/rustbridge&quot;&gt;RustBridge&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And potentially many other categories as well.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Initiatives are intended to be a primary rallying point for the community&lt;/strong&gt;,
  and thus should share some basic traits:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Clear scope&lt;/strong&gt;: an initiative should have clear-cut goals that can actually
be &lt;em&gt;finished&lt;/em&gt;. So, an open-ended goal like &amp;ldquo;MIR&amp;rdquo; doesn&amp;rsquo;t fly, but &amp;ldquo;Get
MIR-trans working on all of crates.io&amp;rdquo; does.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Timeboxed&lt;/strong&gt;: relatedly, an initiative should realistically last at most,
say, 24 weeks (two roadmaps).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Commitment&lt;/strong&gt;: There should be some level of commitment from multiple people
to actually work on the initiative. In particular, the initiative should list
some primary points of contact, and ideally mentors.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Each initiative would have a dedicated status page with this information, links
to issues or other materials, and potentially a FAQ. We&amp;rsquo;ve often found that
there are recurring questions (&amp;ldquo;When is MIR going to be turned on by default?&amp;rdquo;)
about big, ongoing work. The roadmap and status pages give us a highly visible,
central and curated place to put this information.&lt;/p&gt;

&lt;p&gt;The roadmap should be set via an open consensus process in which anyone can
propose or influence initiatives. The initiatives should fit criteria like those
listed above, and should also fit into an overall vision for Rust&amp;rsquo;s evolution
over a longer period.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Details to be worked out&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Cadence&lt;/li&gt;
&lt;li&gt;Can initiatives be added mid-stream?&lt;/li&gt;
&lt;li&gt;Full guidelines for initiatives; how many should be in flight at once? Needs
to be a small number to make this practical and useful (it&amp;rsquo;s a form of
curation/rallying).&lt;/li&gt;
&lt;li&gt;What is the process for deciding on the initiatives?&lt;/li&gt;
&lt;li&gt;Do we divvy things up by subteam? That would make the discussion easier, but
doesn&amp;rsquo;t allow for cross-cutting initiatives very easily.&lt;/li&gt;
&lt;li&gt;Can we find less boring terms than &amp;ldquo;Roadmap&amp;rdquo; and &amp;ldquo;Initiative&amp;rdquo;?&lt;/li&gt;
&lt;li&gt;Can we also include the &amp;ldquo;feature pipeline&amp;rdquo; and other long-running concerns
into a roadmap somehow?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;proposal-rfc-staging&quot;&gt;Proposal: RFC staging&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://internals.rust-lang.org/t/refining-rfcs-part-2-rfc-staging/3657/1&quot;&gt;Discuss link&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;the-problem&quot;&gt;The problem&lt;/h3&gt;

&lt;p&gt;RFCs are hard to keep up with in part because reading a full design &amp;ndash; and all
the commentary around it &amp;ndash; can be a lot of work, and there tend to be a large
number of active RFCs in flight at any time. &lt;strong&gt;RFC discussions are often hard to
follow, due to the overwhelming number of comments, sometimes stretching over
multiple forums.&lt;/strong&gt; Naturally, this problem is exacerbated by &amp;ldquo;controversial&amp;rdquo;
RFCs, which is where we most need broad input and careful discussion. It can
also be hard to track RFCs that are in some sense &amp;ldquo;competing&amp;rdquo; (offering
alternative proposals for a common problem), or to correlate discussion between
the discuss forum and github.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s also problematic to start off with a full proposal. What we really want is
to get the community on the same page first about the importance of the problem
being solved, and &lt;em&gt;then&lt;/em&gt; to proceed to the design phase, perhaps considering
multiple competing designs.&lt;/p&gt;

&lt;p&gt;Finally, RFCs are sometimes closed as &amp;ldquo;postponed&amp;rdquo;, but ideally that should not
simply &lt;em&gt;terminate&lt;/em&gt; the discussion; instead, the discussion should simply
continue elsewhere, or somehow be marked as being at a different stage.&lt;/p&gt;

&lt;h3 id=&quot;the-proposal&quot;&gt;The proposal&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Idea&lt;/strong&gt;: introduce stages into the RFC process, including one for reaching
  consensus on &lt;em&gt;motivation&lt;/em&gt; prior to considering a design.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Idea&lt;/strong&gt;: move the focus away from an RFC PR as the primary venue for RFC
  discussion.&lt;/p&gt;

&lt;p&gt;Put differently, the idea is to orient the RFC process around &lt;em&gt;problems&lt;/em&gt; first,
and solutions second.&lt;/p&gt;

&lt;p&gt;The rough phases I have in mind are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Problem consensus&lt;/li&gt;
&lt;li&gt;RFC drafting&lt;/li&gt;
&lt;li&gt;RFC PR(s)&lt;/li&gt;
&lt;li&gt;FCP&lt;/li&gt;
&lt;li&gt;RFC merged&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Concretely, what this would look like is having some venue for tracking the
problems we might want to solve, perhaps a revamped version of the RFC issue
tracker. Whatever this venue is, it would track the progression through all of
the phases. Let&amp;rsquo;s call this venue the &amp;ldquo;Problem Tracker&amp;rdquo;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Phase 1: Problem consensus&lt;/em&gt;. The initial discussion is essentially about
&lt;strong&gt;reaching consensus on the motivation section of an RFC&lt;/strong&gt;, which should include
examples and make a compelling case that solving the problem is important enough
to warrant expending energy and potential complexity. The subteam would sign off
on that motivation, at which point there is some level of commitment to solve
the problem. That puts the focus where it should be &amp;ndash; solving problems &amp;ndash; and
should make it much easier for subteam members to engage early on in the RFC
lifecycle.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Phase 2: RFC drafting&lt;/em&gt;. This phase can proceed in parallel with the previous
one. During this phase, people sketch designs and work toward one or more full
RFC drafts. Brainstorming and discussion on specific drafts would happen
within dedicated &amp;ldquo;pre-RFC&amp;rdquo; &lt;a href=&quot;http://internals.rust-lang.org/&quot;&gt;discuss posts&lt;/a&gt;,
which are linked from the Problem Tracker. In particular, newly-opened RFC PRs
today often get an avalanche of comments and early revisions, making it very
hard to join the discussion even a week later. Pushing early feedback to our
forum instead will make the eventual RFC PR discussion more focused and easier
to participate in.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Phase 3: RFC PR(s)&lt;/em&gt;. At some point, a &lt;em&gt;shepherd&lt;/em&gt; (see below) can determine
that an RFC draft is of sufficiently high quality and steady state that a PR
should be opened, at which point discussion proceeds as it does
today. Multiple RFC PRs might be open for the same basic problem &amp;ndash; and
indeed, this is a good way to take the &amp;ldquo;Alternatives&amp;rdquo; section more
seriously. All open PRs would be linked from the Problem Tracker.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Phases 4 and 5 work just as today.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;One interesting aspect of this phasing: it&amp;rsquo;s possible to approve a Motivation
section, then get all the way to RFC PR, only to close out the PR for one reason
or another. In such cases, it should be possible to go back to the Problem
Tracker and build a new, alternative RFC draft with the same Motivation section.&lt;/p&gt;

&lt;p&gt;Note that, in this regime, you don&amp;rsquo;t ever open an RFC PR out of hand &amp;ndash; it must
go through the earlier phases, including the pre-RFC discuss post. While this
may feel like more process, I think that globally it will make the whole thing
more efficient, by weeding out poorly motivated RFCs earlier, by focusing
attention on the problem, by producing higher quality RFC PRs, and (as we&amp;rsquo;ll
see) by decentralizing the process a bit more. In addition, it makes it easier
to cope with the problem of &amp;ldquo;Does this need an RFC?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;As part of this proposal, &lt;strong&gt;I think we should &amp;ldquo;reboot&amp;rdquo; the notion of a
&lt;em&gt;shepherd&lt;/em&gt;.&lt;/strong&gt; The idea would be to create a broader network of people around a
subteam who are empowered to help move the RFC process along in various ways,
but aren&amp;rsquo;t necessarily responsible for the final decision. So, for example, we
would have a larger set of &amp;ldquo;lang shepherds&amp;rdquo; who help lang RFCs progress. The
powers and responsibilities of shepherds would include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&amp;ldquo;Calling to question&amp;rdquo; &amp;ndash; that is, proposing that the subteam move to make a
decision on problem consensus or moving to FCP.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Working with the community to help brainstorm, draft, and revise pre-RFCs.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Moving to from pre-RFC to RFC PR phase.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Acting as the &amp;ldquo;scribe&amp;rdquo; for the RFC process, by keeping the Problem Tracker up
to date. In particular, the subteams currently attempt to provide &amp;ldquo;summary&amp;rdquo;
comments for contentious RFCs, to help people track the discussion. This
proposal would give those comments more formal status, as something that would
go directly on the Problem Tracker, and that any shepherd could provide at any
point.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All subteam members can act as shepherds as well.&lt;/p&gt;

&lt;p&gt;In general, I envision the Problem Tracker as the go-to place to see where
things stand for a given problem/set of proposals, including summarization of
discussion and pros/cons for the proposals. The shepherds would play a special
role in establishing that official record.&lt;/p&gt;

&lt;p&gt;I think these changes make the RFC process both more accessible and more
scalable. More accessible because it&amp;rsquo;s easier to get involved and get quick
feedback in lightweight ways (before writing up an entire design). More scalable
because of increased parallelism, and because the big decision points happen at
either an easier stage (establishing motivation) or with many fewer proposals in
flight (the RFC PR stage).&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Details to be worked out&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;What happens to current RFC PRs? Are they grandfathered in, or moved into this
new process?&lt;/li&gt;
&lt;li&gt;Where does the &amp;ldquo;problem tracker&amp;rdquo; live?&lt;/li&gt;
&lt;li&gt;What are good guidelines around an initial &amp;ldquo;motivation&amp;rdquo;?&lt;/li&gt;
&lt;li&gt;How and where can we keep an &amp;ldquo;official record&amp;rdquo; of the progression of a
problem, including links to (and summaries of) pre-RFC and RFC PR threads?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;proposal-async-decisions&quot;&gt;Proposal: Async decisions&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://internals.rust-lang.org/t/refining-rfcs-part-3-async-decisions/3658/1&quot;&gt;Discuss link&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;the-problem&quot;&gt;The problem&lt;/h3&gt;

&lt;p&gt;There is room for improvement around the way that the subteams themselves
work. Today, subteams reach decisions on RFCs and other issues in (bi)weekly
meetings. There are at least two problems with doing so. First, since the
meetings have a limited duration, &lt;strong&gt;we often run out of time without finishing
the active business, introducing delays&lt;/strong&gt;; similarly, because of the high amount
of RFC activity, &lt;strong&gt;the subteams often operate in &amp;ldquo;reactive&amp;rdquo; mode, more than
actively leading&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Another issue is that meetings provide, in some sense, the &amp;ldquo;wrong defaults&amp;rdquo; for
making decisions. We have to be careful to ensure that all the rationale for a
decision is present in the online discussion thread, and that any new rationale
that came up during a meeting means that the decision is delayed, to give the
full community a chance to respond. The point is that, &lt;strong&gt;while we work hard to
provide this transparency, it requires that extra work&lt;/strong&gt;. At the same time,
there is often good discussion in meetings wherein the subteam members build up
a set of shared values &amp;ndash; thereby missing the opportunity to argue for those
values to the wider community. Finding a way to move decision-making to a more
public, asynchronous system seems ideal, though meetings &lt;em&gt;do&lt;/em&gt; have the benefit
of providing a steady cadence to ensure that business is getting done.&lt;/p&gt;

&lt;h3 id=&quot;the-proposal&quot;&gt;The proposal&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Idea&lt;/strong&gt;: move away from video meetings for decision-making, instead reaching
  decisions entirely in the associated comment threads.&lt;/p&gt;

&lt;p&gt;By moving the decision-making process fully online, we make it transparent by
default. That is not to say that subteam members &amp;ndash; or anyone else &amp;ndash; will never
have private conversation, of course. Just that this particular bit of business
is better conducted online.&lt;/p&gt;

&lt;p&gt;The key to making this work is automation. Right now, the meetings provide a
convenient &amp;ldquo;forcing function&amp;rdquo; to ensure that decisions are being reached in a
somewhat timely fashion. To ensure that we still make steady progress, we need a
&lt;em&gt;dashboard&lt;/em&gt; for every subteam member, showing them precisely what outstanding
items they need to weigh in on &amp;ndash; and that list needs to be kept manageably
short.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll need a dashboard tool that can pick up on special text from subteam
members for:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Calling an RFC/issue into FCP

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;process: fcp&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Approving/disapproving FCP

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;process: fcp r+&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;process: fcp r-&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Extending FCP

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;process: fcp extend&amp;rdquo; (for one more week by default; possibly give parameter?)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Approving stabilization/RFC merging

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;process: r+&amp;rdquo; (ideally followed up by some commentary)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Weakly objecting

&lt;ul&gt;
&lt;li&gt;Just leave a comment, followed by a &amp;ldquo;process: r+&amp;rdquo; once you are satisfied
that the objection is addressed or that it&amp;rsquo;s OK not to address it.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Strongly objecting (i.e. blocking acceptance)

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;process: r-&amp;rdquo; (followed up with objection)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Abstaining (possibly?)

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;process: ack&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The dashboard tool would track the current status of RFCs/issues facing a
decision, and would track the various timelines involved, e.g. that RFC FCP
lasts for one week.&lt;/p&gt;

&lt;p&gt;We can and should continue to hold video subteam meetings (they&amp;rsquo;re high
bandwidth!), but for more forward-looking purposes: discussing specific
early-stage RFCs, brainstorming, and prioritization. We can explore recording
these meetings, and potentially opening them up to additional stakeholders who
are not part of the subteam.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Details to be worked out&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A plausible story for automation that retains the consensus process and is
likely to keep things moving.&lt;/li&gt;
&lt;li&gt;Can the automation itself be responsible for moving to FCP/merging? Or at
least provide a pushbutton way for doing so?&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Resurrecting impl Trait</title>
   <link href="http://aturon.github.io/blog/2015/09/28/impl-trait/"/>
   <updated>2015-09-28T00:00:00-07:00</updated>
   <id>http://aturon.github.io/2015/09/28/impl-trait</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt;: since before Rust 1.0, we&amp;rsquo;ve wanted to be able to return an unboxed
closure or avoid spelling out huge iterator types. This blog post revives the
old &lt;code&gt;impl Trait&lt;/code&gt; proposal, and discusses the broad tradeoffs between two
different ways of carrying it out.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Heads up&lt;/strong&gt;: I&amp;rsquo;m going to gloss over some details in this post, in the interest
of getting across the high-level situation as I see it. Of course, any actual
proposal will need to address the questions that I skip over.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;: I removed the &amp;ldquo;elision&amp;rdquo; terminology, which was more confusing than
helpful. I also now mention some implementation issues for the return type
inference proposal. And I&amp;rsquo;ve toned down my preference in the wrapup; I&amp;rsquo;m
becoming less certain :)&lt;/p&gt;

&lt;h2 id=&quot;the-original-proposal&quot;&gt;The original proposal&lt;/h2&gt;

&lt;p&gt;This post is about a topic near-and-dear to me &amp;ndash; my
&lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/105&quot;&gt;first Rust RFC&lt;/a&gt;! &amp;ndash; which is known
as the &amp;ldquo;&lt;code&gt;impl Trait&lt;/code&gt;&amp;rdquo; proposal. The RFC termed these &amp;ldquo;unboxed abstract types&amp;rdquo;,
and it&amp;rsquo;s easiest to start with the motivation given there:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In today&amp;rsquo;s Rust, you can write a function signature like&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;consume_iter_static&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;consume_iter_dynamic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Box&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In both cases, the function does not depend on the exact type of the argument.
The type is held &amp;ldquo;abstract&amp;rdquo;, and is assumed only to satisfy a trait bound.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;In the &lt;code&gt;_static&lt;/code&gt; version using generics,
each use of the function is specialized to a concrete, statically-known type,
giving static dispatch, inline layout, and other performance wins.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In the &lt;code&gt;_dynamic&lt;/code&gt; version using trait objects, the concrete argument type is
only known at runtime using a vtable.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;On the other hand, while you can write&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;produce_iter_dynamic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Box&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;you &lt;em&gt;cannot&lt;/em&gt; write something like&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;produce_iter_static&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That is, in today&amp;rsquo;s Rust, abstract return types can only be written using trait objects, which
can be a significant performance penalty. This RFC proposes &amp;ldquo;unboxed abstract
types&amp;rdquo; as a way of achieving signatures like &lt;code&gt;produce_iter_static&lt;/code&gt;. Like
generics, unboxed abstract types guarantee static dispatch and inline data
layout.&lt;/p&gt;

&lt;p&gt;Here are some problems that unboxed abstract types solve or mitigate:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Returning unboxed closures&lt;/em&gt;. The ongoing work on unboxed closures expresses
closures using traits. Sugar for closures generates an anonymous type
implementing a closure trait. Without unboxed abstract types, there is no way
to use this sugar while returning the resulting closure unboxed, because there
is no way to write the name of the generated type.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Leaky APIs&lt;/em&gt;. Functions can easily leak implementation details in their return
type, when the API should really only promise a trait bound. For example, a
function returning &lt;code&gt;Rev&amp;lt;Splits&amp;lt;&amp;#39;a, u8&amp;gt;&amp;gt;&lt;/code&gt; is revealing exactly how the iterator
is constructed, when the function should only promise that it returns &lt;em&gt;some&lt;/em&gt;
type implementing &lt;code&gt;Iterator&amp;lt;u8&amp;gt;&lt;/code&gt;. Using newtypes/structs with private fields
helps, but is extra work. Unboxed abstract types make it as easy to promise only
a trait bound as it is to return a concrete type.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Complex types&lt;/em&gt;. Use of iterators in particular can lead to huge types:&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;  &lt;span class=&quot;n&quot;&gt;Chain&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&amp;#39;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;u16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Enumerate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Filter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&amp;#39;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MoveItems&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SkipWhile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&amp;#39;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;u16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&amp;#39;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;u16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;u16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slice&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Items&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;u16&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Even when using newtypes to hide the details, the type still has to be written
  out, which can be very painful. Unboxed abstract types only require writing the
  trait bound.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Documentation&lt;/em&gt;. In today&amp;rsquo;s Rust, reading the documentation for the &lt;code&gt;Iterator&lt;/code&gt;
trait is needlessly difficult. Many of the methods return new iterators, but
currently each one returns a different type (&lt;code&gt;Chain&lt;/code&gt;, &lt;code&gt;Zip&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Filter&lt;/code&gt;,
etc), and it requires drilling down into each of these types to determine what
kind of iterator they produce.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In short, unboxed abstract types make it easy for a function signature to
promise nothing more than a trait bound, and do not generally require the
function&amp;rsquo;s author to write down the concrete type implementing the bound.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So, the RFC began with the framing that there was a kind of &amp;ldquo;gap&amp;rdquo; in the
expressiveness matrix: we can choose between static and dynamic dispatch for
inputs, but not for outputs.&lt;/p&gt;

&lt;p&gt;The RFC went on to propose the &lt;code&gt;impl Trait&lt;/code&gt; notation as a way of solving these
problems:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The basic idea is to allow code like the following:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;produce_iter_static&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;skip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where &lt;code&gt;impl Iterator&amp;lt;u8&amp;gt;&lt;/code&gt; should be understood as &amp;ldquo;some type &lt;code&gt;T&lt;/code&gt; such that &lt;code&gt;T:
Iterator&amp;lt;u8&amp;gt;&lt;/code&gt;.  Notice that the function author does not have to write down any
concrete iterator type, nor does the function&amp;rsquo;s signature reveal those details
to its clients. But the type promises that &lt;em&gt;there exists&lt;/em&gt; some concrete type.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The point here is to avoid writing a return type like&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;n&quot;&gt;iter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Skip&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;&amp;#39;static&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Range&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and instead give only the relevant information: some trait(s) that are
implemented for the return type.&lt;/p&gt;

&lt;p&gt;For a variety of reasons the RFC was closed and the feature has not shipped.
But part of the impetus for returning to this topic now is that the illustrious
@eddyb has a working implementation of a subset of the RFC! Ideally, the Rust
community can come to a consensus around a design, and we can adapt and land
this implementation.&lt;/p&gt;

&lt;h2 id=&quot;design-questions&quot;&gt;Design questions&lt;/h2&gt;

&lt;p&gt;As it turns out, though, there are a lot of complex issues and decisions at play
here, and as usual, multiple interesting points in the design space. Some of
these were brought up in the RFC itself, others brought up on thread, and others
haven&amp;rsquo;t really been discussed. But they all have to be tackled.&lt;/p&gt;

&lt;p&gt;First I&amp;rsquo;ll go quickly through the main questions, then talk about design
priorities, and finally present two possible designs.&lt;/p&gt;

&lt;h3 id=&quot;is-impl-trait-a-type&quot;&gt;Is &lt;code&gt;impl Trait&lt;/code&gt; a type?&lt;/h3&gt;

&lt;p&gt;Can &lt;code&gt;impl Trait&lt;/code&gt; appear everywhere a type can?&lt;/p&gt;

&lt;p&gt;If not, where &lt;em&gt;can&lt;/em&gt; &lt;code&gt;impl Trait&lt;/code&gt; be used? Only return types? What about arguments, struct
definitions, type aliases, etc? In each case, what should the semantics be?&lt;/p&gt;

&lt;p&gt;The RFC gave answers to many of these questions, although I think today I would
answer some of them differently.&lt;/p&gt;

&lt;h3 id=&quot;is-impl-trait-quot-sealed-quot&quot;&gt;Is &lt;code&gt;impl Trait&lt;/code&gt; &amp;quot;sealed&amp;rdquo;?&lt;/h3&gt;

&lt;p&gt;As @Ericson2314 astutely remarked on thread:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This RFC is trying to serve up type inference and type abstraction as one
feature, when they are orthogonal.&lt;/p&gt;

&lt;p&gt;Inference-wise, we want to introduce meta-variables/unknowns where we are are not allowed to today.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BigLongIterator&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Abstraction-wise, we want to give ourselves more leeway to change our libraries without breaking client code.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;kn&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nsa&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Works with any T!&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;abs&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Iter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SnoopWhile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;Here &amp;ldquo;type inference&amp;rdquo; means something akin to leaving off a type
annotation that&amp;rsquo;s required today (like the return type of a function),
without any change to semantics.  By contrast, &amp;ldquo;type abstraction&amp;rdquo;
means &lt;em&gt;hiding&lt;/em&gt; some information about a type from clients, similarly
to what we often do with
&lt;a href=&quot;http://aturon.github.io/features/types/newtype.html&quot;&gt;newtypes&lt;/a&gt;
today. The original proposal coupled these two features together.&lt;/p&gt;

&lt;p&gt;This is going to turn out to be a central question for this blog post. &lt;em&gt;Should&lt;/em&gt;
these two aspects of the feature be treated separately or coupled? Are both
needed? What are the tradeoffs?&lt;/p&gt;

&lt;h3 id=&quot;how-do-you-deal-with-clone-or-iterator-adapters&quot;&gt;How do you deal with &lt;code&gt;Clone&lt;/code&gt; or &lt;code&gt;Iterator&lt;/code&gt; adapters?&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s pretty common that a trait is &lt;em&gt;conditionally&lt;/em&gt; implemented:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Clone&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Clone&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But that poses a problem for &lt;code&gt;impl Trait&lt;/code&gt;, which requires an &lt;em&gt;unconditional&lt;/em&gt;
statement about which traits are implemented. This is especially painful for
things like the iterator adapters, which are often &lt;code&gt;Clone&lt;/code&gt; if the original
iterator is, &lt;code&gt;DoubleEndedIterator&lt;/code&gt; if the original iterator is, etc.&lt;/p&gt;

&lt;h3 id=&quot;do-marker-traits-send-sync-have-to-be-mentioned&quot;&gt;Do marker traits (&lt;code&gt;Send&lt;/code&gt;, &lt;code&gt;Sync&lt;/code&gt;, &amp;hellip;) have to be mentioned?&lt;/h3&gt;

&lt;p&gt;When you use the
&lt;a href=&quot;http://aturon.github.io/features/types/newtype.html&quot;&gt;newtype pattern&lt;/a&gt; today,
you have to explicitly forward most traits, but certain traits like &lt;code&gt;Send&lt;/code&gt; and
&lt;code&gt;Sync&lt;/code&gt; will &lt;em&gt;automatically&lt;/em&gt; be implemented for the new type if they were for the
old type. Should &lt;code&gt;impl Trait&lt;/code&gt; work similarly, implicitly carrying the markers?&lt;/p&gt;

&lt;p&gt;This is not just a question of ergonomics, though the ergonomic issue here is
significant! There&amp;rsquo;s also an extensibility problem: new libraries can add new
&amp;ldquo;OIBIT&amp;rdquo;-style marker traits which are supposed to automatically apply to types,
but forcing those markers to be explicitly opted in to for &lt;code&gt;impl Trait&lt;/code&gt; means
they often won&amp;rsquo;t apply. We&amp;rsquo;ve already seen significant problems along these
lines with trait objects today.&lt;/p&gt;

&lt;h2 id=&quot;design-constraints&quot;&gt;Design constraints&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;m going to be a bit opinionated here and lay out some design desires.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hard constraints&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;must be possible to return an unboxed closure and store it in a struct&lt;/li&gt;
&lt;li&gt;must be possible to return a compound iterator without giving the type explicitly&lt;/li&gt;
&lt;li&gt;must cope with &lt;em&gt;multiple&lt;/em&gt; such types appearing as &lt;em&gt;components&lt;/em&gt; of a return
type (e.g., returning a pair of different unboxed closures)&lt;/li&gt;
&lt;li&gt;must be able to assert that at least &lt;em&gt;some&lt;/em&gt; traits are satisfied&lt;/li&gt;
&lt;li&gt;must be able to deal with conditional trait implementations&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Strong desires&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;minimal signature verbosity&lt;/li&gt;
&lt;li&gt;compatible with adding new OIBITs&lt;/li&gt;
&lt;li&gt;simple semantics/explanation of the feature, especially if it looks like a type&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Nice to haves&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;type abstraction (the &amp;ldquo;hiding&amp;rdquo; that @Ericson2314 was talking about)&lt;/li&gt;
&lt;li&gt;more ergonomic newtypes (where you don&amp;rsquo;t have to forward trait impls explicitly)&lt;/li&gt;
&lt;li&gt;applicable to struct definitions, not just function signatures&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;option-1-return-type-inference&quot;&gt;Option 1: return type inference&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ll start with the simpler design: attack only the type inference aspect of the
original proposal, without actually hiding any details about a type from clients.&lt;/p&gt;

&lt;p&gt;The simplest way to do this would be to allow wildcards to leave off types in return
position:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;skip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;first closure&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
     &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;second closure&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The idea here is that the actual return type is fully concrete &amp;ndash; clients of the
API know exactly what it is, and can take advantage of public inherent methods or
arbitrary traits.&lt;/p&gt;

&lt;p&gt;But a pure wildcard proposal is a pretty drastic step away from our policy of
explicitness for signatures and type definitions. In particular, it doesn&amp;rsquo;t lead
to a very informative signature for clients of the API.&lt;/p&gt;

&lt;p&gt;A more palatable choice would be something closer to &lt;code&gt;impl Trait&lt;/code&gt;, like:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;skip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FnOnce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FnOnce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;first closure&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
     &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;second closure&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The idea is that these trait bounds don&amp;rsquo;t say &lt;em&gt;everything&lt;/em&gt; about the concrete
type, but they give some trait bounds that must hold of the concrete type. (So
&lt;code&gt;~FnOnce()&lt;/code&gt; means &amp;ldquo;an elided type with interface roughly &lt;code&gt;FnOnce()&lt;/code&gt;&amp;rdquo;.) Usually,
there is one &amp;ldquo;primary&amp;rdquo; trait for a given return type, though of course you can
list as many as you like using &lt;code&gt;+&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If I have my druthers, this feature would also be usable in argument position:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FnOnce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To be clear about the &amp;ldquo;roughly&amp;rdquo; here: in the &lt;code&gt;foo&lt;/code&gt; example, the return type also
implements &lt;code&gt;Clone&lt;/code&gt; and &lt;code&gt;ExactSizeIterator&lt;/code&gt; &amp;ndash; and client code can rely on those
facts, despite them not being written down.&lt;/p&gt;

&lt;p&gt;On the one hand, this approach is uncomfortably implicit (since bounds can be
left off), and it may leak information about the type that we do not
intend.&lt;/p&gt;

&lt;p&gt;There are also some implementation concerns &amp;ndash; the typechecker will need to
check function definitions in a particular order to discover concrete types, and
must ensure that return type inference isn&amp;rsquo;t used in a cycle between
functions. Note, however, that type inference continues to be purely local.&lt;/p&gt;

&lt;p&gt;On the other hand:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;It&amp;rsquo;s dead simple from the programmer&amp;rsquo;s perspective. There are no
thorny questions about type equality, scoping of type abstractions,
or what &lt;code&gt;~&lt;/code&gt; means in various contexts. It&amp;rsquo;s just an extension of
inference.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;It behaves exactly like associated types today.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;It accounts for conditional trait implementations easily, since those will
automatically be known about the return type whenever they are applicable.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;It accounts for marker traits and &amp;ldquo;OIBITs&amp;rdquo; without any fuss.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;This kind of &amp;ldquo;leakage&amp;rdquo; is already prevalent &amp;ndash; and important! &amp;ndash; in Rust
today. For example, when you define an abstract type, you give a trait bound
which must be fulfilled. But when a client has narrowed to a particular
&lt;code&gt;impl&lt;/code&gt;, &lt;em&gt;everything&lt;/em&gt; about the associated type is revealed:&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;  &lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Assoc&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Clone&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Assoc&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;u8&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// we know that u8::Assoc == u8! We&amp;#39;re only limited to the bound when writing&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// fully generic code.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;The type leakage is, in general, very unlikely to be relied upon. For example, to
observe the particulars of an iterator adapter type, you&amp;rsquo;d have to do
something like assign it to a suitably-typed mutable variable:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;  &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Chain&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&amp;#39;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;u16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Enumerate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Filter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&amp;#39;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MoveItems&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SkipWhile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&amp;#39;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;u16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&amp;#39;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;u16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;u16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slice&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Items&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;u16&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;iter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;some_function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This design addresses all of the hard constraints and strong desires &amp;ndash; but none
of the nice-to-haves.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Key point&lt;/strong&gt;: the strong simplicity here is a major selling point, given that
the pain we&amp;rsquo;re trying to solve here is one of the places where Rust is
considered to be particularly complicated. (See
&lt;a href=&quot;https://www.reddit.com/r/rust/comments/397xn3/why_does_anything_have_higher_priority_than/&quot;&gt;this reddit post&lt;/a&gt;
for example.)&lt;/p&gt;

&lt;h2 id=&quot;option-2-type-abstraction&quot;&gt;Option 2: type abstraction&lt;/h2&gt;

&lt;p&gt;On the other end of the spectrum, we could try to address all of the use cases
outlined, including type abstraction.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m going to give one particular strawman proposal and syntax here, and only at
a high level &amp;ndash; it&amp;rsquo;s not a fully fleshed out spec, but should give some idea of
the possible direction.&lt;/p&gt;

&lt;p&gt;The basic idea is to introduce a &amp;ldquo;type abstraction operator&amp;rdquo; &lt;code&gt;@&lt;/code&gt; that is used to
&amp;ldquo;seal&amp;rdquo; a concrete type to a particular interface:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileDesc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Read&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Write&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Seek&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You should read this as &amp;ldquo;at&amp;rdquo;, meaning that you are viewing a type &amp;ldquo;at&amp;rdquo; some
specific bounds.&lt;/p&gt;

&lt;p&gt;This definition is roughly equivalent to:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FileDesc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Read&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// forward to FileDesc&amp;#39;s Read impl&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Write&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// forward to FileDesc&amp;#39;s Read impl&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Seek&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// forward to FileDesc&amp;#39;s Read impl&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Debug&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// forward to FileDesc&amp;#39;s Read impl&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However that there is a &lt;em&gt;scope&lt;/em&gt; in which the equivalence &lt;code&gt;File = FileDesc&lt;/code&gt; is
known. Within that scope (&amp;ldquo;inside the abstraction boundary&amp;rdquo;), &lt;code&gt;File&lt;/code&gt; is a simple
type alias for &lt;code&gt;FileDesc&lt;/code&gt;. Outside that scope, &lt;code&gt;File&lt;/code&gt; is an opaque type that is
only known to implement the four traits given. This is akin to what you get with
privacy, except that you don&amp;rsquo;t have to explicitly project using &lt;code&gt;.0&lt;/code&gt; or
construct using &lt;code&gt;File(SomeFileDesc)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The obvious scoping rules for the abstraction would be the current privacy rules
(i.e., literally the same as what you get with a newtype).&lt;/p&gt;

&lt;p&gt;There are some tricky questions here that need to be answered in a complete
design, which I don&amp;rsquo;t try to answer here:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Aside from &lt;code&gt;type&lt;/code&gt; definitions, where else can &lt;code&gt;@&lt;/code&gt; be used? We&amp;rsquo;ll explore one
other location &amp;ndash; function signatures &amp;ndash; in this post, but &lt;code&gt;struct&lt;/code&gt;/&lt;code&gt;enum&lt;/code&gt;
definitions are another interesting possibility.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;How should these type definitions interact with coherence? Can you implement
traits for &lt;code&gt;File&lt;/code&gt;? Inherent methods? What if they conflict with traits/methods
on &lt;code&gt;FileDesc&lt;/code&gt;?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;How do you deal with bounds where the type isn&amp;rsquo;t in &lt;code&gt;Self&lt;/code&gt; position? For
example, there is also an impl of &lt;code&gt;Read&lt;/code&gt; and &lt;code&gt;Write&lt;/code&gt; for &lt;code&gt;&amp;amp;File&lt;/code&gt; that should
be exported.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;What are the rules for equality around these types?&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For now, I want to focus on the original motivation: avoiding having to fully
name a type, while providing an interface to it.&lt;/p&gt;

&lt;h3 id=&quot;integrating-return-type-inference&quot;&gt;Integrating return type inference&lt;/h3&gt;

&lt;p&gt;The other part of the &lt;code&gt;@&lt;/code&gt; proposal is that, when used in function signatures,
you can leave off the type before the &lt;code&gt;@&lt;/code&gt; (i.e., the concrete type being
abstracted):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;skip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Unlike the &lt;code&gt;~&lt;/code&gt; proposal above, &lt;em&gt;this hides everything about the return type
except for the stated trait bound&lt;/em&gt;. So clients here don&amp;rsquo;t know that the iterator
is also &lt;code&gt;Clone&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;scaling-up-marker-and-conditional-traits&quot;&gt;Scaling up: marker and conditional traits&lt;/h3&gt;

&lt;p&gt;To make this kind of &amp;ldquo;sealing&amp;rdquo; work, we&amp;rsquo;d have to deal with two additional
thorny problems: marker traits and conditional traits.&lt;/p&gt;

&lt;p&gt;Marker traits like &lt;code&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt; are often &amp;ldquo;defaulted&amp;rdquo; (via &lt;code&gt;..&lt;/code&gt; impls, AKA
OIBITs). When you follow the newtype pattern, these &amp;ldquo;defaulted&amp;rdquo; traits come
along for the ride, whether you ask for them or not &amp;ndash; they leak through. They
are also often conditional (e.g., one type is &lt;code&gt;Send&lt;/code&gt; if some other types are
&lt;code&gt;Send&lt;/code&gt;). It&amp;rsquo;s probably simplest to say that &lt;code&gt;@&lt;/code&gt; has newtype-like semantics and
marker traits leak through. (Leaking is also important because OIBIT-style
traits can be defined in downstream crates about which you have no knowledge.)&lt;/p&gt;

&lt;p&gt;Leaking, of course, makes &lt;code&gt;@Trait&lt;/code&gt; and &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt; different forms of type
abstraction, but OIBITs are a huge pain point for trait objects today, so that&amp;rsquo;s
likely a worthwhile difference.&lt;/p&gt;

&lt;p&gt;A more difficult issue is truly conditional traits, like:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Clone&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Clone&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To deal with this situation, we&amp;rsquo;d need conditional bounds like:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Clone&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Clone&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;DoubleEndedIterator&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;DoubleEndedIterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That&amp;rsquo;s, obviously, pretty verbose. Fortunately, in many cases there are groups
of conditional bounds that tend to go together (see the iterator adapters, for
example). You could imagine capturing these groups into aliases, so that you
could say something like:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IterAdapter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Clone&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Clone&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;DoubleEndedIterator&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;DoubleEndedIterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IterAdapter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;These aliases still have documentation advantages over the current adapter API,
since you&amp;rsquo;d reuse the same alias over and over. By contrast, today each adapter
introduces a separate newtype which must be examined separately to find its API.&lt;/p&gt;

&lt;h3 id=&quot;benefits-drawbacks&quot;&gt;Benefits/drawbacks&lt;/h3&gt;

&lt;p&gt;So in all, it seems feasible to introduce a type abstraction feature, &lt;code&gt;@&lt;/code&gt;, along
with an elided form for function signatures, and have reasonably concise
signatures.&lt;/p&gt;

&lt;p&gt;Some benefits:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The design feels a bit more &amp;ldquo;principled&amp;rdquo; than the pure type inference design:
except for OIBIT traits, the entire interface to a type must be written
explicitly, so there&amp;rsquo;s no accidental leakage and everything is fully
documented.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The use in &lt;code&gt;type&lt;/code&gt; gives a lighter weight form of newtypes that doesn&amp;rsquo;t require
manually forwarding trait impls (akin to &amp;ldquo;generalized newtype deriving&amp;rdquo; from
the Haskell world). However, these types would likely not function as complete
newtypes from the perspective of impl coherence &amp;ndash; it probably doesn&amp;rsquo;t make
sense to impl new traits for them, for example. So they don&amp;rsquo;t solve the whole
problem.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Some drawbacks:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Complexity. This variant is &lt;em&gt;way&lt;/em&gt; more complicated than pure type
inference. And it&amp;rsquo;s not clear that type abstraction is a feature that Rust
really needs, given that we already have privacy and the newtype pattern. We
could provide &amp;ldquo;newtype deriving&amp;rdquo; in a much simpler way to address the pain
points there.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Verbosity. Even with aliases, the signatures involve here tend to be much more
complicated. Of course, that&amp;rsquo;s part of the point: this proposal is trying to
be explicit about signatures.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A somewhat deeper change. This proposal means, for example, that &lt;code&gt;type&lt;/code&gt; can no
longer be understood as a straight-up alias, since repeated uses of &lt;code&gt;@&lt;/code&gt; create
&lt;em&gt;distinct&lt;/em&gt; abstract types.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;wrapup&quot;&gt;Wrapup&lt;/h2&gt;

&lt;p&gt;We absolutely need to expand Rust in this area; I stand by the design
constraints listed here. But we managed to ship a relatively slim Rust 1.0, and
I&amp;rsquo;d like to fight to keep the language as small and concise as we can manage.&lt;/p&gt;

&lt;p&gt;In that light, I&amp;rsquo;m leaning somewhat toward return type inference here, despite
its break from full signature explicitness. But I remain concerned about the
fact that the bound is not actually all that meaningful.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Specialize to reuse</title>
   <link href="http://aturon.github.io/blog/2015/09/18/reuse/"/>
   <updated>2015-09-18T00:00:00-07:00</updated>
   <id>http://aturon.github.io/2015/09/18/reuse</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt;: &lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/1210&quot;&gt;specialization&lt;/a&gt; supports clean, inheritance-like patterns
out of the box. This post explains how, and discusses the interaction with the
&amp;ldquo;virtual structs&amp;rdquo; saga.&lt;/p&gt;

&lt;h2 id=&quot;table-of-contents&quot;&gt;Table of contents&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#overview&quot;&gt;Overview&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#specialization-as-proposed&quot;&gt;Specialization as proposed&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#a-small-addendum&quot;&gt;A small addendum&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#ending-1:-the-trait-based-approach&quot;&gt;Ending 1: the trait-based approach&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#thin-pointers&quot;&gt;Thin pointers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#incorporating-fields&quot;&gt;Incorporating fields&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#struct-composition&quot;&gt;Struct composition&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#struct-inheritance&quot;&gt;Struct inheritance&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#trait-fields&quot;&gt;Trait fields&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#ending-2:-the-enum-based-approach&quot;&gt;Ending 2: the enum-based approach&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#getting-opinionated&quot;&gt;Getting opinionated&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve been working for a while with Niko Matsakis and Nick Cameron on another
round of design for handling type hierarchies like those found in the DOM, in
GUI frameworks, and even the compiler&amp;rsquo;s AST. The Rust community has gone through
&lt;a href=&quot;https://github.com/rust-lang/rfcs/issues/349&quot;&gt;many iterations&lt;/a&gt; of design in
this space, having identified the following goals for a type hierarchy design:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;cheap field access from internal methods;&lt;/li&gt;
&lt;li&gt;cheap dynamic dispatch of methods;&lt;/li&gt;
&lt;li&gt;cheap downcasting;&lt;/li&gt;
&lt;li&gt;thin pointers;&lt;/li&gt;
&lt;li&gt;sharing of fields and methods between definitions;&lt;/li&gt;
&lt;li&gt;safe, i.e., doesn&amp;rsquo;t require a bunch of transmutes or other unsafe code to be usable;&lt;/li&gt;
&lt;li&gt;syntactically lightweight or implicit upcasting;&lt;/li&gt;
&lt;li&gt;calling functions through smart pointers, e.g. &lt;code&gt;fn foo(JSRef&amp;lt;T&amp;gt;, ...)&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;static dispatch of methods.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Two important constraints are missing from this prior list, one technical and
one philosophical:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;reusable constructor code at every level of the hierarchy;&lt;/li&gt;
&lt;li&gt;fits well into the language, either by smoothly extending existing features,
or by adding orthogonal concepts.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the design I&amp;rsquo;ve been pursuing, &lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/1210&quot;&gt;&lt;code&gt;impl&lt;/code&gt; specialization&lt;/a&gt; plays a key
role. That&amp;rsquo;s appealing because specialization is something we&amp;rsquo;ve long wanted for
other reasons, and is a natural deepening of our trait system. But it&amp;rsquo;s not
quite enough, by itself, to meet all of the constraints above.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m going to start by recapping the specialization design. Then I&amp;rsquo;ll explore two
competing avenues for building on specialization to meet the design constraints,
choose-your-own-adventure style. At the end, I&amp;rsquo;ll give my current opinions on
where we ought to go.&lt;/p&gt;

&lt;h2 id=&quot;specialization-as-proposed&quot;&gt;Specialization as proposed&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/1210&quot;&gt;Specialization&lt;/a&gt; allows overlapping trait (and inherent) impls, so long
as there is always a &amp;ldquo;most specific&amp;rdquo; impl that applies to a given concrete type.
The more general impl uses &lt;code&gt;default&lt;/code&gt; to signal which items can be specialized &amp;ndash;
sort of the opposite of &lt;code&gt;final&lt;/code&gt; in Java, or a bit like &lt;code&gt;virtual&lt;/code&gt; in C++.&lt;/p&gt;

&lt;p&gt;One of the major intended uses is to support true zero-cost abstraction, by
allowing you to customize the impl for specific cases to match performance of
non-abstract impls, while maintaining the abstraction for clients. To quote from
the RFC:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Traits today can provide static dispatch in Rust, but they can
still impose an abstraction tax. For example, consider the &lt;code&gt;Extend&lt;/code&gt; trait:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Extend&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;extend&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iterable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IntoIterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Collections that implement the trait are able to insert data from arbitrary
iterators. Today, that means that the implementation can assume nothing about
the argument &lt;code&gt;iterable&lt;/code&gt; that it&amp;rsquo;s given except that it can be transformed into
an iterator. That means the code must work by repeatedly calling &lt;code&gt;next&lt;/code&gt; and
inserting elements one at a time.&lt;/p&gt;

&lt;p&gt;But in specific cases, like extending a vector with a slice, a much more
efficient implementation is possible &amp;ndash; and the optimizer isn&amp;rsquo;t always capable
of producing it automatically. In such cases, specialization can be used to get
the best of both worlds: retaining the abstraction of &lt;code&gt;extend&lt;/code&gt; while providing
custom code for specific cases.&lt;/p&gt;

&lt;p&gt;The design in this RFC relies on multiple, overlapping trait impls, so to take
advantage for &lt;code&gt;Extend&lt;/code&gt; we need to refactor a bit:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Extend&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IntoIterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;extend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iterable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// The generic implementation&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Extend&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IntoIterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// the `default` qualifier allows this method to be specialized below&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;extend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iterable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// implementation using push (like today&amp;#39;s extend)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// A specialized implementation for slices&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&amp;#39;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Extend&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;&amp;#39;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;extend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iterable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;&amp;#39;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// implementation using ptr::write (like push_all)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;Because the generic impl uses &lt;code&gt;default&lt;/code&gt; for its implementation of &lt;code&gt;extend&lt;/code&gt;, it&amp;rsquo;s
permitted to give a more specialized impl block that overrides it. (The block is
more specialized because it applies to a subset of the types the generic one
applies to.)&lt;/p&gt;

&lt;p&gt;A specialized impl doesn&amp;rsquo;t have to provide all the items for a trait; whatever
it doesn&amp;rsquo;t provide is automatically inherited from the generic impl it&amp;rsquo;s
specializing. And conversely, it can &lt;em&gt;only&lt;/em&gt; override items marked &lt;code&gt;default&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Going a bit farther, it&amp;rsquo;s possible to specialize not just impls for a trait, but
also &lt;em&gt;defaults&lt;/em&gt; for a trait. This is done via &lt;code&gt;partial impl&lt;/code&gt; blocks, which are
impls that provide some, but not all, of the items required by a trait. Again
quoting the RFC:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;For example, consider a design for overloading &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;+=&lt;/code&gt;, such that
they are always overloaded together:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rhs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rhs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Rhs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add_assign&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Rhs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this case, there&amp;rsquo;s no natural way to provide a default implementation of
&lt;code&gt;add_assign&lt;/code&gt;, since we do not want to restrict the &lt;code&gt;Add&lt;/code&gt; trait to &lt;code&gt;Clone&lt;/code&gt; data.&lt;/p&gt;

&lt;p&gt;The specialization design in this RFC also allows for &lt;em&gt;partial&lt;/em&gt; implementations,
which can provide specialized defaults without actually providing a full trait
implementation:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;n&quot;&gt;partial&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Clone&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Rhs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rhs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// the `default` qualifier allows further specialization&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add_assign&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rhs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clone&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rhs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This partial impl does &lt;em&gt;not&lt;/em&gt; mean that &lt;code&gt;Add&lt;/code&gt; is implemented for all &lt;code&gt;Clone&lt;/code&gt;
data, but jut that when you do impl &lt;code&gt;Add&lt;/code&gt; and &lt;code&gt;Self: Clone&lt;/code&gt;, you can leave off
&lt;code&gt;add_assign&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#[derive(Copy, Clone)]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rhs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// no fn add_assign necessary&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;h3 id=&quot;a-small-addendum&quot;&gt;A small addendum&lt;/h3&gt;

&lt;p&gt;The specialization RFC touches on, but doesn&amp;rsquo;t actually specify, a way to
&amp;ldquo;access&amp;rdquo; the implementation you&amp;rsquo;re overriding (akin to &lt;code&gt;super&lt;/code&gt; in the OO world).&lt;/p&gt;

&lt;p&gt;For the sake of this post, I&amp;rsquo;ll assume we&amp;rsquo;ve added such a mechanism by way of a
UFCS-like use of &lt;code&gt;default&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// do some complicated stuff&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Debug&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;About to `foo` on {:?}&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The idea is that the &lt;code&gt;default::&lt;/code&gt; prefix accessing the generic impl that&amp;rsquo;s being
overridden, and works like UFCS (in that methods become functions taking &lt;code&gt;self&lt;/code&gt;
explicitly).&lt;/p&gt;

&lt;p&gt;The details here aren&amp;rsquo;t so important, as long as specialization supports &lt;em&gt;some&lt;/em&gt;
mechanism like this (which was always the intent).&lt;/p&gt;

&lt;h2 id=&quot;ending-1-the-trait-based-approach&quot;&gt;Ending 1: the trait-based approach&lt;/h2&gt;

&lt;p&gt;It should already be clear that specialization has a connection to inheritance,
because items left off of a specialized impl are inherited from the impl
(partial or otherwise) it is specializing. As it turns out, that&amp;rsquo;s already
enough to code up something like traditional type hierarchies in OO
languages. You can get pretty far!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This general approach is, in some ways, inspired by
&lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/250&quot;&gt;eddyb and Kimundi&amp;rsquo;s proposal&lt;/a&gt;
from last time around, but using specialization rather than a targeted feature
for default refinement. And of course many of the fine points of the design
here have been explored by others in the community as well.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Here&amp;rsquo;s an example, using a lightly simplified extract from Servo&amp;rsquo;s DOM
implementation.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Node ////////////////////////////////////////////////////////////////////////&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parse_plain_attribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Atom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DomString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AttrValue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;AttrValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// additional virtual methods for Node&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// non-virtual methods for Node&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_parent_of&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// additional methods here&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Element /////////////////////////////////////////////////////////////////////&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;as_activatable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Activatable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;None&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// additional Element methods&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// non-virtual methods for Element&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nearest_activable_element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;partial&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parse_plain_attribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Atom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DomString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AttrValue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;id&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AttrValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_atomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;class&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AttrValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_serialized_tokenlist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parse_plain_attribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Activatable /////////////////////////////////////////////////////////////////&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Activatable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// moar methods&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;partial&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Activatable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;as_activatable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Activatable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;Some&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// HtmlAnchorElement ///////////////////////////////////////////////////////////&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HtmlAnchorElement&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;rel_list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DomTokenList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// moar fields&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HtmlAnchorElement&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parse_plain_attribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Atom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DOMString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AttrValue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;rel&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AttrValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_serialized_tokenlist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parse_plain_attribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HtmlAnchorElement&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Activatable&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HtmlAnchorElement&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// HtmlImageElement ////////////////////////////////////////////////////////////&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HtmlImageElement&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Arc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Image&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// moar fields&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HtmlImageElement&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parse_plain_attribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Atom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DOMString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AttrValue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AttrValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_atomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;width&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;height&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;hspace&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;vspace&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AttrValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_u32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parse_plain_attribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HtmlImageElement&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This example is following a basic pattern:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&amp;ldquo;Abstract base classes&amp;rdquo; turn into traits&lt;/strong&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Their virtual methods become methods in the traits (e.g. &lt;code&gt;parse_plain_attribute&lt;/code&gt;).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;They will be virtually dispatched when using trait objects, and statically
dispatched when used directly on a type implementing the trait (as usual).
In practice that means that after the first virtual call, additional calls
on &lt;code&gt;self&lt;/code&gt; are statically-dispatched.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Their non-virtual methods become inherent methods for the trait, DST style
(e.g. &lt;code&gt;is_parent_of&lt;/code&gt;). These are always statically-dispatched. (Note: it may
be preferable to write these as extension traits with blanket impls, to gain
further static dispatch through monomorphization, at a cost in code size.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Default implementations of methods can be done via &amp;hellip; defaulted methods!&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&amp;ldquo;Concrete classes&amp;rdquo; turn into structs.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The structs implement all of the traits for the abstract base classes above them.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In this case, &amp;ldquo;overriding&amp;rdquo; generally just means supplying an impl when a
default was available.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Methods can be overridden at any point in the hierarchy.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;This is done via a blanket (partial) impl, like &lt;code&gt;partial impl&amp;lt;T: Element&amp;gt; Node for T&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;When one abstract base class overrides its parent, it generally uses
&lt;code&gt;partial impl&lt;/code&gt;. This is because there are usually still some &amp;ldquo;abstract&amp;rdquo; aka
&amp;ldquo;pure virtual&amp;rdquo; methods for the parent (which are just required methods on
the trait).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If further overriding should be allowed, these (partial) impls should use
&lt;code&gt;default&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;For example, the &lt;code&gt;as_activatable&lt;/code&gt; method is overridden for &lt;code&gt;T:
Activatable&lt;/code&gt; with a &amp;ldquo;final&amp;rdquo; version that cannot be further overridden.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And that&amp;rsquo;s it. This entire vision of OO-ish programming rests on using the
existing system of dynamic dispatch through traits, and gets reuse/inheritance
via specialization.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s take stock of the design constraints:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;cheap field access from internal methods;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;No&lt;/strong&gt;: traits have no way to talk about fields directly, and
accessors require virtual dispatch (much more expensive than a fixed offset).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;cheap dynamic dispatch of methods;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Yes&lt;/strong&gt;: covered via the trait system.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;cheap downcasting;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Sort of&lt;/strong&gt;: see the &lt;code&gt;as_activatable&lt;/code&gt; pattern. But not as fast as a type tag
check. (The latter can be encoded if we have fields, however.)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;thin pointers;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;No&lt;/strong&gt;: trait objects use fat pointers.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;sharing of fields and methods between definitions;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Yes&lt;/strong&gt; for methods (via specialization), &lt;strong&gt;No&lt;/strong&gt; for fields.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;safe, i.e., doesn&amp;rsquo;t require a bunch of transmutes or other unsafe code to be usable;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Yes&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;syntactically lightweight or implicit upcasting;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Yes&lt;/strong&gt;, once we have it for super-traits in general (an already-slated,
highly desired, simple feature).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;calling functions through smart pointers, e.g. &lt;code&gt;fn foo(JSRef&amp;lt;T&amp;gt;, ...)&lt;/code&gt;;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Yes&lt;/strong&gt;, via existing coercion/Deref mechanisms.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;static dispatch of methods;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Yes&lt;/strong&gt;, as discussed avove.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;reusable constructor code at every level of the hierarchy;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;No&lt;/strong&gt;, because fields are not addressed.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;fits well into the language, either by smoothly extending existing features,
or by adding orthogonal concepts.

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Yes&lt;/strong&gt;: we didn&amp;rsquo;t have to add anything beyond specialization (which we&amp;rsquo;re
taking for granted here).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So, we essentially met all but two requirements: thin pointers, and field
access/inheritance. What&amp;rsquo;s the simplest way we could accommodate those?&lt;/p&gt;

&lt;h3 id=&quot;thin-pointers&quot;&gt;Thin pointers&lt;/h3&gt;

&lt;p&gt;Recall that today, trait objects are &amp;ldquo;fat pointers&amp;rdquo;: a pointer to some data, and
a pointer to a vtable containing methods for operating on that data.&lt;/p&gt;

&lt;p&gt;This representation is not an arbitrary choice. It goes hand-in-hand with an
important aspect of traits: you can implement a new trait for an already-defined
type. This makes traits quite unlike interfaces in languages like Java, C#, or
Scala, which have to be applied when you define a type. Traits are flexible bits
of glue that can be applied after the fact. But the tradeoff is that the vtable
cannot be part of the &lt;code&gt;Self&lt;/code&gt; type, at least not if you want separate
compilation. After all, the crate defining a &lt;code&gt;struct&lt;/code&gt; simply &lt;em&gt;does not know&lt;/em&gt;
what traits might eventually be applied.&lt;/p&gt;

&lt;p&gt;On the other hand, these fat pointers have a drawback: space overhead. In
particular, if you have a dense graph of trait objects that are pointing to each
other, &lt;em&gt;each pointer&amp;rsquo;s size is doubled&lt;/em&gt;, but the information being stored is
often redundant (and the relevant traits are often implemented up front). For
serious object graphs, this is a non-starter.&lt;/p&gt;

&lt;p&gt;In Rust, when faced with representation tradeoffs, we have a simple tool: the
&lt;code&gt;repr&lt;/code&gt; attribute. So we can address the desire for thin pointers to traits by
introducing &lt;code&gt;#[repr(thin)]&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#[repr(thin)]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyThinTrait&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyType&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyThinTrait&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyType&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;take_thin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MyThinTrait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;doit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Applying &lt;code&gt;#[repr(thin)]&lt;/code&gt; to a trait like &lt;code&gt;MyThinTrait&lt;/code&gt; has a few implications:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The representation of types like &lt;code&gt;&amp;amp;MyThinTrait&lt;/code&gt; (used in &lt;code&gt;take_thin&lt;/code&gt;) is a
single pointer, which points to a vtable followed by the data.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;You can only implement a thin trait for types you define in your crate.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If you implement multiple thin traits for a given type, they must form a
hierarchy. That ensures consistent layout of the vtable.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Thin traits are a useful representation for Rust to offer regardless of any
notion of &amp;ldquo;inheritance&amp;rdquo;.&lt;/p&gt;

&lt;h3 id=&quot;incorporating-fields&quot;&gt;Incorporating fields&lt;/h3&gt;

&lt;p&gt;Now all that&amp;rsquo;s left to handle is fields. To get maximal performance, we need
some way for a trait to require that &lt;code&gt;Self&lt;/code&gt; provides specific fields at
&lt;em&gt;statically-known locations&lt;/em&gt; (which is true for genuine inheritance hierarchies
as one gets in languages like C++). In particular, accessing such fields through
a trait is no more expensive than accessing them directly through a known
struct: you just load the offset. But unlike a full struct definition, this only
requires the existence of a specific field at a specific location; it doesn&amp;rsquo;t
constrain other fields that might be available.&lt;/p&gt;

&lt;p&gt;(&lt;em&gt;Note&lt;/em&gt;: it may also be desirable to support fields in traits at dynamic
offsets, which is still faster than a full dynamic dispatch, but that&amp;rsquo;s distinct
from the requirements set out at the beginning of the post.)&lt;/p&gt;

&lt;p&gt;In addition, it would be ideal if field definitions only have to be mentioned
once, not repeated in every trait and struct definition that is talking about them.&lt;/p&gt;

&lt;p&gt;There are likely a lot of ways we could accomplish these goals, but I&amp;rsquo;ll
highlight a few promising ones, in order of increasing complexity: struct
composition, struct inheritance, and trait fields.&lt;/p&gt;

&lt;h4 id=&quot;struct-composition&quot;&gt;Struct composition&lt;/h4&gt;

&lt;p&gt;There&amp;rsquo;s a very simple way, in today&amp;rsquo;s Rust, for one struct to contain all of the
information of another struct: simply include the other struct as a field!&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NodeFields&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;event_target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EventTarget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;parent_node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Arc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Note: this refers to the Node *trait*! see below.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;first_child&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Arc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;last_child&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Arc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;next_sibling&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Arc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;prev_sibling&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Arc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ElementFields&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;node_fields&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NodeFields&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;local_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Atom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;namespace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Namespace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this example, &lt;code&gt;Element&lt;/code&gt; &amp;ldquo;inherits&amp;rdquo; the fields of &lt;code&gt;Node&lt;/code&gt; simply by embedding
them. This approach also neatly solves the problem of reusing constructors
across the hierarchy: a &lt;code&gt;Node&lt;/code&gt; here is already a partly-constructed &lt;code&gt;Element&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So the remaining question is how to gain access to these fields in a
trait. Here&amp;rsquo;s one possibility:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NodeFields&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ElementFields&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The idea is that a trait can list any number of super-structs (including
indirectly through super-traits), so long as those structs form a &lt;em&gt;composition
hierarchy&lt;/em&gt;: they must form a chain where each struct contains a leading field
whose type is the next struct (like with &lt;code&gt;ElementFields&lt;/code&gt; and &lt;code&gt;NodeFields&lt;/code&gt;
above). The chain then ends in the &lt;code&gt;Self&lt;/code&gt; type implementing the trait.&lt;/p&gt;

&lt;p&gt;So, to complete the DOM example, we&amp;rsquo;d have:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HtmlAnchorElement&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;element_fields&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ElementFields&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// internally, contains a leading NodeFields&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;rel_list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DomTokenList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// moar fields&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HtmlAnchorElement&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HtmlAnchorElement&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When the trait is in scope, it allows direct access to the fields as if they had
been flattened into the struct:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent_node_via_element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Arc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clone&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(A more verbose alternative might be some UFCS-style &lt;code&gt;&amp;lt;self as
NodeFields&amp;gt;::parent_node.clone()&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;Of course, this proposal assumes that structs beginning with the same leading
field always lay that field out in the same way &amp;ndash; in particular, this rules out
reordering of the field. If we don&amp;rsquo;t want to make such a guarantee, we could
limit use of struct bounds to thin traits. Since thin traits are implemented for
structs in the same crate defining those structs, they can impose additional
representation constraints.&lt;/p&gt;

&lt;h4 id=&quot;struct-inheritance&quot;&gt;Struct inheritance&lt;/h4&gt;

&lt;p&gt;The above struct composition approach is, in some ways, pretty simple. It builds
directly on current patterns for building hierarchies of structs. But it is
perhaps &lt;em&gt;too&lt;/em&gt; targeted and narrow.&lt;/p&gt;

&lt;p&gt;A more expansive alternative is explicit struct inheritance. The basic idea here
is very simple:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NodeFields&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;event_target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EventTarget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;parent_node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Arc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// implicitly contains all of NodeFields fields&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ElementFields&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NodeFields&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;local_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Atom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;namespace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Namespace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The initializer sytax for child structs would then permit either providing all
field explicitly, or extending from an instance of the parent structure:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Style 1: all fields&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ElementFields&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ElementFields&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;event_target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;parent_node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// more NodeFields fields&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;local_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;namespace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// more ElementFields fields&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Style 2: using parent struct&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NodeFields&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NodeFields&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;event_target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;parent_node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// more NodeFields fields&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ElementFields&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ElementFields&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;local_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;namespace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// more ElementFields fields&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This covers the need for constructors at each level of the hierarchy. But what
about hooking into traits?&lt;/p&gt;

&lt;p&gt;With struct inheritance, we can treat structs &lt;em&gt;in general&lt;/em&gt; as something you can write in a bound, e.g.:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;take_node_descendant&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NodeFields&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Arc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clone&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// same as writing `trait Node where Self: NodeFields`&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NodeFields&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In all cases, using a struct as a bound like &lt;code&gt;T: NodeFields&lt;/code&gt; means that &lt;code&gt;T&lt;/code&gt;
&lt;em&gt;must inherit from&lt;/em&gt; &lt;code&gt;NodeFields&lt;/code&gt;. For traits, that would immediately give you
access to the fields, and would impose the fixed static offset requirement
(giving maximal performance when accessing those fields). That is, given the
definition of &lt;code&gt;Node&lt;/code&gt; above, if we have &lt;code&gt;n: &amp;amp;Node&lt;/code&gt;, we could write
&lt;code&gt;n.parent_node&lt;/code&gt; and that would compile as if we had &lt;code&gt;n: NodeFields&lt;/code&gt; instead.
Because inheritance is explicit at the point of struct definition, we don&amp;rsquo;t have
the layout worries we had with struct composition; we can lay out child structs
so that their parents are always consistent prefixes.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s plausible that struct inheritance is generally useful outside of OO-like
hierarchies; certainly it avoids long chains like
&lt;code&gt;my_struct.parent1.parent2.actual_field&lt;/code&gt; one gets when using struct composition
at scale, although the previous proposal does that as well.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;While it&amp;rsquo;s not necessary to address our goals here, you could also imagine
adding coercions from &lt;code&gt;&amp;amp;ElementFields&lt;/code&gt; to &lt;code&gt;&amp;amp;NodeFields&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;trait-fields&quot;&gt;Trait fields&lt;/h4&gt;

&lt;p&gt;Finally, we could imagine instead adding fields directly to traits:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;parent_node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Arc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This raises a few questions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;What do you have to say in an &lt;code&gt;impl&lt;/code&gt;?&lt;/li&gt;
&lt;li&gt;Can the fields be hooked up arbitrarily to &lt;code&gt;Self&lt;/code&gt;, or must they form a prefix?&lt;/li&gt;
&lt;li&gt;Can you avoid writing out copies of the field definitions in every struct in
the hierarchy?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are many ways we might answer these questions, and I won&amp;rsquo;t try to fully
explore the space here. But a simple option is to say that the fields must form
a prefix of the fields of &lt;code&gt;Self&lt;/code&gt;, and you don&amp;rsquo;t have to say anything in an
impl. Furthermore, if you write:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HtmlAnchorElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;rel_list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DomTokenList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// moar fields&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;you automatically include the fields mentioned in the &lt;code&gt;Element&lt;/code&gt; trait (including
those from its super-trait &lt;code&gt;Node&lt;/code&gt;) as leading fields in the struct.&lt;/p&gt;

&lt;p&gt;If we furthermore want to provide reusable constructors at every level of the
hierarchy, we have to &lt;em&gt;also&lt;/em&gt; include some way of naming these intermediate
structs and using them in initaializers, e.g.:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;event_target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;parent_node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// more Node fields&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;local_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;namespace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// more Element fields&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HtmlAnchorElement&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HtmlAnchorElement&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;rel_list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// more HtmlAnchorElement fields&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The main advantage of this approach over the previous ones is that you avoid the
need to explicitly name structs corresponding to &amp;ldquo;abstract base classes&amp;rdquo; (like
&lt;code&gt;NodeFields&lt;/code&gt; and &lt;code&gt;ElementFields&lt;/code&gt;); instead, these are implicit via the
&lt;code&gt;::struct&lt;/code&gt; associated type. But there remain questions about using this syntax
more flexibly, for mapping trait fields in more arbitrary ways to struct fields,
without giving up performance in the fixed-offset case.&lt;/p&gt;

&lt;p&gt;A downside is the question of &lt;em&gt;visibility&lt;/em&gt;: currently all items in a trait are
considered public, but this is not necessarily desirable for fields, so we&amp;rsquo;d
likely need some way to express visibility choices. Fitting that into the
existing syntax is not going to be easy. Whereas with struct composition or
inheritance, it just &amp;ldquo;falls out&amp;rdquo; of the struct definitions.&lt;/p&gt;

&lt;h2 id=&quot;ending-2-the-enum-based-approach&quot;&gt;Ending 2: the enum-based approach&lt;/h2&gt;

&lt;p&gt;Whew! So all of the proposals we just saw took traits as the sole source of
dynamic dispatch and tried to close remaining gaps through slight enrichments of
traits and structs.&lt;/p&gt;

&lt;p&gt;A radically different approach takes the perspective that Rust already has &lt;em&gt;two&lt;/em&gt;
forms of dynamic dispatch today &amp;ndash; traits and &lt;em&gt;match expressions&lt;/em&gt; &amp;ndash;
corresponding to &amp;ldquo;open&amp;rdquo; (extensible) and closed sets of types respectively.&lt;/p&gt;

&lt;p&gt;Niko Matsakis outlined a substantial expansion to enums in
&lt;a href=&quot;http://smallcultfollowing.com/babysteps/blog/2015/08/20/virtual-structs-part-3-bringing-enums-and-structs-together/&quot;&gt;his recent post&lt;/a&gt;,
which is part of the original design he, Nick Cameron, and I had been working
on. The missing piece in that post is how to tie it together with specialization
and thereby get something more like inheritance.&lt;/p&gt;

&lt;p&gt;I won&amp;rsquo;t recap the whole proposal here (it&amp;rsquo;s worth a read in full!), but in short
it makes enums into full-blown hierarchies, defining types at every level (and
structs at the leaves):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// where this node is positioned after layout&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Rectangle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TextElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ParagraphElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Given such a hierarchy, you can write:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;takes_any_node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That is, you can use an enum as a &lt;em&gt;bound&lt;/em&gt;, which stands for &amp;ldquo;any type under this
point in the hierarchy&amp;rdquo;, but will be statically resolved via monomorphization.&lt;/p&gt;

&lt;p&gt;This immediately opens the door to specialization for reuse:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ParsePlainAttribute&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parse_plain_attribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Atom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DomString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AttrValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ParsePlainAttribute&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parse_plain_attribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Atom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DomString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AttrValue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;AttrValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ParsePlainAttribute&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parse_plain_attribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Atom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DomString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AttrValue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;id&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AttrValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_atomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;class&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AttrValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_serialized_tokenlist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parse_plain_attribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ParsePlainAttribute&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HtmlAnchorElement&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parse_plain_attribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Atom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DOMString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AttrValue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;rel&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AttrValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_serialized_tokenlist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parse_plain_attribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This pattern of specialization, trying to match the example at the beginning of
the post, &lt;em&gt;almost&lt;/em&gt; works: if you call &lt;code&gt;parse_plain_attribute&lt;/code&gt; on an
&lt;code&gt;HtmlAnchorElement&lt;/code&gt;, you&amp;rsquo;ll get the correct behavior.&lt;/p&gt;

&lt;p&gt;But if you&amp;rsquo;ve upcasted to an &lt;code&gt;Element&lt;/code&gt; or &lt;code&gt;Node&lt;/code&gt;, &lt;em&gt;the behavior will revert to
the defaults for those types&lt;/em&gt;! That&amp;rsquo;s because you&amp;rsquo;re not getting dynamic
dispatch here, which for enums we said should go through &lt;code&gt;match&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The solution is to instead write the code as follows:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ParsePlainAttribute&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parse_plain_attribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Atom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DomString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AttrValue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;AttrValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ParsePlainAttribute&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parse_plain_attribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Atom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DomString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AttrValue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;id&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AttrValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_atomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;class&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AttrValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_serialized_tokenlist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parse_plain_attribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ParsePlainAttribute&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HtmlAnchorElement&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parse_plain_attribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Atom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DOMString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AttrValue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;rel&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AttrValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_serialized_tokenlist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parse_plain_attribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that we&amp;rsquo;re now using specialization &lt;em&gt;without any explicit blanket
impls&lt;/em&gt;. In this proposal, when the &lt;code&gt;Self&lt;/code&gt; type is an enum, it&amp;rsquo;s &lt;em&gt;as if&lt;/em&gt; you had
written a blanket impl like the ones above, except that when the function is
invoked on the enum type, it will use a &lt;code&gt;match&lt;/code&gt; to dispatch to most specialized
implementation. That is, it&amp;rsquo;s as if we&amp;rsquo;d written the following for &lt;code&gt;Node&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Fully generic *default* impl&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ParsePlainAttribute&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parse_plain_attribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Atom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DomString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AttrValue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;AttrValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Specialized impl for the `Node` type itself&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ParsePlainAttribute&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parse_plain_attribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Atom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DomString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AttrValue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// NOTE: `this` has a different type in each arm!&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HtmlAnchorElement&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parse_plain_attribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HtmlImageElement&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parse_plain_attribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And of course:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It&amp;rsquo;s nicer to write the impls directly against the enum type than using an explicit blanket;&lt;/li&gt;
&lt;li&gt;This is also almost certainly the behavior you wanted anyway: you always get
the most specific impl, whether dynamically or statically dispatched.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;But the desugaring &lt;em&gt;only&lt;/em&gt; triggers when &lt;code&gt;Self&lt;/code&gt; is a direct enum type.&lt;/p&gt;

&lt;h2 id=&quot;getting-opinionated&quot;&gt;Getting opinionated&lt;/h2&gt;

&lt;p&gt;If you&amp;rsquo;ve stuck with me until this point, first of all: thanks! That was a long
haul.&lt;/p&gt;

&lt;p&gt;So, what should we do? To recap, we have two major routes, both of which start
with specialization.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The first takes a minimalistic approach, adding a couple of minor
(and independently motivated) features to traits and structs to get to
our goal. There are a few options for dealing with fields, in
particular.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The second combines specialization with another major set of enhancements to
enums, which are also independently motivated, but are much more complex. It
then adds a bit of sugar on top to tie the two together.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The trait approach allows for open-ended hierarchies (extensible by downstream
crates), while the enum approach is closed. On the flip side, that means that
downcasting can be somewhat more awkward (and is a code smell) for the trait
approach, while it&amp;rsquo;s completely natural (just a &lt;code&gt;match&lt;/code&gt;) for the enum approach.&lt;/p&gt;

&lt;p&gt;Initially, I was very excited about the latter, enum-centric approach, because
the work on enum hierarchies seems like such a natural extension to Rust. But I
am worried about a few things. First of all, getting the proposal that Niko laid
out to work will require substantially reworking our type inference to account
for subtyping. Making this happen &lt;em&gt;backwards-compatibly&lt;/em&gt; with our existing enums
is not going to be easy, and may not even be possible. It also makes subtyping
much more important in Rust, which is likely to be a &lt;em&gt;complexity multiplier&lt;/em&gt; as
it interacts with every other aspect of the type system.  There are also various
dark syntactic corners that come out of the partial unification of enums and
structs (e.g., how do you specify visibility of shared fields in an in-line
enum?)  Finally, the key bit of sugar at the apex that ties enum hierarchies and
specialization together is a bit subtle, and only covers the most obvious cases
of &lt;code&gt;Self&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In short, I see a lot of known risks, and worry about unknown risks, with the
enum hierarchy route.&lt;/p&gt;

&lt;p&gt;In contrast, the struct/trait-centric proposals feel much less risky; they don&amp;rsquo;t
introduce fundamental new complexity that interacts with the rest of the type
system, and they have a smaller overall footprint. I also like the way that
specialization is used very explicitly to get inheritance, rather than through
a layer of sugar on top.&lt;/p&gt;

&lt;p&gt;And of the struct proposals, I think that struct inheritance strikes the best
balance between minimalism, flexibility, and &amp;ldquo;fit&amp;rdquo; with the existing language.&lt;/p&gt;

&lt;p&gt;The main downside of my preferred struct/trait approach is that there&amp;rsquo;s some
amount of boilerplate: &amp;ldquo;abstract base classes&amp;rdquo; like &lt;code&gt;Node&lt;/code&gt; turn into a &lt;code&gt;Node&lt;/code&gt;
trait and a &lt;code&gt;NodeFields&lt;/code&gt; struct. That detail could easily be hidden behind a
macro, but it might also argue in favor of the more complex traits-with-fields
variant.&lt;/p&gt;

&lt;p&gt;(I should mention: it&amp;rsquo;s possible that in the long run, we&amp;rsquo;ll want subtyping and
not just coercions with any approach we take. But still, enum hierarchies want
this to happen for our existing enums in a way that may require breakage.)&lt;/p&gt;

&lt;p&gt;If we &lt;em&gt;do&lt;/em&gt; go with a struct/trait approach, I think we should carefully check
that the design is compatible with a future expansion of enums along the lines
Niko laid out in his post, since we may still want enum hierarchies in the long
run. I&amp;rsquo;ve given this a fair amount of thought, and likewise think that struct
inheritance is the best fit. In particular, it could replace the somewhat
magical proposal for &amp;ldquo;common fields&amp;rdquo; (which included an associated
&lt;code&gt;MyEnum::struct&lt;/code&gt; type).&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Lock-freedom without garbage collection</title>
   <link href="http://aturon.github.io/blog/2015/08/27/epoch/"/>
   <updated>2015-08-27T00:00:00-07:00</updated>
   <id>http://aturon.github.io/2015/08/27/epoch</id>
   <content type="html">&lt;h2 id=&quot;tl-dr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;p&gt;It&amp;rsquo;s widespread folklore that one advantage of garbage collection is the ease of
building high-performance lock-free data structures. Manual memory management
for these data structures is not easy, and a GC makes it trivial.&lt;/p&gt;

&lt;p&gt;This post shows that, using Rust, it&amp;rsquo;s possible to build a memory management API
for concurrent data structures that:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Makes it as easy to implement lock-free data structures as a GC does;&lt;/li&gt;
&lt;li&gt;Statically safeguards against misuse of the memory management scheme;&lt;/li&gt;
&lt;li&gt;Has overhead competitive with (and more predictable than) GC.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the benchmarks I show below, Rust is able to easily beat a Java
lock-free queue implementation, with an implementation that&amp;rsquo;s as easy
to write.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve implemented &amp;ldquo;epoch-based memory reclamation&amp;rdquo; in a new library called
&lt;a href=&quot;https://github.com/aturon/crossbeam&quot;&gt;Crossbeam&lt;/a&gt;, which is ready to use in for
your own data structures today. This post covers some background on lock-free
data structures, the epoch algorithm, and the entire Rust API.&lt;/p&gt;

&lt;h3 id=&quot;contents&quot;&gt;Contents&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#benchmarks&quot;&gt;Benchmarks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#lock-free-data-structures&quot;&gt;Lock-free data structures&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#treiber&amp;#x27;s-stack&quot;&gt;Treiber&amp;rsquo;s stack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#the-problem&quot;&gt;The problem&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#epoch-based-reclamation&quot;&gt;Epoch-based reclamation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#the-rust-api&quot;&gt;The Rust API&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#guard&quot;&gt;&lt;code&gt;Guard&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#owned-and-shared-pointers&quot;&gt;&lt;code&gt;Owned&lt;/code&gt; and &lt;code&gt;Shared&lt;/code&gt; pointers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#atomic&quot;&gt;&lt;code&gt;Atomic&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#freeing-memory&quot;&gt;Freeing memory&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#treiber&amp;#x27;s-stack-on-epochs&quot;&gt;Treiber&amp;rsquo;s stack on epochs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#managing-garbage&quot;&gt;Managing garbage&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#the-road-ahead&quot;&gt;The road ahead&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;benchmarks&quot;&gt;Benchmarks&lt;/h2&gt;

&lt;p&gt;Before looking in depth at the API design and usage for epoch reclamation, let&amp;rsquo;s
cut right to the chase: performance.&lt;/p&gt;

&lt;p&gt;To test the overhead my Crossbeam implementation relative to a full
GC, I implemented a basic lock-free queue (a vanilla
&lt;a href=&quot;http://www.research.ibm.com/people/m/michael/podc-1996.pdf&quot;&gt;Michael-Scott queue&lt;/a&gt;)
on top of it, and built the same queue in Scala. In general, JVM-based
languages are a good test case for the &amp;ldquo;good GC&amp;rdquo; path toward lock-free
data structures.&lt;/p&gt;

&lt;p&gt;In addition to these implementations, I compared against:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A more efficient &amp;ldquo;segmented&amp;rdquo; queue that allocates nodes with multiple slots. I
wrote this queue in Rust, on top of Crossbeam.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A Rust single-threaded queue protected by a mutex.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The java.util.concurrent queue implementation (ConcurrentLinkedQueue), which
is a tuned variant of the Michael-Scott queue.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I tested these queues in two ways:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A multi-producer, single-consumer (MPSC) scenario in which two threads
repeatedly send messages and one thread receives them, both in a tight loop.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A multi-producer, multi-consumer (MPMC) scenario in which two threads send and
two thread receive in a tight loop.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Benchmarks like these are fairly typical for measuring the scalability of a
lock-free data structure under &amp;ldquo;contention&amp;rdquo; &amp;ndash; multiple threads competing to
make concurrent updates simultaenously. &lt;strong&gt;There are many variations that should be
benchmarked when building a production queue implementation; the goal here is
just to gauge the ballpark overhead of the memory management scheme&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;For the MPSC test, I also compared against the algorithm used in Rust&amp;rsquo;s built-in
channels, which is optimized for this scenario (and hence doesn&amp;rsquo;t support MPMC).&lt;/p&gt;

&lt;p&gt;The machine is a 4 core 2.6Ghz Intel Core i7 with 16GB RAM.&lt;/p&gt;

&lt;p&gt;Here are the results, given in nanosecond per message (lower is better):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/public/bench-mpsc.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/public/bench-mpmc.png&quot;&gt;&lt;/p&gt;

&lt;h3 id=&quot;analysis&quot;&gt;Analysis&lt;/h3&gt;

&lt;p&gt;The main takeaway is that the Crossbeam implementation &amp;ndash; which has not been
tuned &amp;ndash; is competitive in all cases. It&amp;rsquo;s possible to do better on both the
Rust and JVM sides by using more clever or specialized queues, but these results
show at least that the overhead of epochs is reasonable.&lt;/p&gt;

&lt;p&gt;Notice that the Java/Scala versions fare much better in the MPMC test than they do in
MPSC test. Why is that?&lt;/p&gt;

&lt;p&gt;The answer is simple: garbage collection. In the MPSC test, the producers tend
to overrun the consumer over time, meaning that the amount of data in the queue
slowly grows. That in turn increases the cost of each garbage collection, which
involves walking over the live data set.&lt;/p&gt;

&lt;p&gt;In the epoch scheme, by contrast, the cost of managing garbage is relatively
fixed: it&amp;rsquo;s proportional to the number of threads, not the amount of live
data. This turns out to yield both better and more consistent/predictable
performance.&lt;/p&gt;

&lt;p&gt;Finally, one comparison I did not include on the chart (because it would dwarf
the others) was using a &lt;code&gt;Mutex&lt;/code&gt; around a deque in Rust. For the MPMC test,
performance was around 3040ns/operation, over 20x slower than the Crossbeam
implementation. This is a vivid demonstration of why lock-free data structure
are important &amp;ndash; so let&amp;rsquo;s start by diving into what those are.&lt;/p&gt;

&lt;h2 id=&quot;lock-free-data-structures&quot;&gt;Lock-free data structures&lt;/h2&gt;

&lt;p&gt;When you want to use (and mutate) a data structure from many concurrent threads,
you need synchronization. The simplest solution is a global lock &amp;ndash; in Rust,
wrapping the entire data structure in
a &lt;a href=&quot;http://static.rust-lang.org/doc/master/std/sync/struct.Mutex.html&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt; and
calling it a day.&lt;/p&gt;

&lt;p&gt;Problem is, that kind of &amp;ldquo;coarse-grained&amp;rdquo; synchronization means that multiple
threads always need to coordinate when accessing a data structure, even if they
were accessing disjoint pieces of it. It also means that even when a thread is
only trying to read, it must &lt;em&gt;write&lt;/em&gt;, by updating the lock state &amp;ndash; and since
the lock is a global point of communication, these writes lead to a large amount
of cache invalidation traffic. Even if you use a lot of locks at a finer grain,
there are other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Lock_%28computer_science%29#Disadvantages&quot;&gt;hazards&lt;/a&gt;
like &lt;a href=&quot;https://en.wikipedia.org/wiki/Deadlock&quot;&gt;deadlock&lt;/a&gt; and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Priority_inversion&quot;&gt;priority inversion&lt;/a&gt;, and you
often still leave performance on the table.&lt;/p&gt;

&lt;p&gt;A more radical alternative is &lt;em&gt;lock-free data structures&lt;/em&gt;, which use atomic
operations to make direct changes to the data structure without further
synchronization. They are often faster, more scalable, and more robust than
lock-based designs.&lt;/p&gt;

&lt;p&gt;I won&amp;rsquo;t try to give a full tutorial to lock-free programming in this post, but a
key point is that, if you don&amp;rsquo;t have global synchronization, it&amp;rsquo;s very difficult
to tell when you can free memory. Many published algorithms basically assume a
garbage collector or some other means of reclaiming memory. So before lock-free
concurrency can really take off in Rust, we need a story for memory reclamation
&amp;ndash; and that&amp;rsquo;s what this blog post is all about.&lt;/p&gt;

&lt;h3 id=&quot;treiber-39-s-stack&quot;&gt;Treiber&amp;rsquo;s stack&lt;/h3&gt;

&lt;p&gt;To make things more concrete, let&amp;rsquo;s look at the &amp;ldquo;Hello world&amp;rdquo; of lock-free data
structures: Treiber&amp;rsquo;s stack. The stack is represented as a singly-linked list,
with all modifications happening on the &lt;code&gt;head&lt;/code&gt; pointer:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;box_raw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;null_mut&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AtomicPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Ordering&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AtomicPtr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Stack&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AtomicPtr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;null_mut&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()),&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It&amp;rsquo;s easiest to start with popping. To pop, you just loop, taking a snapshot of
the &lt;code&gt;head&lt;/code&gt; and doing a compare-and-swap replacing the snapshot with its next
pointer:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note that &lt;code&gt;compare_and_swap&lt;/code&gt; atomically changes the value of an &lt;code&gt;AtomicPtr&lt;/code&gt;
from an old value to a new value, if the old value matched. Also, for this post
you can safely ignore the &lt;code&gt;Acquire&lt;/code&gt;, &lt;code&gt;Release&lt;/code&gt; and &lt;code&gt;Relaxed&lt;/code&gt; labels if you&amp;rsquo;re
not familiar with them.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;loop&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// take a snapshot&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;// we observed the stack empty&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;null_mut&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;None&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

                &lt;span class=&quot;c1&quot;&gt;// if snapshot is still good, update from `head` to `next`&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compare_and_swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

                    &lt;span class=&quot;c1&quot;&gt;// extract out the data from the now-unlinked node&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// **NOTE**: leaks the node!&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Some&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;ptr::read&lt;/code&gt; function is Rust&amp;rsquo;s way of extracting ownership of data without
static or dynamic tracking. Here we are using the atomicity of
&lt;code&gt;compare_and_swap&lt;/code&gt; to guarantee that only one thread will call &lt;code&gt;ptr::read&lt;/code&gt; &amp;ndash;
and as we&amp;rsquo;ll see, this implementation never frees &lt;code&gt;Node&lt;/code&gt;s, so the destructor on
&lt;code&gt;data&lt;/code&gt; is never invoked. Those two facts together make our use of &lt;code&gt;ptr::read&lt;/code&gt;
safe.&lt;/p&gt;

&lt;p&gt;Pushing is similar:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// allocate the node, and immediately turn it into a *mut pointer&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Box&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;into_raw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Box&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;null_mut&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}));&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;loop&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// snapshot current head&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;// update `next` pointer with snapshot&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;// if snapshot is still good, link in new node&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compare_and_swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;the-problem&quot;&gt;The problem&lt;/h3&gt;

&lt;p&gt;If we had coded the above in a language with a GC, we&amp;rsquo;d be done. But as written
in Rust, it leaks memory. In particular, the &lt;code&gt;pop&lt;/code&gt; implementation doesn&amp;rsquo;t
attempt to free the node pointer after it has removed it from the stack.&lt;/p&gt;

&lt;p&gt;What would go wrong if we did just that?&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// extract out the data from the now-unlinked node&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Some&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// free the node&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;mem&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;drop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Box&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_raw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The problem is that other threads could also be running &lt;code&gt;pop&lt;/code&gt; at the same
time. Those threads could have a snapshot of the current head; nothing would
prevent them from reading &lt;code&gt;(*head).next&lt;/code&gt; on that snapshot just after we
deallocate the node they&amp;rsquo;re pointing to &amp;ndash; a use-after-free bug in the making!&lt;/p&gt;

&lt;p&gt;So that&amp;rsquo;s the crux. We want to use lock-free algorithms, but many follow a
similar pattern to the stack above, leaving us with no clear point where it&amp;rsquo;s
safe to deallocate a node. What now?&lt;/p&gt;

&lt;h2 id=&quot;epoch-based-reclamation&quot;&gt;Epoch-based reclamation&lt;/h2&gt;

&lt;p&gt;There are a few non-GC-based ways of managing memory for lock-free code, but
they all come down to the same core observations:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;There are two sources of reachability at play &amp;ndash; the data structure, and the
snapshots in threads accessing it. Before we delete a node, we need to know that
it cannot be reached in either of these ways.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Once a node has been unlinked from the data structure, no &lt;em&gt;new&lt;/em&gt; snapshots
reaching it will be created.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;One of the most elegant and promising reclamation schemes is
&lt;a href=&quot;https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-579.pdf&quot;&gt;Keir Fraser&amp;rsquo;s &lt;em&gt;epoch-based reclamation&lt;/em&gt;&lt;/a&gt;,
which was described in very loose terms in his PhD thesis.&lt;/p&gt;

&lt;p&gt;The basic idea is to stash away nodes that have been unlinked from the data
structure (the first source of reachability) until they can be safely deleted.
Before we can delete a stashed node, we need to know that all threads that were
accessing the data structure at the time have finished the operation they were
performing. By observation 2 above, that will imply that there are no longer any
snapshots left (since no new ones could have been created in the meantime).  The
hard part is doing all of this without much synchronization.  Otherwise, we lose
the benefit that lock-freedom was supposed to bring in the first place!&lt;/p&gt;

&lt;p&gt;The epoch scheme works by having:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;A global epoch counter (taking on values 0, 1, and 2);&lt;/li&gt;
&lt;li&gt;A global list of garbage for each epoch;&lt;/li&gt;
&lt;li&gt;An &amp;ldquo;active&amp;rdquo; flag for each thread;&lt;/li&gt;
&lt;li&gt;An epoch counter for each thread.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The epochs are used to discover when garbage can safely be freed, because no
thread can reach it. &lt;strong&gt;Unlike traditional GC, this does not require walking
through live data&lt;/strong&gt;; it&amp;rsquo;s purely a matter of checking epoch counts.&lt;/p&gt;

&lt;p&gt;When a thread wants to perform an operation on the data structure, it first sets
its &amp;ldquo;active&amp;rdquo; flag, and then updates its local epoch to match the global one. If
the thread removes a node from the data structure, it adds that node to the
garbage list for the current global epoch. (Note: it&amp;rsquo;s very important that the
garbage go into the &lt;em&gt;current&lt;/em&gt; global epoch, not the previous local snapshot.)
When it completes its operation, it clears the &amp;ldquo;active&amp;rdquo; flag.&lt;/p&gt;

&lt;p&gt;To try to collect the garbage (which can be done at any point), a thread walks
over the flags for all participating threads, and checks whether all active
threads are in the current epoch. If so, it can attempt to increment the global
epoch (modulo 3). If the increment succeeds, the garbage from &lt;em&gt;two&lt;/em&gt; epochs ago
can be freed.&lt;/p&gt;

&lt;p&gt;Why do we need three epochs? Because &amp;ldquo;garbage collection&amp;rdquo; is done concurrently,
it&amp;rsquo;s possible for threads to be in one of two epochs at any time (the &amp;ldquo;old&amp;rdquo; one,
and the &amp;ldquo;new&amp;rdquo; one). But because we check that all active threads are in the old
epoch before incrementing it, we are guaranteed that no active threads are in
the third epoch.&lt;/p&gt;

&lt;p&gt;This scheme is carefully designed so that most of the time, threads touch data
that is already in cache or is (usually) thread-local. Only doing &amp;ldquo;GC&amp;rdquo; involves
changing the global epoch or reading the epochs of other threads. The epoch
approach is also algorithm-agnostic, easy to use, and its performance is
&lt;a href=&quot;http://csng.cs.toronto.edu/publication_files/0000/0159/jpdc07.pdf&quot;&gt;competitive with other approaches&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It also turns out to be a great match for Rust&amp;rsquo;s ownership system.&lt;/p&gt;

&lt;h2 id=&quot;the-rust-api&quot;&gt;The Rust API&lt;/h2&gt;

&lt;p&gt;We want the Rust API to reflect the basic principles of epoch-based reclamation:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;When operating on a shared data structure, a thread must always be in its
&amp;ldquo;active&amp;rdquo; state.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;When a thread is active, all data read out of the data structure will remain
allocated until the thread becomes inactive.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We&amp;rsquo;ll leverage Rust&amp;rsquo;s ownership system &amp;ndash; in particular, ownership-based
resource management (aka RAII) &amp;ndash; to capture these constraints directly in the
type signatures of an epoch API. This will in turn help ensure we use epoch
management correctly.&lt;/p&gt;

&lt;h3 id=&quot;guard&quot;&gt;&lt;code&gt;Guard&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;To operate on a lock-free data structure, you first acquire a &lt;em&gt;guard&lt;/em&gt;, which
is an owned value that represents your thread being active:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Guard&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Guard&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;pin&lt;/code&gt; function marks the thread as active, loads the global epoch, and may
try to perform GC (detailed a bit later in the post). The destructor for
&lt;code&gt;Guard&lt;/code&gt;, on the other hand, exits epoch management by marking the thread
inactive.&lt;/p&gt;

&lt;p&gt;Since the &lt;code&gt;Guard&lt;/code&gt; represents &amp;ldquo;being active&amp;rdquo;, a borrow &lt;code&gt;&amp;amp;&amp;#39;a Guard&lt;/code&gt; guarantees
that the thread is active for the entire lifetime &lt;code&gt;&amp;#39;a&lt;/code&gt; &amp;ndash; exactly what we need
to bound the lifetime of the snapshots taken in a lock-free algorithm.&lt;/p&gt;

&lt;p&gt;To put the &lt;code&gt;Guard&lt;/code&gt; to use, Crossbeam provides a set of three pointer types meant to work together:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Owned&amp;lt;T&amp;gt;&lt;/code&gt;, akin to &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, which points to uniquely-owned data that has
not yet been published in a concurrent data structure.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Shared&amp;lt;&amp;#39;a, T&amp;gt;&lt;/code&gt;, akin to &lt;code&gt;&amp;amp;&amp;#39;a T&lt;/code&gt;, which points to shared data that may or may
not be reachable from a data structure, but it guaranteed not to be freed
during lifetime &lt;code&gt;&amp;#39;a&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Atomic&amp;lt;T&amp;gt;&lt;/code&gt;, akin to &lt;code&gt;std::sync::atomic::AtomicPtr&lt;/code&gt;, which provides atomic
updates to a pointer using the &lt;code&gt;Owned&lt;/code&gt; and &lt;code&gt;Shared&lt;/code&gt; types, and connects them
to a &lt;code&gt;Guard&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We&amp;rsquo;ll look at each of these in turn.&lt;/p&gt;

&lt;h3 id=&quot;owned-and-shared-pointers&quot;&gt;&lt;code&gt;Owned&lt;/code&gt; and &lt;code&gt;Shared&lt;/code&gt; pointers&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;Owned&lt;/code&gt; pointer has an interface nearly identical to &lt;code&gt;Box&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Owned&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Owned&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Owned&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Deref&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Owned&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Target&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DerefMut&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Owned&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;Shared&amp;lt;&amp;#39;a, T&amp;gt;&lt;/code&gt; pointer is similar to &lt;code&gt;&amp;amp;&amp;#39;a T&lt;/code&gt; &amp;ndash; it is &lt;code&gt;Copy&lt;/code&gt; &amp;ndash; but it
dereferences to a &lt;code&gt;&amp;amp;&amp;#39;a T&lt;/code&gt;. This is a somewhat hacky way of conveying that the
lifetime of the pointer it provides is in fact &lt;code&gt;&amp;#39;a&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Shared&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&amp;#39;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;&amp;#39;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&amp;#39;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Copy&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Shared&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&amp;#39;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&amp;#39;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Clone&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Shared&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&amp;#39;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&amp;#39;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Deref&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Shared&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&amp;#39;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Target&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;&amp;#39;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Unlike &lt;code&gt;Owned&lt;/code&gt;, there is no way to create a &lt;code&gt;Shared&lt;/code&gt; pointer directly. Instead,
&lt;code&gt;Shared&lt;/code&gt; pointers are acquired by reading from an &lt;code&gt;Atomic&lt;/code&gt;, as we&amp;rsquo;ll see
next.&lt;/p&gt;

&lt;h3 id=&quot;atomic&quot;&gt;&lt;code&gt;Atomic&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;The heart of the library is &lt;code&gt;Atomic&lt;/code&gt;, which provides atomic access to a
(nullable) pointer, and connects all the other types of the library together:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c-Doc&quot;&gt;/// Create a new, null atomic pointer.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We&amp;rsquo;ll look at operations one at a time, since the signatures are somewhat subtle.&lt;/p&gt;

&lt;h4 id=&quot;loading&quot;&gt;Loading&lt;/h4&gt;

&lt;p&gt;First, loading from an &lt;code&gt;Atomic&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&amp;#39;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Ordering&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;&amp;#39;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Guard&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Shared&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&amp;#39;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In order to perform the load, we must pass in a borrow of a &lt;code&gt;Guard&lt;/code&gt;. As
explained above, this is a way of guaranteeing that the thread is active for the
entire lifetime &lt;code&gt;&amp;#39;a&lt;/code&gt;. In return, you get an optional &lt;code&gt;Shared&lt;/code&gt; pointer back
(&lt;code&gt;None&lt;/code&gt; if the &lt;code&gt;Atomic&lt;/code&gt; is currently null), with lifetime tied to the guard.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s interesting to compare this to the standard library&amp;rsquo;s &lt;code&gt;AtomicPtr&lt;/code&gt;
interface, where &lt;code&gt;load&lt;/code&gt; returns a &lt;code&gt;*mut T&lt;/code&gt;. Due to the use of epochs, we&amp;rsquo;re able
to guarantee safe dereferencing of the pointer within &lt;code&gt;&amp;#39;a&lt;/code&gt;, whereas with
&lt;code&gt;AtomicPtr&lt;/code&gt; all bets are off.&lt;/p&gt;

&lt;h4 id=&quot;storing&quot;&gt;Storing&lt;/h4&gt;

&lt;p&gt;Storing is a bit more complicated because of the multiple pointer types in play.&lt;/p&gt;

&lt;p&gt;If we simply want to write an &lt;code&gt;Owned&lt;/code&gt; pointer or a null value, we do not even
need the thread to be active. We are just transferring ownership &lt;em&gt;into&lt;/em&gt; the data
structure, and don&amp;rsquo;t need any assurance about the lifetimes of pointers:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Owned&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Ordering&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Sometimes, though, we want to transfer ownership into the data structure and
immediately acquire a shared pointer to the transferred data &amp;ndash; for example,
because we want to add additional links to the same node in the data
structure. In that case, we&amp;rsquo;ll need to tie the lifetime to a guard:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;store_and_ref&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&amp;#39;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                             &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Owned&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                             &lt;span class=&quot;n&quot;&gt;ord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Ordering&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                             &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;&amp;#39;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Guard&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                             &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Shared&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&amp;#39;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that the runtime representation of &lt;code&gt;val&lt;/code&gt; and the return value is exactly
the same &amp;ndash; we&amp;rsquo;re passing a pointer in, and getting the same pointer out. But
the &lt;em&gt;ownership&lt;/em&gt; situation from Rust&amp;rsquo;s perspective changes radically in this step.&lt;/p&gt;

&lt;p&gt;Finally, we can store a shared pointer back into the data structure:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;store_shared&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Shared&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Ordering&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This operation does not require a guard, because we&amp;rsquo;re not learning any new
information about the lifetime of a pointer.&lt;/p&gt;

&lt;h4 id=&quot;cas&quot;&gt;CAS&lt;/h4&gt;

&lt;p&gt;Next we have a similar family of compare-and-set operations. The simplest case
is swapping a &lt;code&gt;Shared&lt;/code&gt; pointer with a fresh &lt;code&gt;Owned&lt;/code&gt; one:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;old&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Shared&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Owned&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;ord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Ordering&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
               &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Owned&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As with &lt;code&gt;store&lt;/code&gt;, this operation does not require a guard; it produces no new
lifetime information. The &lt;code&gt;Result&lt;/code&gt; indicates whether the CAS succeeded; if not,
ownership of the &lt;code&gt;new&lt;/code&gt; pointer is returned to the caller.&lt;/p&gt;

&lt;p&gt;We then have an analog to &lt;code&gt;store_and_ref&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cas_and_ref&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&amp;#39;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                           &lt;span class=&quot;n&quot;&gt;old&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Shared&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                           &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Owned&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                           &lt;span class=&quot;n&quot;&gt;ord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Ordering&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                           &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;&amp;#39;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Guard&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                           &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Shared&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&amp;#39;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Owned&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this case, on a successful CAS we acquire a &lt;code&gt;Shared&lt;/code&gt; pointer to the data we
inserted.&lt;/p&gt;

&lt;p&gt;Finally, we can replace one &lt;code&gt;Shared&lt;/code&gt; pointer with another:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cas_shared&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                             &lt;span class=&quot;n&quot;&gt;old&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Shared&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                             &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Shared&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                             &lt;span class=&quot;n&quot;&gt;ord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Ordering&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                             &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The boolean return value is &lt;code&gt;true&lt;/code&gt; when the CAS is successful.&lt;/p&gt;

&lt;h3 id=&quot;freeing-memory&quot;&gt;Freeing memory&lt;/h3&gt;

&lt;p&gt;Of course, all of the above machinery is in service of the ultimate goal:
actually freeing memory that is no longer reachable. When a node has been
de-linked from the data structure, the thread that delinked it can inform its
&lt;code&gt;Guard&lt;/code&gt; that the memory should be reclaimed:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Guard&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unlinked&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Shared&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This operation adds the &lt;code&gt;Shared&lt;/code&gt; pointer to the appropriate garbage list,
allowing it to be freed two epochs later.&lt;/p&gt;

&lt;p&gt;The operation is unsafe because it is asserting that:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the &lt;code&gt;Shared&lt;/code&gt; pointer is not reachable from the data structure,&lt;/li&gt;
&lt;li&gt;no other thread will call &lt;code&gt;unlinked&lt;/code&gt; on it.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Crucially, though, other threads &lt;em&gt;may&lt;/em&gt; continue to reference this &lt;code&gt;Shared&lt;/code&gt;
pointer; the epoch system will ensure that no threads are doing so by the time
the pointer is actually freed.&lt;/p&gt;

&lt;p&gt;There is no particular connection between the lifetime of the &lt;code&gt;Shared&lt;/code&gt; pointer
here and the &lt;code&gt;Guard&lt;/code&gt;; if we have a reachable &lt;code&gt;Shared&lt;/code&gt; pointer, we know that the
guard it came from is active.&lt;/p&gt;

&lt;h3 id=&quot;treiber-39-s-stack-on-epochs&quot;&gt;Treiber&amp;rsquo;s stack on epochs&lt;/h3&gt;

&lt;p&gt;Without further ado, here is the code for Treiber&amp;rsquo;s stack using the Crossbeam
epoch API:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;kn&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Ordering&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;crossbeam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mem&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;epoch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Atomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Owned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TreiberStack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TreiberStack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TreiberStack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;TreiberStack&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// allocate the node via Owned&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Owned&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// become active&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;loop&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// snapshot current head&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;guard&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;// update `next` pointer with snapshot&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store_shared&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;// if snapshot is still good, link in the new node&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cas_and_ref&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;guard&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nb&quot;&gt;Ok&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;nb&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;owned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;owned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// become active&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;loop&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// take a snapshot&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;guard&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// the stack is non-empty&lt;/span&gt;
                &lt;span class=&quot;nb&quot;&gt;Some&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// read through the snapshot, *safely*!&lt;/span&gt;
                    &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;guard&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

                    &lt;span class=&quot;c1&quot;&gt;// if snapshot is still good, update from `head` to `next`&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cas_shared&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Some&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                            &lt;span class=&quot;c1&quot;&gt;// mark the node as unlinked&lt;/span&gt;
                            &lt;span class=&quot;n&quot;&gt;guard&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unlinked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

                            &lt;span class=&quot;c1&quot;&gt;// extract out the data from the now-unlinked node&lt;/span&gt;
                            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Some&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
                        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

                &lt;span class=&quot;c1&quot;&gt;// we observed the stack empty&lt;/span&gt;
                &lt;span class=&quot;nb&quot;&gt;None&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;None&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Some obserations:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The basic logic of the algorithm is identical to the version that relies on a
GC, except that we explicitly flag the popped node as &amp;ldquo;unlinked&amp;rdquo;. In general,
it&amp;rsquo;s possible to take lock-free algorithms &amp;ldquo;off the shelf&amp;rdquo; (the ones on the
shelf generally assume a GC) and code them up directly against Crossbeam in
this way.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;After we take a snapshot, we can dereference it without using &lt;code&gt;unsafe&lt;/code&gt;,
because the &lt;code&gt;guard&lt;/code&gt; guarantees its liveness.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The use of &lt;code&gt;ptr::read&lt;/code&gt; here is justified by our use of compare-and-swap to
ensure that only one thread calls it, and the fact that the epoch reclamation
scheme &lt;em&gt;does not run destructors&lt;/em&gt;, but merely deallocates memory.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The last point about deallocation deserves a bit more comment, so let&amp;rsquo;s wrap up
the API description by talking about garbage.&lt;/p&gt;

&lt;h3 id=&quot;managing-garbage&quot;&gt;Managing garbage&lt;/h3&gt;

&lt;p&gt;The design in Crossbeam treats epoch management as a service shared by all data
structures: there is a single static for global epoch state, and a single
thread-local for the per-thread state. This makes the epoch API very simple to
use, since there&amp;rsquo;s no per-data structure setup. It also means the (rather
trivial) space usage is tied to the number of threads using epochs, not the
number of data structures.&lt;/p&gt;

&lt;p&gt;One difference in Crossbeam&amp;rsquo;s implementation from the existing literature on
epochs is that &lt;em&gt;each thread keeps local garbage lists&lt;/em&gt;. That is, when a thread
marks a node as &amp;ldquo;unlinked&amp;rdquo; that node is added to some thread-local data, rather
than immediately to a global garbage list (which would require additional
synchronization).&lt;/p&gt;

&lt;p&gt;Each time you call &lt;code&gt;epoch::pin()&lt;/code&gt;, the current thread will check whether its
local garbage has surpassed a collection threshold, and if so, it will attempt a
collection. Likewise, whenever you call &lt;code&gt;epoch::pin()&lt;/code&gt;, if the global epoch has
advanced past the previous snapshot, the current thread can collect some of its
garbage. Besides avoiding global synchronization around the garbage lists, this
new scheme spreads out the work of actually freeing memory among all the threads
accessing a data structure.&lt;/p&gt;

&lt;p&gt;Because GC can only occur if all active threads are on the current epoch, it&amp;rsquo;s
not always possible to collect. But in practice, the garbage on a given thread
rarely exceeds the threshold.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s one catch, though: because GC can fail, if a thread is exiting, it needs
to do &lt;em&gt;something&lt;/em&gt; with its garbage. So the Crossbeam implementation &lt;em&gt;also&lt;/em&gt; has
global garbage lists, which are used as a last-ditch place to throw garbage when
a thread exits. These global garbage lists are collected by the thread that
successfully increments the global epoch.&lt;/p&gt;

&lt;p&gt;Finally, what does it mean to &amp;ldquo;collect&amp;rdquo; the garbage? As mentioned above, the
library &lt;em&gt;only&lt;/em&gt; deallocates the memory; it does not run
destructors.&lt;/p&gt;

&lt;p&gt;Conceptually, the framework splits up the destruction of an object into two
pieces: destroying/moving out interior data, and deallocating the object
containing it. The former should happen at the same time as invoking &lt;code&gt;unlinked&lt;/code&gt;
&amp;ndash; that&amp;rsquo;s the point where there is a unique thread that owns the object in every
sense except the ability to actually deallocate it. The latter happens at some
unknown later point, when the object is known to no longer be referenced. This
does impose an obligation on the user: access through a snapshot should only
read data that will be valid until deallocation. But this is basically always
the case for lock-free data structures, which tend to have a clear split between
data relevant to the container (i.e., &lt;code&gt;Atomic&lt;/code&gt; fields), and the actual data
contained (like the &lt;code&gt;data&lt;/code&gt; field in &lt;code&gt;Node&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Splitting up the tear down of an object this way means that destructors run
synchronously, at predictable times, alleviating one of the pain points of GC,
and allowing the framework to be used with non-&lt;code&gt;&amp;#39;static&lt;/code&gt; (and non-&lt;code&gt;Send&lt;/code&gt;) data.&lt;/p&gt;

&lt;h2 id=&quot;the-road-ahead&quot;&gt;The road ahead&lt;/h2&gt;

&lt;p&gt;Crossbeam is still in its infancy. The work here is laying the foundation for
exploring a wide range of lock-free data structures in Rust, and I hope for
Crossbeam to eventually play a role similar to java.util.concurrent for Rust &amp;ndash;
including a lock-free hashmap, work-stealing deques, and lightweight task
engine. If you&amp;rsquo;re interested in this work, I&amp;rsquo;d love to have help!&lt;/p&gt;
</content>
 </entry>
 

</feed>
