\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{€}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
\newcommand{\RegionMarkerTok}[1]{{#1}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
\newcommand{\NormalTok}[1]{{#1}}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={},
            pdftitle={The Rust Reference Manual},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{5}

\title{The Rust Reference Manual}

\begin{document}
\maketitle

0.11.0-pre (169c988d09a9d4e46de2b7fead9489e94964c7c7 2014-07-02 18:41:38 +0000)

Copyright © 2011-2014 The Rust Project Developers. Licensed under the
\href{http://www.apache.org/licenses/LICENSE-2.0}{Apache License,
Version 2.0} or the \href{http://opensource.org/licenses/MIT}{MIT
license}, at your option.

This file may not be copied, modified, or distributed except according
to those terms.

{
\hypersetup{linkcolor=black}
\setcounter{tocdepth}{3}
\tableofcontents
}
\section{Introduction}\label{introduction}

This document is the reference manual for the Rust programming language.
It provides three kinds of material:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Chapters that formally define the language grammar and, for each
  construct, informally describe its semantics and give examples of its
  use.
\item
  Chapters that informally describe the memory model, concurrency model,
  runtime services, linkage model and debugging facilities.
\item
  Appendix chapters providing rationale and references to languages that
  influenced the design.
\end{itemize}

This document does not serve as a tutorial introduction to the language.
Background familiarity with the language is assumed. A separate
\href{tutorial.html}{tutorial} document is available to help acquire
such background familiarity.

This document also does not serve as a reference to the
\href{std/index.html}{standard} library included in the language
distribution. Those libraries are documented separately by extracting
documentation attributes from their source code.

\subsection{Disclaimer}\label{disclaimer}

Rust is a work in progress. The language continues to evolve as the
design shifts and is fleshed out in working code. Certain parts work,
certain parts do not, certain parts will be removed or changed.

This manual is a snapshot written in the present tense. All features
described exist in working code unless otherwise noted, but some are
quite primitive or remain to be further modified by planned work. Some
may be temporary. It is a \emph{draft}, and we ask that you not take
anything you read here as final.

If you have suggestions to make, please try to focus them on
\emph{reductions} to the language: possible features that can be
combined or omitted. We aim to keep the size and complexity of the
language under control.

\begin{quote}
\textbf{Note:} The grammar for Rust given in this document is rough and
very incomplete; only a modest number of sections have accompanying
grammar rules. Formalizing the grammar accepted by the Rust parser is
ongoing work, but future versions of this document will contain a
complete grammar. Moreover, we hope that this grammar will be extracted
and verified as LL(1) by an automated grammar-analysis tool, and further
tested against the Rust sources. Preliminary versions of this automation
exist, but are not yet complete.
\end{quote}

\section{Notation}\label{notation}

Rust's grammar is defined over Unicode codepoints, each conventionally
denoted \texttt{U+XXXX}, for 4 or more hexadecimal digits \texttt{X}.
\emph{Most} of Rust's grammar is confined to the ASCII range of Unicode,
and is described in this document by a dialect of Extended Backus-Naur
Form (EBNF), specifically a dialect of EBNF supported by common
automated LL(k) parsing tools such as \texttt{llgen}, rather than the
dialect given in ISO 14977. The dialect can be defined
self-referentially as follows:

\begin{verbatim}
grammar : rule + ;
rule    : nonterminal ':' productionrule ';' ;
productionrule : production [ '|' production ] * ;
production : term * ;
term : element repeats ;
element : LITERAL | IDENTIFIER | '[' productionrule ']' ;
repeats : [ '*' | '+' ] NUMBER ? | NUMBER ? | '?' ;
\end{verbatim}

Where:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Whitespace in the grammar is ignored.
\item
  Square brackets are used to group rules.
\item
  \texttt{LITERAL} is a single printable ASCII character, or an escaped
  hexadecimal ASCII code of the form \texttt{\textbackslash{}xQQ}, in
  single quotes, denoting the corresponding Unicode codepoint
  \texttt{U+00QQ}.
\item
  \texttt{IDENTIFIER} is a nonempty string of ASCII letters and
  underscores.
\item
  The \texttt{repeat} forms apply to the adjacent \texttt{element}, and
  are as follows:

  \begin{itemize}
  \itemsep1pt\parskip0pt\parsep0pt
  \item
    \texttt{?} means zero or one repetition
  \item
    \texttt{*} means zero or more repetitions
  \item
    \texttt{+} means one or more repetitions
  \item
    NUMBER trailing a repeat symbol gives a maximum repetition count
  \item
    NUMBER on its own gives an exact repetition count
  \end{itemize}
\end{itemize}

This EBNF dialect should hopefully be familiar to many readers.

\subsection{Unicode productions}\label{unicode-productions}

A few productions in Rust's grammar permit Unicode codepoints outside
the ASCII range. We define these productions in terms of character
properties specified in the Unicode standard, rather than in terms of
ASCII-range codepoints. The section
\hyperref[special-unicode-productions]{Special Unicode Productions}
lists these productions.

\hyperdef{}{string-table-productions}{\subsection{String table
productions}\label{string-table-productions}}

Some rules in the grammar --- notably
\hyperref[unary-operator-expressions]{unary operators},
\hyperref[binary-operator-expressions]{binary operators}, and
\hyperref[keywords]{keywords} --- are given in a simplified form: as a
listing of a table of unquoted, printable whitespace-separated strings.
These cases form a subset of the rules regarding the
\hyperref[tokens]{token} rule, and are assumed to be the result of a
lexical-analysis phase feeding the parser, driven by a DFA, operating
over the disjunction of all such string table entries.

When such a string enclosed in double-quotes (\texttt{"}) occurs inside
the grammar, it is an implicit reference to a single member of such a
string table production. See \hyperref[tokens]{tokens} for more
information.

\section{Lexical structure}\label{lexical-structure}

\subsection{Input format}\label{input-format}

Rust input is interpreted as a sequence of Unicode codepoints encoded in
UTF-8, normalized to Unicode normalization form NFKC. Most Rust grammar
rules are defined in terms of printable ASCII-range codepoints, but a
small number are defined in terms of Unicode properties or explicit
codepoint lists. \footnote{Substitute definitions for the special
  Unicode productions are provided to the grammar verifier, restricted
  to ASCII range, when verifying the grammar in this document.}

\hyperdef{}{special-unicode-productions}{\subsection{Special Unicode
Productions}\label{special-unicode-productions}}

The following productions in the Rust grammar are defined in terms of
Unicode properties: \texttt{ident}, \texttt{non\_null},
\texttt{non\_star}, \texttt{non\_eol}, \texttt{non\_slash\_or\_star},
\texttt{non\_single\_quote} and \texttt{non\_double\_quote}.

\hyperdef{}{identifiers}{\subsubsection{Identifiers}\label{identifiers}}

The \texttt{ident} production is any nonempty Unicode string of the
following form:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  The first character has property \texttt{XID\_start}
\item
  The remaining characters have property \texttt{XID\_continue}
\end{itemize}

that does \emph{not} occur in the set of \hyperref[keywords]{keywords}.

Note: \texttt{XID\_start} and \texttt{XID\_continue} as character
properties cover the character ranges used to form the more familiar C
and Java language-family identifiers.

\subsubsection{Delimiter-restricted
productions}\label{delimiter-restricted-productions}

Some productions are defined by exclusion of particular Unicode
characters:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{non\_null} is any single Unicode character aside from
  \texttt{U+0000} (null)
\item
  \texttt{non\_eol} is \texttt{non\_null} restricted to exclude
  \texttt{U+000A} (\texttt{'\textbackslash{}n'})
\item
  \texttt{non\_star} is \texttt{non\_null} restricted to exclude
  \texttt{U+002A} (\texttt{*})
\item
  \texttt{non\_slash\_or\_star} is \texttt{non\_null} restricted to
  exclude \texttt{U+002F} (\texttt{/}) and \texttt{U+002A} (\texttt{*})
\item
  \texttt{non\_single\_quote} is \texttt{non\_null} restricted to
  exclude \texttt{U+0027} (\texttt{'})
\item
  \texttt{non\_double\_quote} is \texttt{non\_null} restricted to
  exclude \texttt{U+0022} (\texttt{"})
\end{itemize}

\subsection{Comments}\label{comments}

\begin{verbatim}
comment : block_comment | line_comment ;
block_comment : "/*" block_comment_body * '*' + '/' ;
block_comment_body : [block_comment | character] * ;
line_comment : "//" non_eol * ;
\end{verbatim}

Comments in Rust code follow the general C++ style of line and
block-comment forms. Nested block comments are supported.

Line comments beginning with exactly \emph{three} slashes
(\texttt{///}), and block comments beginning with exactly one repeated
asterisk in the block-open sequence (\texttt{/**}), are interpreted as a
special syntax for \texttt{doc} \hyperref[attributes]{attributes}. That
is, they are equivalent to writing \texttt{\#{[}doc="..."{]}} around the
body of the comment (this includes the comment characters themselves, ie
\texttt{/// Foo} turns into \texttt{\#{[}doc="/// Foo"{]}}).

Non-doc comments are interpreted as a form of whitespace.

\subsection{Whitespace}\label{whitespace}

\begin{verbatim}
whitespace_char : '\x20' | '\x09' | '\x0a' | '\x0d' ;
whitespace : [ whitespace_char | comment ] + ;
\end{verbatim}

The \texttt{whitespace\_char} production is any nonempty Unicode string
consisting of any of the following Unicode characters: \texttt{U+0020}
(space, \texttt{' '}), \texttt{U+0009} (tab,
\texttt{'\textbackslash{}t'}), \texttt{U+000A} (LF,
\texttt{'\textbackslash{}n'}), \texttt{U+000D} (CR,
\texttt{'\textbackslash{}r'}).

Rust is a ``free-form'' language, meaning that all forms of whitespace
serve only to separate \emph{tokens} in the grammar, and have no
semantic significance.

A Rust program has identical meaning if each whitespace element is
replaced with any other legal whitespace element, such as a single space
character.

\hyperdef{}{tokens}{\subsection{Tokens}\label{tokens}}

\begin{verbatim}
simple_token : keyword | unop | binop ;
token : simple_token | ident | literal | symbol | whitespace token ;
\end{verbatim}

Tokens are primitive productions in the grammar defined by regular
(non-recursive) languages. ``Simple'' tokens are given in
\hyperref[string-table-productions]{string table production} form, and
occur in the rest of the grammar as double-quoted strings. Other tokens
have exact rules given.

\hyperdef{}{keywords}{\subsubsection{Keywords}\label{keywords}}

The keywords are the following strings:

\begin{verbatim}
as
box break
continue crate
else enum extern
false fn for
if impl in
let loop
match mod mut
priv proc pub
ref return
self static struct super
true trait type
unsafe use
while
\end{verbatim}

Each of these keywords has special meaning in its grammar, and all of
them are excluded from the \texttt{ident} rule.

\hyperdef{}{literals}{\subsubsection{Literals}\label{literals}}

A literal is an expression consisting of a single token, rather than a
sequence of tokens, that immediately and directly denotes the value it
evaluates to, rather than referring to it by name or some other
evaluation rule. A literal is a form of constant expression, so is
evaluated (primarily) at compile time.

\begin{verbatim}
literal : string_lit | char_lit | byte_string_lit | byte_lit | num_lit ;
\end{verbatim}

\paragraph{Character and string
literals}\label{character-and-string-literals}

\begin{verbatim}
char_lit : '\x27' char_body '\x27' ;
string_lit : '"' string_body * '"' | 'r' raw_string ;

char_body : non_single_quote
          | '\x5c' [ '\x27' | common_escape | unicode_escape ] ;

string_body : non_double_quote
            | '\x5c' [ '\x22' | common_escape | unicode_escape ] ;
raw_string : '"' raw_string_body '"' | '#' raw_string '#' ;

common_escape : '\x5c'
              | 'n' | 'r' | 't' | '0'
              | 'x' hex_digit 2
unicode_escape : 'u' hex_digit 4
               | 'U' hex_digit 8 ;

hex_digit : 'a' | 'b' | 'c' | 'd' | 'e' | 'f'
          | 'A' | 'B' | 'C' | 'D' | 'E' | 'F'
          | dec_digit ;
oct_digit : '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' ;
dec_digit : '0' | nonzero_dec ;
nonzero_dec: '1' | '2' | '3' | '4'
           | '5' | '6' | '7' | '8' | '9' ;
\end{verbatim}

A \emph{character literal} is a single Unicode character enclosed within
two \texttt{U+0027} (single-quote) characters, with the exception of
\texttt{U+0027} itself, which must be \emph{escaped} by a preceding
U+005C character (\texttt{\textbackslash{}}).

A \emph{string literal} is a sequence of any Unicode characters enclosed
within two \texttt{U+0022} (double-quote) characters, with the exception
of \texttt{U+0022} itself, which must be \emph{escaped} by a preceding
\texttt{U+005C} character (\texttt{\textbackslash{}}), or a \emph{raw
string literal}.

Some additional \emph{escapes} are available in either character or
non-raw string literals. An escape starts with a \texttt{U+005C}
(\texttt{\textbackslash{}}) and continues with one of the following
forms:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  An \emph{8-bit codepoint escape} escape starts with \texttt{U+0078}
  (\texttt{x}) and is followed by exactly two \emph{hex digits}. It
  denotes the Unicode codepoint equal to the provided hex value.
\item
  A \emph{16-bit codepoint escape} starts with \texttt{U+0075}
  (\texttt{u}) and is followed by exactly four \emph{hex digits}. It
  denotes the Unicode codepoint equal to the provided hex value.
\item
  A \emph{32-bit codepoint escape} starts with \texttt{U+0055}
  (\texttt{U}) and is followed by exactly eight \emph{hex digits}. It
  denotes the Unicode codepoint equal to the provided hex value.
\item
  A \emph{whitespace escape} is one of the characters \texttt{U+006E}
  (\texttt{n}), \texttt{U+0072} (\texttt{r}), or \texttt{U+0074}
  (\texttt{t}), denoting the unicode values \texttt{U+000A} (LF),
  \texttt{U+000D} (CR) or \texttt{U+0009} (HT) respectively.
\item
  The \emph{backslash escape} is the character \texttt{U+005C}
  (\texttt{\textbackslash{}}) which must be escaped in order to denote
  \emph{itself}.
\end{itemize}

Raw string literals do not process any escapes. They start with the
character \texttt{U+0072} (\texttt{r}), followed by zero or more of the
character \texttt{U+0023} (\texttt{\#}) and a \texttt{U+0022}
(double-quote) character. The \emph{raw string body} is not defined in
the EBNF grammar above: it can contain any sequence of Unicode
characters and is terminated only by another \texttt{U+0022}
(double-quote) character, followed by the same number of \texttt{U+0023}
(\texttt{\#}) characters that preceded the opening \texttt{U+0022}
(double-quote) character.

All Unicode characters contained in the raw string body represent
themselves, the characters \texttt{U+0022} (double-quote) (except when
followed by at least as many \texttt{U+0023} (\texttt{\#}) characters as
were used to start the raw string literal) or \texttt{U+005C}
(\texttt{\textbackslash{}}) do not have any special meaning.

Examples for string literals:

\begin{verbatim}
"foo"; r"foo";                     // foo
"\"foo\""; r#""foo""#;             // "foo"

"foo #\"# bar";
r##"foo #"# bar"##;                // foo #"# bar

"\x52"; "R"; r"R";                 // R
"\\x52"; r"\x52";                  // \x52
\end{verbatim}

\paragraph{Byte and byte string
literals}\label{byte-and-byte-string-literals}

\begin{verbatim}
byte_lit : 'b' '\x27' byte_body '\x27' ;
byte_string_lit : 'b' '"' string_body * '"' | 'b' 'r' raw_byte_string ;

byte_body : ascii_non_single_quote
          | '\x5c' [ '\x27' | common_escape ] ;

byte_string_body : ascii_non_double_quote
            | '\x5c' [ '\x22' | common_escape ] ;
raw_byte_string : '"' raw_byte_string_body '"' | '#' raw_byte_string '#' ;
\end{verbatim}

A \emph{byte literal} is a single ASCII character (in the
\texttt{U+0000} to \texttt{U+007F} range) enclosed within two
\texttt{U+0027} (single-quote) characters, with the exception of
\texttt{U+0027} itself, which must be \emph{escaped} by a preceding
U+005C character (\texttt{\textbackslash{}}), or a single \emph{escape}.
It is equivalent to a \texttt{u8} unsigned 8-bit integer \emph{number
literal}.

A \emph{byte string literal} is a sequence of ASCII characters and
\emph{escapes} enclosed within two \texttt{U+0022} (double-quote)
characters, with the exception of \texttt{U+0022} itself, which must be
\emph{escaped} by a preceding \texttt{U+005C} character
(\texttt{\textbackslash{}}), or a \emph{raw byte string literal}. It is
equivalent to a \texttt{\&'static {[}u8{]}} borrowed vector of unsigned
8-bit integers.

Some additional \emph{escapes} are available in either byte or non-raw
byte string literals. An escape starts with a \texttt{U+005C}
(\texttt{\textbackslash{}}) and continues with one of the following
forms:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  An \emph{byte escape} escape starts with \texttt{U+0078} (\texttt{x})
  and is followed by exactly two \emph{hex digits}. It denotes the byte
  equal to the provided hex value.
\item
  A \emph{whitespace escape} is one of the characters \texttt{U+006E}
  (\texttt{n}), \texttt{U+0072} (\texttt{r}), or \texttt{U+0074}
  (\texttt{t}), denoting the bytes values \texttt{0x0A} (ASCII LF),
  \texttt{0x0D} (ASCII CR) or \texttt{0x09} (ASCII HT) respectively.
\item
  The \emph{backslash escape} is the character \texttt{U+005C}
  (\texttt{\textbackslash{}}) which must be escaped in order to denote
  its ASCII encoding \texttt{0x5C}.
\end{itemize}

Raw byte string literals do not process any escapes. They start with the
character \texttt{U+0072} (\texttt{r}), followed by \texttt{U+0062}
(\texttt{b}), followed by zero or more of the character \texttt{U+0023}
(\texttt{\#}), and a \texttt{U+0022} (double-quote) character. The
\emph{raw string body} is not defined in the EBNF grammar above: it can
contain any sequence of ASCII characters and is terminated only by
another \texttt{U+0022} (double-quote) character, followed by the same
number of \texttt{U+0023} (\texttt{\#}) characters that preceded the
opening \texttt{U+0022} (double-quote) character. A raw byte string
literal can not contain any non-ASCII byte.

All characters contained in the raw string body represent their ASCII
encoding, the characters \texttt{U+0022} (double-quote) (except when
followed by at least as many \texttt{U+0023} (\texttt{\#}) characters as
were used to start the raw string literal) or \texttt{U+005C}
(\texttt{\textbackslash{}}) do not have any special meaning.

Examples for byte string literals:

\begin{verbatim}
b"foo"; br"foo";                     // foo
b"\"foo\""; br#""foo""#;             // "foo"

b"foo #\"# bar";
br##"foo #"# bar"##;                 // foo #"# bar

b"\x52"; b"R"; br"R";                // R
b"\\x52"; br"\x52";                  // \x52
\end{verbatim}

\paragraph{Number literals}\label{number-literals}

\begin{verbatim}
num_lit : nonzero_dec [ dec_digit | '_' ] * num_suffix ?
        | '0' [       [ dec_digit | '_' ] * num_suffix ?
              | 'b'   [ '1' | '0' | '_' ] + int_suffix ?
              | 'o'   [ oct_digit | '_' ] + int_suffix ?
              | 'x'   [ hex_digit | '_' ] + int_suffix ? ] ;

num_suffix : int_suffix | float_suffix ;

int_suffix : 'u' int_suffix_size ?
           | 'i' int_suffix_size ? ;
int_suffix_size : [ '8' | '1' '6' | '3' '2' | '6' '4' ] ;

float_suffix : [ exponent | '.' dec_lit exponent ? ] ? float_suffix_ty ? ;
float_suffix_ty : 'f' [ '3' '2' | '6' '4' ] ;
exponent : ['E' | 'e'] ['-' | '+' ] ? dec_lit ;
dec_lit : [ dec_digit | '_' ] + ;
\end{verbatim}

A \emph{number literal} is either an \emph{integer literal} or a
\emph{floating-point literal}. The grammar for recognizing the two kinds
of literals is mixed, as they are differentiated by suffixes.

\subparagraph{Integer literals}\label{integer-literals}

An \emph{integer literal} has one of four forms:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  A \emph{decimal literal} starts with a \emph{decimal digit} and
  continues with any mixture of \emph{decimal digits} and
  \emph{underscores}.
\item
  A \emph{hex literal} starts with the character sequence
  \texttt{U+0030} \texttt{U+0078} (\texttt{0x}) and continues as any
  mixture hex digits and underscores.
\item
  An \emph{octal literal} starts with the character sequence
  \texttt{U+0030} \texttt{U+006F} (\texttt{0o}) and continues as any
  mixture octal digits and underscores.
\item
  A \emph{binary literal} starts with the character sequence
  \texttt{U+0030} \texttt{U+0062} (\texttt{0b}) and continues as any
  mixture binary digits and underscores.
\end{itemize}

An integer literal may be followed (immediately, without any spaces) by
an \emph{integer suffix}, which changes the type of the literal. There
are two kinds of integer literal suffix:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  The \texttt{i} and \texttt{u} suffixes give the literal type
  \texttt{int} or \texttt{uint}, respectively.
\item
  Each of the signed and unsigned machine types \texttt{u8},
  \texttt{i8}, \texttt{u16}, \texttt{i16}, \texttt{u32}, \texttt{i32},
  \texttt{u64} and \texttt{i64} give the literal the corresponding
  machine type.
\end{itemize}

The type of an \emph{unsuffixed} integer literal is determined by type
inference. If an integer type can be \emph{uniquely} determined from the
surrounding program context, the unsuffixed integer literal has that
type. If the program context underconstrains the type, it is considered
a static type error; if the program context overconstrains the type, it
is also considered a static type error.

Examples of integer literals of various forms:

\begin{verbatim}
123i;                              // type int
123u;                              // type uint
123_u;                             // type uint
0xff_u8;                           // type u8
0o70_i16;                          // type i16
0b1111_1111_1001_0000_i32;         // type i32
\end{verbatim}

\subparagraph{Floating-point literals}\label{floating-point-literals}

A \emph{floating-point literal} has one of two forms:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Two \emph{decimal literals} separated by a period character
  \texttt{U+002E} (\texttt{.}), with an optional \emph{exponent}
  trailing after the second decimal literal.
\item
  A single \emph{decimal literal} followed by an \emph{exponent}.
\end{itemize}

By default, a floating-point literal has a generic type, and, like
integer literals, the type must be uniquely determined from the context.
A floating-point literal may be followed (immediately, without any
spaces) by a \emph{floating-point suffix}, which changes the type of the
literal. There are two floating-point suffixes: \texttt{f32}, and
\texttt{f64} (the 32-bit and 64-bit floating point types).

Examples of floating-point literals of various forms:

\begin{verbatim}
123.0f64;                          // type f64
0.1f64;                            // type f64
0.1f32;                            // type f32
12E+99_f64;                        // type f64
\end{verbatim}

\hyperdef{}{unit-and-boolean-literals}{\subparagraph{Unit and boolean
literals}\label{unit-and-boolean-literals}}

The \emph{unit value}, the only value of the type that has the same
name, is written as \texttt{()}. The two values of the boolean type are
written \texttt{true} and \texttt{false}.

\subsubsection{Symbols}\label{symbols}

\begin{verbatim}
symbol : "::" "->"
       | '#' | '[' | ']' | '(' | ')' | '{' | '}'
       | ',' | ';' ;
\end{verbatim}

Symbols are a general class of printable \hyperref[tokens]{token} that
play structural roles in a variety of grammar productions. They are
catalogued here for completeness as the set of remaining miscellaneous
printable tokens that do not otherwise appear as
\hyperref[unary-operator-expressions]{unary operators},
\hyperref[binary-operator-expressions]{binary operators}, or
\hyperref[keywords]{keywords}.

\hyperdef{}{paths}{\subsection{Paths}\label{paths}}

\begin{verbatim}
expr_path : [ "::" ] ident [ "::" expr_path_tail ] + ;
expr_path_tail : '<' type_expr [ ',' type_expr ] + '>'
               | expr_path ;

type_path : ident [ type_path_tail ] + ;
type_path_tail : '<' type_expr [ ',' type_expr ] + '>'
               | "::" type_path ;
\end{verbatim}

A \emph{path} is a sequence of one or more path components
\emph{logically} separated by a namespace qualifier (\texttt{::}). If a
path consists of only one component, it may refer to either an
\hyperref[items]{item} or a \hyperref[memory-slots]{slot} in a local
control scope. If a path has multiple components, it refers to an item.

Every item has a \emph{canonical path} within its crate, but the path
naming an item is only meaningful within a given crate. There is no
global namespace across crates; an item's canonical path merely
identifies it within the crate.

Two examples of simple paths consisting of only identifier components:

\begin{verbatim}
x;
x::y::z;
\end{verbatim}

Path components are usually \hyperref[identifiers]{identifiers}, but the
trailing component of a path may be an angle-bracket-enclosed list of
type arguments. In \hyperref[expressions]{expression} context, the type
argument list is given after a final (\texttt{::}) namespace qualifier
in order to disambiguate it from a relational expression involving the
less-than symbol (\texttt{\textless{}}). In type expression context, the
final namespace qualifier is omitted.

Two examples of paths with type arguments:

\begin{verbatim}
# struct HashMap<K, V>;
# fn f() {
# fn id<T>(t: T) -> T { t }
type T = HashMap<int,String>;  // Type arguments used in a type expression
let x = id::<int>(10);       // Type arguments used in a call expression
# }
\end{verbatim}

Paths can be denoted with various leading qualifiers to change the
meaning of how it is resolved:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Paths starting with \texttt{::} are considered to be global paths
  where the components of the path start being resolved from the crate
  root. Each identifier in the path must resolve to an item.
\end{itemize}

\texttt{rust   mod a \{       pub fn foo() \{\}   \}   mod b \{       pub fn foo() \{           ::a::foo(); // call a's foo function       \}   \}   \# fn main() \{\}}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Paths starting with the keyword \texttt{super} begin resolution
  relative to the parent module. Each further identifier must resolve to
  an item
\end{itemize}

\texttt{rust   mod a \{       pub fn foo() \{\}   \}   mod b \{       pub fn foo() \{           super::a::foo(); // call a's foo function       \}   \}   \# fn main() \{\}}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Paths starting with the keyword \texttt{self} begin resolution
  relative to the current module. Each further identifier must resolve
  to an item.
\end{itemize}

\texttt{rust   fn foo() \{\}   fn bar() \{       self::foo();   \}   \# fn main() \{\}}

\section{Syntax extensions}\label{syntax-extensions}

A number of minor features of Rust are not central enough to have their
own syntax, and yet are not implementable as functions. Instead, they
are given names, and invoked through a consistent syntax:
\texttt{name!(...)}. Examples include:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{format!} : format data into a string
\item
  \texttt{env!} : look up an environment variable's value at compile
  time
\item
  \texttt{file!}: return the path to the file being compiled
\item
  \texttt{stringify!} : pretty-print the Rust expression given as an
  argument
\item
  \texttt{include!} : include the Rust expression in the given file
\item
  \texttt{include\_str!} : include the contents of the given file as a
  string
\item
  \texttt{include\_bin!} : include the contents of the given file as a
  binary blob
\item
  \texttt{error!}, \texttt{warn!}, \texttt{info!}, \texttt{debug!} :
  provide diagnostic information.
\end{itemize}

All of the above extensions are expressions with values.

\subsection{Macros}\label{macros}

\begin{verbatim}
expr_macro_rules : "macro_rules" '!' ident '(' macro_rule * ')' ;
macro_rule : '(' matcher * ')' "=>" '(' transcriber * ')' ';' ;
matcher : '(' matcher * ')' | '[' matcher * ']'
        | '{' matcher * '}' | '$' ident ':' ident
        | '$' '(' matcher * ')' sep_token? [ '*' | '+' ]
        | non_special_token ;
transcriber : '(' transcriber * ')' | '[' transcriber * ']'
            | '{' transcriber * '}' | '$' ident
            | '$' '(' transcriber * ')' sep_token? [ '*' | '+' ]
            | non_special_token ;
\end{verbatim}

User-defined syntax extensions are called ``macros'', and the
\texttt{macro\_rules} syntax extension defines them. Currently,
user-defined macros can expand to expressions, statements, or items.

(A \texttt{sep\_token} is any token other than \texttt{*} and
\texttt{+}. A \texttt{non\_special\_token} is any token other than a
delimiter or \texttt{\$}.)

The macro expander looks up macro invocations by name, and tries each
macro rule in turn. It transcribes the first successful match. Matching
and transcription are closely related to each other, and we will
describe them together.

\subsubsection{Macro By Example}\label{macro-by-example}

The macro expander matches and transcribes every token that does not
begin with a \texttt{\$} literally, including delimiters. For parsing
reasons, delimiters must be balanced, but they are otherwise not
special.

In the matcher, \texttt{\$} \emph{name} \texttt{:} \emph{designator}
matches the nonterminal in the Rust syntax named by \emph{designator}.
Valid designators are \texttt{item}, \texttt{block}, \texttt{stmt},
\texttt{pat}, \texttt{expr}, \texttt{ty} (type), \texttt{ident},
\texttt{path}, \texttt{matchers} (lhs of the \texttt{=\textgreater{}} in
macro rules), \texttt{tt} (rhs of the \texttt{=\textgreater{}} in macro
rules). In the transcriber, the designator is already known, and so only
the name of a matched nonterminal comes after the dollar sign.

In both the matcher and transcriber, the Kleene star-like operator
indicates repetition. The Kleene star operator consists of \texttt{\$}
and parens, optionally followed by a separator token, followed by
\texttt{*} or \texttt{+}. \texttt{*} means zero or more repetitions,
\texttt{+} means at least one repetition. The parens are not matched or
transcribed. On the matcher side, a name is bound to \emph{all} of the
names it matches, in a structure that mimics the structure of the
repetition encountered on a successful match. The job of the transcriber
is to sort that structure out.

The rules for transcription of these repetitions are called ``Macro By
Example''. Essentially, one ``layer'' of repetition is discharged at a
time, and all of them must be discharged by the time a name is
transcribed. Therefore,
\texttt{( \$( \$i:ident ),* ) =\textgreater{} ( \$i )} is an invalid
macro, but
\texttt{( \$( \$i:ident ),* ) =\textgreater{} ( \$( \$i:ident ),*  )} is
acceptable (if trivial).

When Macro By Example encounters a repetition, it examines all of the
\texttt{\$} \emph{name} s that occur in its body. At the ``current
layer'', they all must repeat the same number of times, so
\texttt{( \$( \$i:ident ),* ; \$( \$j:ident ),* ) =\textgreater{} ( \$( (\$i,\$j) ),* )}
is valid if given the argument \texttt{(a,b,c ; d,e,f)}, but not
\texttt{(a,b,c ; d,e)}. The repetition walks through the choices at that
layer in lockstep, so the former input transcribes to
\texttt{( (a,d), (b,e), (c,f) )}.

Nested repetitions are allowed.

\subsubsection{Parsing limitations}\label{parsing-limitations}

The parser used by the macro system is reasonably powerful, but the
parsing of Rust syntax is restricted in two ways:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\itemsep1pt\parskip0pt\parsep0pt
\item
  The parser will always parse as much as possible. If it attempts to
  match \texttt{\$i:expr {[} , {]}} against \texttt{8 {[} , {]}}, it
  will attempt to parse \texttt{i} as an array index operation and fail.
  Adding a separator can solve this problem.
\item
  The parser must have eliminated all ambiguity by the time it reaches a
  \texttt{\$} \emph{name} \texttt{:} \emph{designator}. This requirement
  most often affects name-designator pairs when they occur at the
  beginning of, or immediately after, a \texttt{\$(...)*}; requiring a
  distinctive token in front can solve the problem.
\end{enumerate}

\subsection{Syntax extensions useful for the macro
author}\label{syntax-extensions-useful-for-the-macro-author}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{log\_syntax!} : print out the arguments at compile time
\item
  \texttt{trace\_macros!} : supply \texttt{true} or \texttt{false} to
  enable or disable macro expansion logging
\item
  \texttt{stringify!} : turn the identifier argument into a string
  literal
\item
  \texttt{concat!} : concatenates a comma-separated list of literals
\item
  \texttt{concat\_idents!} : create a new identifier by concatenating
  the arguments
\end{itemize}

\section{Crates and source files}\label{crates-and-source-files}

Rust is a \emph{compiled} language. Its semantics obey a \emph{phase
distinction} between compile-time and run-time. Those semantic rules
that have a \emph{static interpretation} govern the success or failure
of compilation. We refer to these rules as ``static semantics''.
Semantic rules called ``dynamic semantics'' govern the behavior of
programs at run-time. A program that fails to compile due to violation
of a compile-time rule has no defined dynamic semantics; the compiler
should halt with an error report, and produce no executable artifact.

The compilation model centres on artifacts called \emph{crates}. Each
compilation processes a single crate in source form, and if successful,
produces a single crate in binary form: either an executable or a
library.\footnote{A crate is somewhat analogous to an \emph{assembly} in
  the ECMA-335 CLI model, a \emph{library} in the SML/NJ Compilation
  Manager, a \emph{unit} in the Owens and Flatt module system, or a
  \emph{configuration} in Mesa.}

A \emph{crate} is a unit of compilation and linking, as well as
versioning, distribution and runtime loading. A crate contains a
\emph{tree} of nested \hyperref[modules]{module} scopes. The top level
of this tree is a module that is anonymous (from the point of view of
paths within the module) and any item within a crate has a canonical
\hyperref[paths]{module path} denoting its location within the crate's
module tree.

The Rust compiler is always invoked with a single source file as input,
and always produces a single output crate. The processing of that source
file may result in other source files being loaded as modules. Source
files have the extension \texttt{.rs}.

A Rust source file describes a module, the name and location of which
--- in the module tree of the current crate --- are defined from outside
the source file: either by an explicit \texttt{mod\_item} in a
referencing source file, or by the name of the crate itself.

Each source file contains a sequence of zero or more \texttt{item}
definitions, and may optionally begin with any number of
\texttt{attributes} that apply to the containing module. Attributes on
the anonymous crate module define important metadata that influences the
behavior of the compiler.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{# #![allow(unused_attribute)]}
\CommentTok{// Crate ID}
\NormalTok{#![crate_id = }\StringTok{"projx#2.5"}\NormalTok{]}

\CommentTok{// Additional metadata attributes}
\NormalTok{#![desc = }\StringTok{"Project X"}\NormalTok{]}
\NormalTok{#![license = }\StringTok{"BSD"}\NormalTok{]}
\NormalTok{#![comment = }\StringTok{"This is a comment on Project X."}\NormalTok{]}

\CommentTok{// Specify the output type}
\NormalTok{#![crate_type = }\StringTok{"lib"}\NormalTok{]}

\CommentTok{// Turn on a warning}
\NormalTok{#![warn(non_camel_case_types)]}
\end{Highlighting}
\end{Shaded}

A crate that contains a \texttt{main} function can be compiled to an
executable. If a \texttt{main} function is present, its return type must
be \hyperref[primitive-types]{\texttt{unit}} and it must take no
arguments.

\section{Items and attributes}\label{items-and-attributes}

Crates contain \hyperref[items]{items}, each of which may have some
number of \hyperref[attributes]{attributes} attached to it.

\hyperdef{}{items}{\subsection{Items}\label{items}}

\begin{verbatim}
item : mod_item | fn_item | type_item | struct_item | enum_item
     | static_item | trait_item | impl_item | extern_block ;
\end{verbatim}

An \emph{item} is a component of a crate; some module items can be
defined in crate files, but most are defined in source files. Items are
organized within a crate by a nested set of \hyperref[modules]{modules}.
Every crate has a single ``outermost'' anonymous module; all further
items within the crate have \hyperref[paths]{paths} within the module
tree of the crate.

Items are entirely determined at compile-time, generally remain fixed
during execution, and may reside in read-only memory.

There are several kinds of item:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \hyperref[modules]{modules}
\item
  \hyperref[functions]{functions}
\item
  \hyperref[type-definitions]{type definitions}
\item
  \hyperref[structures]{structures}
\item
  \hyperref[enumerations]{enumerations}
\item
  \hyperref[static-items]{static items}
\item
  \hyperref[traits]{traits}
\item
  \hyperref[implementations]{implementations}
\end{itemize}

Some items form an implicit scope for the declaration of sub-items. In
other words, within a function or module, declarations of items can (in
many cases) be mixed with the statements, control blocks, and similar
artifacts that otherwise compose the item body. The meaning of these
scoped items is the same as if the item was declared outside the scope
--- it is still a static item --- except that the item's \emph{path
name} within the module namespace is qualified by the name of the
enclosing item, or is private to the enclosing item (in the case of
functions). The grammar specifies the exact locations in which sub-item
declarations may appear.

\subsubsection{Type Parameters}\label{type-parameters}

All items except modules may be \emph{parameterized} by type. Type
parameters are given as a comma-separated list of identifiers enclosed
in angle brackets (\texttt{\textless{}...\textgreater{}}), after the
name of the item and before its definition. The type parameters of an
item are considered ``part of the name'', not part of the type of the
item. A referencing \hyperref[paths]{path} must (in principle) provide
type arguments as a list of comma-separated types enclosed within angle
brackets, in order to refer to the type-parameterized item. In practice,
the type-inference system can usually infer such argument types from
context. There are no general type-parametric types, only
type-parametric items. That is, Rust has no notion of type abstraction:
there are no first-class ``forall'' types.

\hyperdef{}{modules}{\subsubsection{Modules}\label{modules}}

\begin{verbatim}
mod_item : "mod" ident ( ';' | '{' mod '}' );
mod : [ view_item | item ] * ;
\end{verbatim}

A module is a container for zero or more \hyperref[view-items]{view
items} and zero or more \hyperref[items]{items}. The view items manage
the visibility of the items defined within the module, as well as the
visibility of names from outside the module when referenced from inside
the module.

A \emph{module item} is a module, surrounded in braces, named, and
prefixed with the keyword \texttt{mod}. A module item introduces a new,
named module into the tree of modules making up a crate. Modules can
nest arbitrarily.

An example of a module:

\begin{verbatim}
mod math {
    type Complex = (f64, f64);
    fn sin(f: f64) -> f64 {
        /* ... */
# fail!();
    }
    fn cos(f: f64) -> f64 {
        /* ... */
# fail!();
    }
    fn tan(f: f64) -> f64 {
        /* ... */
# fail!();
    }
}
\end{verbatim}

Modules and types share the same namespace. Declaring a named type that
has the same name as a module in scope is forbidden: that is, a type
definition, trait, struct, enumeration, or type parameter can't shadow
the name of a module in scope, or vice versa.

A module without a body is loaded from an external file, by default with
the same name as the module, plus the \texttt{.rs} extension. When a
nested submodule is loaded from an external file, it is loaded from a
subdirectory path that mirrors the module hierarchy.

\begin{verbatim}
// Load the `vec` module from `vec.rs`
mod vec;

mod task {
    // Load the `local_data` module from `task/local_data.rs`
    mod local_data;
}
\end{verbatim}

The directories and files used for loading external file modules can be
influenced with the \texttt{path} attribute.

\begin{verbatim}
#[path = "task_files"]
mod task {
    // Load the `local_data` module from `task_files/tls.rs`
    #[path = "tls.rs"]
    mod local_data;
}
\end{verbatim}

\hyperdef{}{view-items}{\paragraph{View items}\label{view-items}}

\begin{verbatim}
view_item : extern_crate_decl | use_decl ;
\end{verbatim}

A view item manages the namespace of a module. View items do not define
new items, but rather, simply change other items' visibility. There are
several kinds of view item:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \hyperref[extern-crate-declarations]{\texttt{extern crate}
  declarations}
\item
  \hyperref[use-declarations]{\texttt{use} declarations}
\end{itemize}

\hyperdef{}{extern-crate-declarations}{\subparagraph{Extern crate
declarations}\label{extern-crate-declarations}}

\begin{verbatim}
extern_crate_decl : "extern" "crate" ident [ '(' link_attrs ')' ] ? [ '=' string_lit ] ? ;
link_attrs : link_attr [ ',' link_attrs ] + ;
link_attr : ident '=' literal ;
\end{verbatim}

An \emph{\texttt{extern crate} declaration} specifies a dependency on an
external crate. The external crate is then bound into the declaring
scope as the \texttt{ident} provided in the
\texttt{extern\_crate\_decl}.

The external crate is resolved to a specific \texttt{soname} at compile
time, and a runtime linkage requirement to that \texttt{soname} is
passed to the linker for loading at runtime. The \texttt{soname} is
resolved at compile time by scanning the compiler's library path and
matching the optional \texttt{crateid} provided as a string literal
against the \texttt{crateid} attributes that were declared on the
external crate when it was compiled. If no \texttt{crateid} is provided,
a default \texttt{name} attribute is assumed, equal to the
\texttt{ident} given in the \texttt{extern\_crate\_decl}.

Four examples of \texttt{extern crate} declarations:

\begin{verbatim}
extern crate pcre;

extern crate std; // equivalent to: extern crate std = "std";

extern crate ruststd = "std"; // linking to 'std' under another name

extern crate foo = "some/where/rust-foo#foo:1.0"; // a full crate ID for external tools
\end{verbatim}

\hyperdef{}{use-declarations}{\subparagraph{Use
declarations}\label{use-declarations}}

\begin{verbatim}
use_decl : "pub" ? "use" [ ident '=' path
                          | path_glob ] ;

path_glob : ident [ "::" [ path_glob
                          | '*' ] ] ?
          | '{' ident [ ',' ident ] * '}' ;
\end{verbatim}

A \emph{use declaration} creates one or more local name bindings
synonymous with some other \hyperref[paths]{path}. Usually a
\texttt{use} declaration is used to shorten the path required to refer
to a module item. These declarations may appear at the top of
\hyperref[modules]{modules} and \hyperref[blocks]{blocks}.

\emph{Note}: Unlike in many languages, \texttt{use} declarations in Rust
do \emph{not} declare linkage dependency with external crates. Rather,
\hyperref[extern-crate-declarations]{\texttt{extern crate} declarations}
declare linkage dependencies.

Use declarations support a number of convenient shortcuts:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Rebinding the target name as a new local name, using the syntax
  \texttt{use x = p::q::r;}.
\item
  Simultaneously binding a list of paths differing only in their final
  element, using the glob-like brace syntax
  \texttt{use a::b::\{c,d,e,f\};}
\item
  Binding all paths matching a given prefix, using the asterisk wildcard
  syntax \texttt{use a::b::*;}
\end{itemize}

An example of \texttt{use} declarations:

\begin{verbatim}
use std::iter::range_step;
use std::option::{Some, None};

# fn foo<T>(_: T){}

fn main() {
    // Equivalent to 'std::iter::range_step(0u, 10u, 2u);'
    range_step(0u, 10u, 2u);

    // Equivalent to 'foo(vec![std::option::Some(1.0f64),
    // std::option::None]);'
    foo(vec![Some(1.0f64), None]);
}
\end{verbatim}

Like items, \texttt{use} declarations are private to the containing
module, by default. Also like items, a \texttt{use} declaration can be
public, if qualified by the \texttt{pub} keyword. Such a \texttt{use}
declaration serves to \emph{re-export} a name. A public \texttt{use}
declaration can therefore \emph{redirect} some public name to a
different target definition: even a definition with a private canonical
path, inside a different module. If a sequence of such redirections form
a cycle or cannot be resolved unambiguously, they represent a
compile-time error.

An example of re-exporting:

\begin{verbatim}
# fn main() { }
mod quux {
    pub use quux::foo::{bar, baz};

    pub mod foo {
        pub fn bar() { }
        pub fn baz() { }
    }
}
\end{verbatim}

In this example, the module \texttt{quux} re-exports two public names
defined in \texttt{foo}.

Also note that the paths contained in \texttt{use} items are relative to
the crate root. So, in the previous example, the \texttt{use} refers to
\texttt{quux::foo::\{bar, baz\}}, and not simply to
\texttt{foo::\{bar, baz\}}. This also means that top-level module
declarations should be at the crate root if direct usage of the declared
modules within \texttt{use} items is desired. It is also possible to use
\texttt{self} and \texttt{super} at the beginning of a \texttt{use} item
to refer to the current and direct parent modules respectively. All
rules regarding accessing declared modules in \texttt{use} declarations
applies to both module declarations and \texttt{extern crate}
declarations.

An example of what will and will not work for \texttt{use} items:

\begin{verbatim}
# #![allow(unused_imports)]
use foo::native::start;  // good: foo is at the root of the crate
use foo::baz::foobaz;    // good: foo is at the root of the crate

mod foo {
    extern crate native;

    use foo::native::start; // good: foo is at crate root
//  use native::start;      // bad:  native is not at the crate root
    use self::baz::foobaz;  // good: self refers to module 'foo'
    use foo::bar::foobar;   // good: foo is at crate root

    pub mod bar {
        pub fn foobar() { }
    }

    pub mod baz {
        use super::bar::foobar; // good: super refers to module 'foo'
        pub fn foobaz() { }
    }
}

fn main() {}
\end{verbatim}

\hyperdef{}{functions}{\subsubsection{Functions}\label{functions}}

A \emph{function item} defines a sequence of
\hyperref[statements]{statements} and an optional final
\hyperref[expressions]{expression}, along with a name and a set of
parameters. Functions are declared with the keyword \texttt{fn}.
Functions declare a set of \emph{input}
\hyperref[memory-slots]{\emph{slots}} as parameters, through which the
caller passes arguments into the function, and an \emph{output}
\hyperref[memory-slots]{\emph{slot}} through which the function passes
results back to the caller.

A function may also be copied into a first class \emph{value}, in which
case the value has the corresponding
\hyperref[function-types]{\emph{function type}}, and can be used
otherwise exactly as a function item (with a minor additional cost of
calling the function indirectly).

Every control path in a function logically ends with a \texttt{return}
expression or a diverging expression. If the outermost block of a
function has a value-producing expression in its final-expression
position, that expression is interpreted as an implicit \texttt{return}
expression applied to the final-expression.

An example of a function:

\begin{verbatim}
fn add(x: int, y: int) -> int {
    return x + y;
}
\end{verbatim}

As with \texttt{let} bindings, function arguments are irrefutable
patterns, so any pattern that is valid in a let binding is also valid as
an argument.

\begin{verbatim}
fn first((value, _): (int, int)) -> int { value }
\end{verbatim}

\hyperdef{}{generic-functions}{\paragraph{Generic
functions}\label{generic-functions}}

A \emph{generic function} allows one or more \emph{parameterized types}
to appear in its signature. Each type parameter must be explicitly
declared, in an angle-bracket-enclosed, comma-separated list following
the function name.

\begin{verbatim}
fn iter<T>(seq: &[T], f: |T|) {
    for elt in seq.iter() { f(elt); }
}
fn map<T, U>(seq: &[T], f: |T| -> U) -> Vec<U> {
    let mut acc = vec![];
    for elt in seq.iter() { acc.push(f(elt)); }
    acc
}
\end{verbatim}

Inside the function signature and body, the name of the type parameter
can be used as a type name.

When a generic function is referenced, its type is instantiated based on
the context of the reference. For example, calling the \texttt{iter}
function defined above on \texttt{{[}1, 2{]}} will instantiate type
parameter \texttt{T} with \texttt{int}, and require the closure
parameter to have type \texttt{fn(int)}.

The type parameters can also be explicitly supplied in a trailing
\hyperref[paths]{path} component after the function name. This might be
necessary if there is not sufficient context to determine the type
parameters. For example,
\texttt{mem::size\_of::\textless{}u32\textgreater{}() == 4}.

Since a parameter type is opaque to the generic function, the set of
operations that can be performed on it is limited. Values of parameter
type can only be moved, not copied.

\begin{verbatim}
fn id<T>(x: T) -> T { x }
\end{verbatim}

Similarly, \hyperref[traits]{trait} bounds can be specified for type
parameters to allow methods with that trait to be called on values of
that type.

\paragraph{Unsafety}\label{unsafety}

Unsafe operations are those that potentially violate the memory-safety
guarantees of Rust's static semantics.

The following language level features cannot be used in the safe subset
of Rust:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Dereferencing a \hyperref[pointer-types]{raw pointer}.
\item
  Reading or writing a \hyperref[mutable-statics]{mutable static
  variable}.
\item
  Calling an unsafe function (including an intrinsic or foreign
  function).
\end{itemize}

\hyperdef{}{unsafe-functions}{\subparagraph{Unsafe
functions}\label{unsafe-functions}}

Unsafe functions are functions that are not safe in all contexts and/or
for all possible inputs. Such a function must be prefixed with the
keyword \texttt{unsafe}.

\subparagraph{Unsafe blocks}\label{unsafe-blocks}

A block of code can also be prefixed with the \texttt{unsafe} keyword,
to permit calling \texttt{unsafe} functions or dereferencing raw
pointers within a safe function.

When a programmer has sufficient conviction that a sequence of
potentially unsafe operations is actually safe, they can encapsulate
that sequence (taken as a whole) within an \texttt{unsafe} block. The
compiler will consider uses of such code safe, in the surrounding
context.

Unsafe blocks are used to wrap foreign libraries, make direct use of
hardware or implement features not directly present in the language. For
example, Rust provides the language features necessary to implement
memory-safe concurrency in the language but the implementation of tasks
and message passing is in the standard library.

Rust's type system is a conservative approximation of the dynamic safety
requirements, so in some cases there is a performance cost to using safe
code. For example, a doubly-linked list is not a tree structure and can
only be represented with managed or reference-counted pointers in safe
code. By using \texttt{unsafe} blocks to represent the reverse links as
raw pointers, it can be implemented with only owned pointers.

\subparagraph{Behavior considered
unsafe}\label{behavior-considered-unsafe}

This is a list of behavior which is forbidden in all Rust code. Type
checking provides the guarantee that these issues are never caused by
safe code. An \texttt{unsafe} block or function is responsible for never
invoking this behaviour or exposing an API making it possible for it to
occur in safe code.

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Data races
\item
  Dereferencing a null/dangling raw pointer
\item
  Mutating an immutable value/reference
\item
  Reads of
  \href{http://llvm.org/docs/LangRef.html\#undefined-values}{undef}
  (uninitialized) memory
\item
  Breaking the
  \href{http://llvm.org/docs/LangRef.html\#pointer-aliasing-rules}{pointer
  aliasing rules} with raw pointers (a subset of the rules used by C)
\item
  Invoking undefined behavior via compiler intrinsics:

  \begin{itemize}
  \itemsep1pt\parskip0pt\parsep0pt
  \item
    Indexing outside of the bounds of an object with
    \texttt{std::ptr::offset} (\texttt{offset} intrinsic), with the
    exception of one byte past the end which is permitted.
  \item
    Using \texttt{std::ptr::copy\_nonoverlapping\_memory}
    (\texttt{memcpy32}/\texttt{memcpy64} instrinsics) on overlapping
    buffers
  \end{itemize}
\item
  Invalid values in primitive types, even in private fields/locals:

  \begin{itemize}
  \itemsep1pt\parskip0pt\parsep0pt
  \item
    Dangling/null pointers in non-raw pointers, or slices
  \item
    A value other than \texttt{false} (0) or \texttt{true} (1) in a
    \texttt{bool}
  \item
    A discriminant in an \texttt{enum} not included in the type
    definition
  \item
    A value in a \texttt{char} which is a surrogate or above
    \texttt{char::MAX}
  \item
    non-UTF-8 byte sequences in a \texttt{str}
  \end{itemize}
\end{itemize}

\subparagraph{Behaviour not considered
unsafe}\label{behaviour-not-considered-unsafe}

This is a list of behaviour not considered \emph{unsafe} in Rust terms,
but that may be undesired.

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Deadlocks
\item
  Reading data from private fields (\texttt{std::repr},
  \texttt{format!("\{:?\}", x)})
\item
  Leaks due to reference count cycles, even in the global heap
\item
  Exiting without calling destructors
\item
  Sending signals
\item
  Accessing/modifying the file system
\item
  Unsigned integer overflow (well-defined as wrapping)
\item
  Signed integer overflow (well-defined as two's complement
  representation wrapping)
\end{itemize}

\paragraph{Diverging functions}\label{diverging-functions}

A special kind of function can be declared with a \texttt{!} character
where the output slot type would normally be. For example:

\begin{verbatim}
fn my_err(s: &str) -> ! {
    println!("{}", s);
    fail!();
}
\end{verbatim}

We call such functions ``diverging'' because they never return a value
to the caller. Every control path in a diverging function must end with
a \texttt{fail!()} or a call to another diverging function on every
control path. The \texttt{!} annotation does \emph{not} denote a type.
Rather, the result type of a diverging function is a special type called
$\bot$ (``bottom'') that unifies with any type. Rust has no syntax for
$\bot$.

It might be necessary to declare a diverging function because as
mentioned previously, the typechecker checks that every control path in
a function ends with a \hyperref[return-expressions]{\texttt{return}} or
diverging expression. So, if \texttt{my\_err} were declared without the
\texttt{!} annotation, the following code would not typecheck:

\begin{verbatim}
# fn my_err(s: &str) -> ! { fail!() }

fn f(i: int) -> int {
   if i == 42 {
     return 42;
   }
   else {
     my_err("Bad number!");
   }
}
\end{verbatim}

This will not compile without the \texttt{!} annotation on
\texttt{my\_err}, since the \texttt{else} branch of the conditional in
\texttt{f} does not return an \texttt{int}, as required by the signature
of \texttt{f}. Adding the \texttt{!} annotation to \texttt{my\_err}
informs the typechecker that, should control ever enter
\texttt{my\_err}, no further type judgments about \texttt{f} need to
hold, since control will never resume in any context that relies on
those judgments. Thus the return type on \texttt{f} only needs to
reflect the \texttt{if} branch of the conditional.

\paragraph{Extern functions}\label{extern-functions}

Extern functions are part of Rust's foreign function interface,
providing the opposite functionality to
\hyperref[external-blocks]{external blocks}. Whereas external blocks
allow Rust code to call foreign code, extern functions with bodies
defined in Rust code \emph{can be called by foreign code}. They are
defined in the same way as any other Rust function, except that they
have the \texttt{extern} modifier.

\begin{verbatim}
// Declares an extern fn, the ABI defaults to "C"
extern fn new_int() -> int { 0 }

// Declares an extern fn with "stdcall" ABI
extern "stdcall" fn new_int_stdcall() -> int { 0 }
\end{verbatim}

Unlike normal functions, extern fns have an \texttt{extern "ABI" fn()}.
This is the same type as the functions declared in an extern block.

\begin{verbatim}
# extern fn new_int() -> int { 0 }
let fptr: extern "C" fn() -> int = new_int;
\end{verbatim}

Extern functions may be called directly from Rust code as Rust uses
large, contiguous stack segments like C.

\hyperdef{}{type-definitions}{\subsubsection{Type
definitions}\label{type-definitions}}

A \emph{type definition} defines a new name for an existing
\hyperref[types]{type}. Type definitions are declared with the keyword
\texttt{type}. Every value has a single, specific type; the
type-specified aspects of a value include:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Whether the value is composed of sub-values or is indivisible.
\item
  Whether the value represents textual or numerical information.
\item
  Whether the value represents integral or floating-point information.
\item
  The sequence of memory operations required to access the value.
\item
  The \hyperref[type-kinds]{kind} of the type.
\end{itemize}

For example, the type \texttt{(u8, u8)} defines the set of immutable
values that are composite pairs, each containing two unsigned 8-bit
integers accessed by pattern-matching and laid out in memory with the
\texttt{x} component preceding the \texttt{y} component.

\hyperdef{}{structures}{\subsubsection{Structures}\label{structures}}

A \emph{structure} is a nominal \hyperref[structure-types]{structure
type} defined with the keyword \texttt{struct}.

An example of a \texttt{struct} item and its use:

\begin{verbatim}
struct Point {x: int, y: int}
let p = Point {x: 10, y: 11};
let px: int = p.x;
\end{verbatim}

A \emph{tuple structure} is a nominal \hyperref[tuple-types]{tuple
type}, also defined with the keyword \texttt{struct}. For example:

\begin{verbatim}
struct Point(int, int);
let p = Point(10, 11);
let px: int = match p { Point(x, _) => x };
\end{verbatim}

A \emph{unit-like struct} is a structure without any fields, defined by
leaving off the list of fields entirely. Such types will have a single
value, just like the \hyperref[unit-and-boolean-literals]{unit value
\texttt{()}} of the unit type. For example:

\begin{verbatim}
struct Cookie;
let c = [Cookie, Cookie, Cookie, Cookie];
\end{verbatim}

By using the \texttt{struct\_inherit} feature gate, structures may use
single inheritance. A Structure may only inherit from a single other
structure, called the \emph{super-struct}. The inheriting structure
(sub-struct) acts as if all fields in the super-struct were present in
the sub-struct. Fields declared in a sub-struct must not have the same
name as any field in any (transitive) super-struct. All fields (both
declared and inherited) must be specified in any initializers.
Inheritance between structures does not give subtyping or coercion. The
super-struct and sub-struct must be defined in the same crate. The
super-struct must be declared using the \texttt{virtual} keyword. For
example:

\begin{verbatim}
virtual struct Sup { x: int }
struct Sub : Sup { y: int }
let s = Sub {x: 10, y: 11};
let sx = s.x;
\end{verbatim}

\hyperdef{}{enumerations}{\subsubsection{Enumerations}\label{enumerations}}

An \emph{enumeration} is a simultaneous definition of a nominal
\hyperref[enumerated-types]{enumerated type} as well as a set of
\emph{constructors}, that can be used to create or pattern-match values
of the corresponding enumerated type.

Enumerations are declared with the keyword \texttt{enum}.

An example of an \texttt{enum} item and its use:

\begin{verbatim}
enum Animal {
  Dog,
  Cat
}

let mut a: Animal = Dog;
a = Cat;
\end{verbatim}

Enumeration constructors can have either named or unnamed fields:

\begin{verbatim}
# #![feature(struct_variant)]
# fn main() {
enum Animal {
    Dog (String, f64),
    Cat { name: String, weight: f64 }
}

let mut a: Animal = Dog("Cocoa".to_string(), 37.2);
a = Cat { name: "Spotty".to_string(), weight: 2.7 };
# }
\end{verbatim}

In this example, \texttt{Cat} is a \emph{struct-like enum variant},
whereas \texttt{Dog} is simply called an enum variant.

\hyperdef{}{static-items}{\subsubsection{Static
items}\label{static-items}}

\begin{verbatim}
static_item : "static" ident ':' type '=' expr ';' ;
\end{verbatim}

A \emph{static item} is a named \emph{constant value} stored in the
global data section of a crate. Immutable static items are stored in the
read-only data section. The constant value bound to a static item is,
like all constant values, evaluated at compile time. Static items have
the \texttt{static} lifetime, which outlives all other lifetimes in a
Rust program. Static items are declared with the \texttt{static}
keyword. A static item must have a \emph{constant expression} giving its
definition.

Static items must be explicitly typed. The type may be \texttt{bool},
\texttt{char}, a number, or a type derived from those primitive types.
The derived types are references with the \texttt{static} lifetime,
fixed-size arrays, tuples, and structs.

\begin{verbatim}
static BIT1: uint = 1 << 0;
static BIT2: uint = 1 << 1;

static BITS: [uint, ..2] = [BIT1, BIT2];
static STRING: &'static str = "bitstring";

struct BitsNStrings<'a> {
    mybits: [uint, ..2],
    mystring: &'a str
}

static bits_n_strings: BitsNStrings<'static> = BitsNStrings {
    mybits: BITS,
    mystring: STRING
};
\end{verbatim}

\hyperdef{}{mutable-statics}{\paragraph{Mutable
statics}\label{mutable-statics}}

If a static item is declared with the \texttt{mut} keyword, then it is
allowed to be modified by the program. One of Rust's goals is to make
concurrency bugs hard to run into, and this is obviously a very large
source of race conditions or other bugs. For this reason, an
\texttt{unsafe} block is required when either reading or writing a
mutable static variable. Care should be taken to ensure that
modifications to a mutable static are safe with respect to other tasks
running in the same process.

Mutable statics are still very useful, however. They can be used with C
libraries and can also be bound from C libraries (in an \texttt{extern}
block).

\begin{verbatim}
# fn atomic_add(_: &mut uint, _: uint) -> uint { 2 }

static mut LEVELS: uint = 0;

// This violates the idea of no shared state, and this doesn't internally
// protect against races, so this function is `unsafe`
unsafe fn bump_levels_unsafe1() -> uint {
    let ret = LEVELS;
    LEVELS += 1;
    return ret;
}

// Assuming that we have an atomic_add function which returns the old value,
// this function is "safe" but the meaning of the return value may not be what
// callers expect, so it's still marked as `unsafe`
unsafe fn bump_levels_unsafe2() -> uint {
    return atomic_add(&mut LEVELS, 1);
}
\end{verbatim}

\hyperdef{}{traits}{\subsubsection{Traits}\label{traits}}

A \emph{trait} describes a set of method types.

Traits can include default implementations of methods, written in terms
of some unknown \hyperref[self-types]{\texttt{self} type}; the
\texttt{self} type may either be completely unspecified, or constrained
by some other trait.

Traits are implemented for specific types through separate
\hyperref[implementations]{implementations}.

\begin{verbatim}
# type Surface = int;
# type BoundingBox = int;
trait Shape {
    fn draw(&self, Surface);
    fn bounding_box(&self) -> BoundingBox;
}
\end{verbatim}

This defines a trait with two methods. All values that have
\hyperref[implementations]{implementations} of this trait in scope can
have their \texttt{draw} and \texttt{bounding\_box} methods called,
using \texttt{value.bounding\_box()}
\hyperref[method-call-expressions]{syntax}.

Type parameters can be specified for a trait to make it generic. These
appear after the trait name, using the same syntax used in
\hyperref[generic-functions]{generic functions}.

\begin{verbatim}
trait Seq<T> {
   fn len(&self) -> uint;
   fn elt_at(&self, n: uint) -> T;
   fn iter(&self, |T|);
}
\end{verbatim}

Generic functions may use traits as \emph{bounds} on their type
parameters. This will have two effects: only types that have the trait
may instantiate the parameter, and within the generic function, the
methods of the trait can be called on values that have the parameter's
type. For example:

\begin{verbatim}
# type Surface = int;
# trait Shape { fn draw(&self, Surface); }
fn draw_twice<T: Shape>(surface: Surface, sh: T) {
    sh.draw(surface);
    sh.draw(surface);
}
\end{verbatim}

Traits also define an \hyperref[object-types]{object type} with the same
name as the trait. Values of this type are created by
\hyperref[type-cast-expressions]{casting} pointer values (pointing to a
type for which an implementation of the given trait is in scope) to
pointers to the trait name, used as a type.

\begin{verbatim}
# trait Shape { }
# impl Shape for int { }
# let mycircle = 0i;
let myshape: Box<Shape> = box mycircle as Box<Shape>;
\end{verbatim}

The resulting value is a box containing the value that was cast, along
with information that identifies the methods of the implementation that
was used. Values with a trait type can have
\hyperref[method-call-expressions]{methods called} on them, for any
method in the trait, and can be used to instantiate type parameters that
are bounded by the trait.

Trait methods may be static, which means that they lack a \texttt{self}
argument. This means that they can only be called with function call
syntax (\texttt{f(x)}) and not method call syntax (\texttt{obj.f()}).
The way to refer to the name of a static method is to qualify it with
the trait name, treating the trait name like a module. For example:

\begin{verbatim}
trait Num {
    fn from_int(n: int) -> Self;
}
impl Num for f64 {
    fn from_int(n: int) -> f64 { n as f64 }
}
let x: f64 = Num::from_int(42);
\end{verbatim}

Traits may inherit from other traits. For example, in

\begin{verbatim}
trait Shape { fn area() -> f64; }
trait Circle : Shape { fn radius() -> f64; }
\end{verbatim}

the syntax \texttt{Circle : Shape} means that types that implement
\texttt{Circle} must also have an implementation for \texttt{Shape}.
Multiple supertraits are separated by \texttt{+},
\texttt{trait Circle : Shape + PartialEq \{ \}}. In an implementation of
\texttt{Circle} for a given type \texttt{T}, methods can refer to
\texttt{Shape} methods, since the typechecker checks that any type with
an implementation of \texttt{Circle} also has an implementation of
\texttt{Shape}.

In type-parameterized functions, methods of the supertrait may be called
on values of subtrait-bound type parameters. Referring to the previous
example of \texttt{trait Circle : Shape}:

\begin{verbatim}
# trait Shape { fn area(&self) -> f64; }
# trait Circle : Shape { fn radius(&self) -> f64; }
fn radius_times_area<T: Circle>(c: T) -> f64 {
    // `c` is both a Circle and a Shape
    c.radius() * c.area()
}
\end{verbatim}

Likewise, supertrait methods may also be called on trait objects.

\begin{verbatim}
# trait Shape { fn area(&self) -> f64; }
# trait Circle : Shape { fn radius(&self) -> f64; }
# impl Shape for int { fn area(&self) -> f64 { 0.0 } }
# impl Circle for int { fn radius(&self) -> f64 { 0.0 } }
# let mycircle = 0;
let mycircle: Circle = ~mycircle as ~Circle;
let nonsense = mycircle.radius() * mycircle.area();
\end{verbatim}

\hyperdef{}{implementations}{\subsubsection{Implementations}\label{implementations}}

An \emph{implementation} is an item that implements a
\hyperref[traits]{trait} for a specific type.

Implementations are defined with the keyword \texttt{impl}.

\begin{verbatim}
# struct Point {x: f64, y: f64};
# type Surface = int;
# struct BoundingBox {x: f64, y: f64, width: f64, height: f64};
# trait Shape { fn draw(&self, Surface); fn bounding_box(&self) -> BoundingBox; }
# fn do_draw_circle(s: Surface, c: Circle) { }
struct Circle {
    radius: f64,
    center: Point,
}

impl Shape for Circle {
    fn draw(&self, s: Surface) { do_draw_circle(s, *self); }
    fn bounding_box(&self) -> BoundingBox {
        let r = self.radius;
        BoundingBox{x: self.center.x - r, y: self.center.y - r,
         width: 2.0 * r, height: 2.0 * r}
    }
}
\end{verbatim}

It is possible to define an implementation without referring to a trait.
The methods in such an implementation can only be used as direct calls
on the values of the type that the implementation targets. In such an
implementation, the trait type and \texttt{for} after \texttt{impl} are
omitted. Such implementations are limited to nominal types (enums,
structs), and the implementation must appear in the same module or a
sub-module as the \texttt{self} type.

When a trait \emph{is} specified in an \texttt{impl}, all methods
declared as part of the trait must be implemented, with matching types
and type parameter counts.

An implementation can take type parameters, which can be different from
the type parameters taken by the trait it implements. Implementation
parameters are written after the \texttt{impl} keyword.

\begin{verbatim}
# trait Seq<T> { }
impl<T> Seq<T> for Vec<T> {
   /* ... */
}
impl Seq<bool> for u32 {
   /* Treat the integer as a sequence of bits */
}
\end{verbatim}

\hyperdef{}{external-blocks}{\subsubsection{External
blocks}\label{external-blocks}}

\begin{verbatim}
extern_block_item : "extern" '{' extern_block '}' ;
extern_block : [ foreign_fn ] * ;
\end{verbatim}

External blocks form the basis for Rust's foreign function interface.
Declarations in an external block describe symbols in external, non-Rust
libraries.

Functions within external blocks are declared in the same way as other
Rust functions, with the exception that they may not have a body and are
instead terminated by a semicolon.

\begin{verbatim}
extern crate libc;
use libc::{c_char, FILE};

extern {
    fn fopen(filename: *const c_char, mode: *const c_char) -> *mut FILE;
}
# fn main() {}
\end{verbatim}

Functions within external blocks may be called by Rust code, just like
functions defined in Rust. The Rust compiler automatically translates
between the Rust ABI and the foreign ABI.

A number of \hyperref[attributes]{attributes} control the behavior of
external blocks.

By default external blocks assume that the library they are calling uses
the standard C ``cdecl'' ABI. Other ABIs may be specified using an
\texttt{abi} string, as shown here:

\begin{verbatim}
// Interface to the Windows API
extern "stdcall" { }
\end{verbatim}

The \texttt{link} attribute allows the name of the library to be
specified. When specified the compiler will attempt to link against the
native library of the specified name.

\begin{verbatim}
#[link(name = "crypto")]
extern { }
\end{verbatim}

The type of a function declared in an extern block is
\texttt{extern "abi" fn(A1, ..., An) -\textgreater{} R}, where
\texttt{A1...An} are the declared types of its arguments and \texttt{R}
is the declared return type.

\subsection{Visibility and Privacy}\label{visibility-and-privacy}

These two terms are often used interchangeably, and what they are
attempting to convey is the answer to the question ``Can this item be
used at this location?''

Rust's name resolution operates on a global hierarchy of namespaces.
Each level in the hierarchy can be thought of as some item. The items
are one of those mentioned above, but also include external crates.
Declaring or defining a new module can be thought of as inserting a new
tree into the hierarchy at the location of the definition.

To control whether interfaces can be used across modules, Rust checks
each use of an item to see whether it should be allowed or not. This is
where privacy warnings are generated, or otherwise ``you used a private
item of another module and weren't allowed to.''

By default, everything in rust is \emph{private}, with one exception.
Enum variants in a \texttt{pub} enum are also public by default. You are
allowed to alter this default visibility with the \texttt{priv} keyword.
When an item is declared as \texttt{pub}, it can be thought of as being
accessible to the outside world. For example:

\begin{verbatim}
# fn main() {}
// Declare a private struct
struct Foo;

// Declare a public struct with a private field
pub struct Bar {
    field: int
}

// Declare a public enum with two public variants
pub enum State {
    PubliclyAccessibleState,
    PubliclyAccessibleState2,
}
\end{verbatim}

With the notion of an item being either public or private, Rust allows
item accesses in two cases:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\itemsep1pt\parskip0pt\parsep0pt
\item
  If an item is public, then it can be used externally through any of
  its public ancestors.
\item
  If an item is private, it may be accessed by the current module and
  its descendants.
\end{enumerate}

These two cases are surprisingly powerful for creating module
hierarchies exposing public APIs while hiding internal implementation
details. To help explain, here's a few use cases and what they would
entail.

\begin{itemize}
\item
  A library developer needs to expose functionality to crates which link
  against their library. As a consequence of the first case, this means
  that anything which is usable externally must be \texttt{pub} from the
  root down to the destination item. Any private item in the chain will
  disallow external accesses.
\item
  A crate needs a global available ``helper module'' to itself, but it
  doesn't want to expose the helper module as a public API. To
  accomplish this, the root of the crate's hierarchy would have a
  private module which then internally has a ``public api''. Because the
  entire crate is a descendant of the root, then the entire local crate
  can access this private module through the second case.
\item
  When writing unit tests for a module, it's often a common idiom to
  have an immediate child of the module to-be-tested named
  \texttt{mod test}. This module could access any items of the parent
  module through the second case, meaning that internal implementation
  details could also be seamlessly tested from the child module.
\end{itemize}

In the second case, it mentions that a private item ``can be accessed''
by the current module and its descendants, but the exact meaning of
accessing an item depends on what the item is. Accessing a module, for
example, would mean looking inside of it (to import more items). On the
other hand, accessing a function would mean that it is invoked.
Additionally, path expressions and import statements are considered to
access an item in the sense that the import/expression is only valid if
the destination is in the current visibility scope.

Here's an example of a program which exemplifies the three cases
outlined above.

\begin{verbatim}
// This module is private, meaning that no external crate can access this
// module. Because it is private at the root of this current crate, however, any
// module in the crate may access any publicly visible item in this module.
mod crate_helper_module {

    // This function can be used by anything in the current crate
    pub fn crate_helper() {}

    // This function *cannot* be used by anything else in the crate. It is not
    // publicly visible outside of the `crate_helper_module`, so only this
    // current module and its descendants may access it.
    fn implementation_detail() {}
}

// This function is "public to the root" meaning that it's available to external
// crates linking against this one.
pub fn public_api() {}

// Similarly to 'public_api', this module is public so external crates may look
// inside of it.
pub mod submodule {
    use crate_helper_module;

    pub fn my_method() {
        // Any item in the local crate may invoke the helper module's public
        // interface through a combination of the two rules above.
        crate_helper_module::crate_helper();
    }

    // This function is hidden to any module which is not a descendant of
    // `submodule`
    fn my_implementation() {}

    #[cfg(test)]
    mod test {

        #[test]
        fn test_my_implementation() {
            // Because this module is a descendant of `submodule`, it's allowed
            // to access private items inside of `submodule` without a privacy
            // violation.
            super::my_implementation();
        }
    }
}

# fn main() {}
\end{verbatim}

For a rust program to pass the privacy checking pass, all paths must be
valid accesses given the two rules above. This includes all use
statements, expressions, types, etc.

\hyperdef{}{re-exporting-and-visibility}{\subsubsection{Re-exporting and
Visibility}\label{re-exporting-and-visibility}}

Rust allows publicly re-exporting items through a \texttt{pub use}
directive. Because this is a public directive, this allows the item to
be used in the current module through the rules above. It essentially
allows public access into the re-exported item. For example, this
program is valid:

\begin{verbatim}
pub use api = self::implementation;

mod implementation {
    pub fn f() {}
}

# fn main() {}
\end{verbatim}

This means that any external crate referencing
\texttt{implementation::f} would receive a privacy violation, while the
path \texttt{api::f} would be allowed.

When re-exporting a private item, it can be thought of as allowing the
``privacy chain'' being short-circuited through the reexport instead of
passing through the namespace hierarchy as it normally would.

\subsubsection{Glob imports and
Visibility}\label{glob-imports-and-visibility}

Currently glob imports are considered an ``experimental'' language
feature. For sanity purpose along with helping the implementation, glob
imports will only import public items from their destination, not
private items.

\begin{quote}
\textbf{Note:} This is subject to change, glob exports may be removed
entirely or they could possibly import private items for a privacy error
to later be issued if the item is used.
\end{quote}

\hyperdef{}{attributes}{\subsection{Attributes}\label{attributes}}

\begin{verbatim}
attribute : '#' '!' ? '[' meta_item ']' ;
meta_item : ident [ '=' literal
                  | '(' meta_seq ')' ] ? ;
meta_seq : meta_item [ ',' meta_seq ] ? ;
\end{verbatim}

Static entities in Rust --- crates, modules and items --- may have
\emph{attributes} applied to them. Attributes in Rust are modeled on
Attributes in ECMA-335, with the syntax coming from ECMA-334 (C\#). An
attribute is a general, free-form metadatum that is interpreted
according to name, convention, and language and compiler version.
Attributes may appear as any of:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  A single identifier, the attribute name
\item
  An identifier followed by the equals sign `=' and a literal, providing
  a key/value pair
\item
  An identifier followed by a parenthesized list of sub-attribute
  arguments
\end{itemize}

Attributes with a bang (``!'') after the hash (``\#'') apply to the item
that the attribute is declared within. Attributes that do not have a
bang after the hash apply to the item that follows the attribute.

An example of attributes:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// General metadata applied to the enclosing module or crate.}
\NormalTok{#![license = }\StringTok{"BSD"}\NormalTok{]}

\CommentTok{// A function marked as a unit test}
\OtherTok{#[}\NormalTok{test}\OtherTok{]}
\KeywordTok{fn} \NormalTok{test_foo() \{}
  \CommentTok{/* ... */}
\NormalTok{\}}

\CommentTok{// A conditionally-compiled module}
\OtherTok{#[}\NormalTok{cfg}\OtherTok{(}\NormalTok{target}\OtherTok{_}\NormalTok{os}\OtherTok{=}\StringTok{"linux"}\OtherTok{)]}
\KeywordTok{mod} \NormalTok{bar \{}
  \CommentTok{/* ... */}
\NormalTok{\}}

\CommentTok{// A lint attribute used to suppress a warning/error}
\OtherTok{#[}\NormalTok{allow}\OtherTok{(}\NormalTok{non}\OtherTok{_}\NormalTok{camel}\OtherTok{_}\NormalTok{case}\OtherTok{_}\NormalTok{types}\OtherTok{)]}
\KeywordTok{type} \NormalTok{int8_t = }\KeywordTok{i8}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

\begin{quote}
\textbf{Note:} At some point in the future, the compiler will
distinguish between language-reserved and user-available attributes.
Until then, there is effectively no difference between an attribute
handled by a loadable syntax extension and the compiler.
\end{quote}

\subsubsection{Crate-only attributes}\label{crate-only-attributes}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{crate\_id} - specify the this crate's crate ID.
\item
  \texttt{crate\_type} - see \hyperref[linkage]{linkage}.
\item
  \texttt{feature} - see \hyperref[compiler-features]{compiler
  features}.
\item
  \texttt{no\_main} - disable emitting the \texttt{main} symbol. Useful
  when some other object being linked to defines \texttt{main}.
\item
  \texttt{no\_start} - disable linking to the \texttt{native} crate,
  which specifies the ``start'' language item.
\item
  \texttt{no\_std} - disable linking to the \texttt{std} crate.
\item
  \texttt{no\_builtins} - disable optimizing certain code patterns to
  invocations of library functions that are assumed to exist
\end{itemize}

\subsubsection{Module-only attributes}\label{module-only-attributes}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{macro\_escape} - macros defined in this module will be visible
  in the module's parent, after this module has been included.
\item
  \texttt{no\_implicit\_prelude} - disable injecting
  \texttt{use std::prelude::*} in this module.
\item
  \texttt{path} - specifies the file to load the module from.
  \texttt{\#{[}path="foo.rs"{]} mod   bar;} is equivalent to
  \texttt{mod bar \{ /* contents of foo.rs */ \}}. The path is taken
  relative to the directory that the current module is in.
\end{itemize}

\subsubsection{Function-only attributes}\label{function-only-attributes}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{plugin\_registrar} - mark this function as the registration
  point for compiler plugins, such as loadable syntax extensions.
\item
  \texttt{main} - indicates that this function should be passed to the
  entry point, rather than the function in the crate root named
  \texttt{main}.
\item
  \texttt{start} - indicates that this function should be used as the
  entry point, overriding the ``start'' language item. See the ``start''
  \hyperref[language-items]{language item} for more details.
\end{itemize}

\subsubsection{Static-only attributes}\label{static-only-attributes}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{thread\_local} - on a \texttt{static mut}, this signals that
  the value of this static may change depending on the current thread.
  The exact consequences of this are implementation-defined.
\end{itemize}

\subsubsection{FFI attributes}\label{ffi-attributes}

On an \texttt{extern} block, the following attributes are interpreted:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{link\_args} - specify arguments to the linker, rather than
  just the library name and type. This is feature gated and the exact
  behavior is implementation-defined (due to variety of linker
  invocation syntax).
\item
  \texttt{link} - indicate that a native library should be linked to for
  the declarations in this block to be linked correctly. See
  \hyperref[external-blocks]{external blocks}
\end{itemize}

On declarations inside an \texttt{extern} block, the following
attributes are interpreted:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{link\_name} - the name of the symbol that this function or
  static should be imported as.
\item
  \texttt{linkage} - on a static, this specifies the
  \href{http://llvm.org/docs/LangRef.html\#linkage-types}{linkage type}.
\end{itemize}

\subsubsection{Miscellaneous attributes}\label{miscellaneous-attributes}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{link\_section} - on statics and functions, this specifies the
  section of the object file that this item's contents will be placed
  into.
\item
  \texttt{macro\_export} - export a macro for cross-crate usage.
\item
  \texttt{no\_mangle} - on any item, do not apply the standard name
  mangling. Set the symbol for this item to its identifier.
\item
  \texttt{packed} - on structs or enums, eliminate any padding that
  would be used to align fields.
\item
  \texttt{repr} - on C-like enums, this sets the underlying type used
  for representation. Useful for FFI. Takes one argument, which is the
  primitive type this enum should be represented for, or \texttt{C},
  which specifies that it should be the default \texttt{enum} size of
  the C ABI for that platform. Note that enum representation in C is
  undefined, and this may be incorrect when the C code is compiled with
  certain flags.
\item
  \texttt{simd} - on certain tuple structs, derive the arithmetic
  operators, which lower to the target's SIMD instructions, if any; the
  \texttt{simd} feature gate is necessary to use this attribute.
\item
  \texttt{static\_assert} - on statics whose type is \texttt{bool},
  terminates compilation with an error if it is not initialized to
  \texttt{true}.
\item
  \texttt{unsafe\_destructor} - allow implementations of the ``drop''
  language item where the type it is implemented for does not implement
  the ``send'' language item; the \texttt{unsafe\_destructor} feature
  gate is needed to use this attribute
\item
  \texttt{unsafe\_no\_drop\_flag} - on structs, remove the flag that
  prevents destructors from being run twice. Destructors might be run
  multiple times on the same object with this attribute.
\end{itemize}

\subsubsection{Conditional compilation}\label{conditional-compilation}

Sometimes one wants to have different compiler outputs from the same
code, depending on build target, such as targeted operating system, or
to enable release builds.

There are two kinds of configuration options, one that is either defined
or not (\texttt{\#{[}cfg(foo){]}}), and the other that contains a string
that can be checked against (\texttt{\#{[}cfg(bar = "baz"){]}}
(currently only compiler-defined configuration options can have the
latter form).

\begin{verbatim}
// The function is only included in the build when compiling for OSX
#[cfg(target_os = "macos")]
fn macos_only() {
  // ...
}

// This function is only included when either foo or bar is defined
#[cfg(foo)]
#[cfg(bar)]
fn needs_foo_or_bar() {
  // ...
}

// This function is only included when compiling for a unixish OS with a 32-bit
// architecture
#[cfg(unix, target_word_size = "32")]
fn on_32bit_unix() {
  // ...
}
\end{verbatim}

This illustrates some conditional compilation can be achieved using the
\texttt{\#{[}cfg(...){]}} attribute. Note that
\texttt{\#{[}cfg(foo, bar){]}} is a condition that needs both
\texttt{foo} and \texttt{bar} to be defined while
\texttt{\#{[}cfg(foo){]} \#{[}cfg(bar){]}} only needs one of
\texttt{foo} and \texttt{bar} to be defined (this resembles in the
disjunctive normal form). Additionally, one can reverse a condition by
enclosing it in a \texttt{not(...)}, like e. g.
\texttt{\#{[}cfg(not(target\_os = "win32")){]}}.

The following configurations must be defined by the implementation:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{target\_arch = "..."}. Target CPU architecture, such as
  \texttt{"x86"}, \texttt{"x86\_64"} \texttt{"mips"}, or \texttt{"arm"}.
\item
  \texttt{target\_endian = "..."}. Endianness of the target CPU, either
  \texttt{"little"} or \texttt{"big"}.
\item
  \texttt{target\_family = "..."}. Operating system family of the
  target, e. g. \texttt{"unix"} or \texttt{"windows"}. The value of this
  configuration option is defined as a configuration itself, like
  \texttt{unix} or \texttt{windows}.
\item
  \texttt{target\_os = "..."}. Operating system of the target, examples
  include \texttt{"win32"}, \texttt{"macos"}, \texttt{"linux"},
  \texttt{"android"} or \texttt{"freebsd"}.
\item
  \texttt{target\_word\_size = "..."}. Target word size in bits. This is
  set to \texttt{"32"} for targets with 32-bit pointers, and likewise
  set to \texttt{"64"} for 64-bit pointers.
\item
  \texttt{unix}. See \texttt{target\_family}.
\item
  \texttt{windows}. See \texttt{target\_family}.
\end{itemize}

\subsubsection{Lint check attributes}\label{lint-check-attributes}

A lint check names a potentially undesirable coding pattern, such as
unreachable code or omitted documentation, for the static entity to
which the attribute applies.

For any lint check \texttt{C}:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{warn(C)} warns about violations of \texttt{C} but continues
  compilation,
\item
  \texttt{deny(C)} signals an error after encountering a violation of
  \texttt{C},
\item
  \texttt{allow(C)} overrides the check for \texttt{C} so that
  violations will go unreported,
\item
  \texttt{forbid(C)} is the same as \texttt{deny(C)}, but also forbids
  changing the lint level afterwards.
\end{itemize}

The lint checks supported by the compiler can be found via
\texttt{rustc -W help}, along with their default settings.

\begin{verbatim}
mod m1 {
    // Missing documentation is ignored here
    #[allow(missing_doc)]
    pub fn undocumented_one() -> int { 1 }

    // Missing documentation signals a warning here
    #[warn(missing_doc)]
    pub fn undocumented_too() -> int { 2 }

    // Missing documentation signals an error here
    #[deny(missing_doc)]
    pub fn undocumented_end() -> int { 3 }
}
\end{verbatim}

This example shows how one can use \texttt{allow} and \texttt{warn} to
toggle a particular check on and off.

\begin{verbatim}
#[warn(missing_doc)]
mod m2{
    #[allow(missing_doc)]
    mod nested {
        // Missing documentation is ignored here
        pub fn undocumented_one() -> int { 1 }

        // Missing documentation signals a warning here,
        // despite the allow above.
        #[warn(missing_doc)]
        pub fn undocumented_two() -> int { 2 }
    }

    // Missing documentation signals a warning here
    pub fn undocumented_too() -> int { 3 }
}
\end{verbatim}

This example shows how one can use \texttt{forbid} to disallow uses of
\texttt{allow} for that lint check.

\begin{verbatim}
#[forbid(missing_doc)]
mod m3 {
    // Attempting to toggle warning signals an error here
    #[allow(missing_doc)]
    /// Returns 2.
    pub fn undocumented_too() -> int { 2 }
}
\end{verbatim}

\hyperdef{}{language-items}{\subsubsection{Language
items}\label{language-items}}

Some primitive Rust operations are defined in Rust code, rather than
being implemented directly in C or assembly language. The definitions of
these operations have to be easy for the compiler to find. The
\texttt{lang} attribute makes it possible to declare these operations.
For example, the \texttt{str} module in the Rust standard library
defines the string equality function:

\begin{verbatim}
#[lang="str_eq"]
pub fn eq_slice(a: &str, b: &str) -> bool {
    // details elided
}
\end{verbatim}

The name \texttt{str\_eq} has a special meaning to the Rust compiler,
and the presence of this definition means that it will use this
definition when generating calls to the string equality function.

A complete list of the built-in language items follows:

\paragraph{Built-in Traits}\label{built-in-traits}

\begin{itemize}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{send}]
  Able to be sent across task boundaries.
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{sized}]
  Has a size known at compile time.
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{copy}]
  Types that do not move ownership when used by-value.
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{share}]
  Able to be safely shared between tasks when aliased.
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{drop}]
  Have destructors.
  \end{description}
\end{itemize}

\paragraph{Operators}\label{operators}

These language items are traits:

\begin{itemize}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{add}]
  Elements can be added (for example, integers and floats).
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{sub}]
  Elements can be subtracted.
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{mul}]
  Elements can be multiplied.
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{div}]
  Elements have a division operation.
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{rem}]
  Elements have a remainder operation.
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{neg}]
  Elements can be negated arithmetically.
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{not}]
  Elements can be negated logically.
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{bitxor}]
  Elements have an exclusive-or operation.
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{bitand}]
  Elements have a bitwise \texttt{and} operation.
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{bitor}]
  Elements have a bitwise \texttt{or} operation.
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{shl}]
  Elements have a left shift operation.
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{shr}]
  Elements have a right shift operation.
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{index}]
  Elements can be indexed.
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{eq}]
  Elements can be compared for equality.
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{ord}]
  Elements have a partial ordering.
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{deref}]
  \texttt{*} can be applied, yielding a reference to another type
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{deref\_mut}]
  \texttt{*} can be applied, yielding a mutable reference to another
  type
  \end{description}
\end{itemize}

These are functions:

\begin{itemize}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{str\_eq}]
  Compare two strings (\texttt{\&str}) for equality.
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{uniq\_str\_eq}]
  Compare two owned strings (\texttt{String}) for equality.
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{strdup\_uniq}]
  Return a new unique string
  \end{description}

  containing a copy of the contents of a unique string.
\end{itemize}

\hyperdef{}{types}{\paragraph{Types}\label{types}}

\begin{itemize}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{unsafe}]
  A type whose contents can be mutated through an immutable reference
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{type\_id}]
  The type returned by the \texttt{type\_id} intrinsic.
  \end{description}
\end{itemize}

\paragraph{Marker types}\label{marker-types}

These types help drive the compiler's analysis

\begin{itemize}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{covariant\_type}]
  The type parameter should be considered covariant
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{contravariant\_type}]
  The type parameter should be considered contravariant
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{invariant\_type}]
  The type parameter should be considered invariant
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{covariant\_lifetime}]
  The lifetime parameter should be considered covariant
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{contravariant\_lifetime}]
  The lifetime parameter should be considered contravariant
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{invariant\_lifetime}]
  The lifetime parameter should be considered invariant
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{no\_send\_bound}]
  This type does not implement ``send'', even if eligible
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{no\_copy\_bound}]
  This type does not implement ``copy'', even if eligible
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{no\_share\_bound}]
  This type does not implement ``share'', even if eligible
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{managed\_bound}]
  This type implements ``managed''
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{fail\_}]
  Abort the program with an error.
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{fail\_bounds\_check}]
  Abort the program with a bounds check error.
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{exchange\_malloc}]
  Allocate memory on the exchange heap.
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{exchange\_free}]
  Free memory that was allocated on the exchange heap.
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{malloc}]
  Allocate memory on the managed heap.
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{free}]
  Free memory that was allocated on the managed heap.
  \end{description}
\end{itemize}

\begin{quote}
\textbf{Note:} This list is likely to become out of date. We should
auto-generate it from \texttt{librustc/middle/lang\_items.rs}.
\end{quote}

\subsubsection{Inline attributes}\label{inline-attributes}

The inline attribute is used to suggest to the compiler to perform an
inline expansion and place a copy of the function or static in the
caller rather than generating code to call the function or access the
static where it is defined.

The compiler automatically inlines functions based on internal
heuristics. Incorrectly inlining functions can actually making the
program slower, so it should be used with care.

Immutable statics are always considered inlineable unless marked with
\texttt{\#{[}inline(never){]}}. It is undefined whether two different
inlineable statics have the same memory address. In other words, the
compiler is free to collapse duplicate inlineable statics together.

\texttt{\#{[}inline{]}} and \texttt{\#{[}inline(always){]}} always
causes the function to be serialized into crate metadata to allow
cross-crate inlining.

There are three different types of inline attributes:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{\#{[}inline{]}} hints the compiler to perform an inline
  expansion.
\item
  \texttt{\#{[}inline(always){]}} asks the compiler to always perform an
  inline expansion.
\item
  \texttt{\#{[}inline(never){]}} asks the compiler to never perform an
  inline expansion.
\end{itemize}

\subsubsection{Deriving}\label{deriving}

The \texttt{deriving} attribute allows certain traits to be
automatically implemented for data structures. For example, the
following will create an \texttt{impl} for the \texttt{PartialEq} and
\texttt{Clone} traits for \texttt{Foo}, the type parameter \texttt{T}
will be given the \texttt{PartialEq} or \texttt{Clone} constraints for
the appropriate \texttt{impl}:

\begin{verbatim}
#[deriving(PartialEq, Clone)]
struct Foo<T> {
    a: int,
    b: T
}
\end{verbatim}

The generated \texttt{impl} for \texttt{PartialEq} is equivalent to

\begin{verbatim}
# struct Foo<T> { a: int, b: T }
impl<T: PartialEq> PartialEq for Foo<T> {
    fn eq(&self, other: &Foo<T>) -> bool {
        self.a == other.a && self.b == other.b
    }

    fn ne(&self, other: &Foo<T>) -> bool {
        self.a != other.a || self.b != other.b
    }
}
\end{verbatim}

Supported traits for \texttt{deriving} are:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Comparison traits: \texttt{PartialEq}, \texttt{Eq},
  \texttt{PartialOrd}, \texttt{Ord}.
\item
  Serialization: \texttt{Encodable}, \texttt{Decodable}. These require
  \texttt{serialize}.
\item
  \texttt{Clone}, to create \texttt{T} from \texttt{\&T} via a copy.
\item
  \texttt{Hash}, to iterate over the bytes in a data type.
\item
  \texttt{Rand}, to create a random instance of a data type.
\item
  \texttt{Default}, to create an empty instance of a data type.
\item
  \texttt{Zero}, to create a zero instance of a numeric data type.
\item
  \texttt{FromPrimitive}, to create an instance from a numeric
  primitive.
\item
  \texttt{Show}, to format a value using the \texttt{\{\}} formatter.
\end{itemize}

\subsubsection{Stability}\label{stability}

One can indicate the stability of an API using the following attributes:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{deprecated}: This item should no longer be used, e.g.~it has
  been replaced. No guarantee of backwards-compatibility.
\item
  \texttt{experimental}: This item was only recently introduced or is
  otherwise in a state of flux. It may change significantly, or even be
  removed. No guarantee of backwards-compatibility.
\item
  \texttt{unstable}: This item is still under development, but requires
  more testing to be considered stable. No guarantee of
  backwards-compatibility.
\item
  \texttt{stable}: This item is considered stable, and will not change
  significantly. Guarantee of backwards-compatibility.
\item
  \texttt{frozen}: This item is very stable, and is unlikely to change.
  Guarantee of backwards-compatibility.
\item
  \texttt{locked}: This item will never change unless a serious bug is
  found. Guarantee of backwards-compatibility.
\end{itemize}

These levels are directly inspired by
\href{http://nodejs.org/api/documentation.html}{Node.js' ``stability
index''}.

Stability levels are inherited, so an items's stability attribute is the
default stability for everything nested underneath it.

There are lints for disallowing items marked with certain levels:
\texttt{deprecated}, \texttt{experimental} and \texttt{unstable}. For
now, only \texttt{deprecated} warns by default, but this will change
once the standard library has been stabilized. Stability levels are
meant to be promises at the crate level, so these lints only apply when
referencing items from an \emph{external} crate, not to items defined
within the current crate. Items with no stability level are considered
to be unstable for the purposes of the lint. One can give an optional
string that will be displayed when the lint flags the use of an item.

For example, if we define one crate called \texttt{stability\_levels}:

\begin{verbatim}
#[deprecated="replaced by `best`"]
pub fn bad() {
    // delete everything
}

pub fn better() {
    // delete fewer things
}

#[stable]
pub fn best() {
    // delete nothing
}
\end{verbatim}

then the lints will work as follows for a client crate:

\begin{verbatim}
#![warn(unstable)]
extern crate stability_levels;
use stability_levels::{bad, better, best};

fn main() {
    bad(); // "warning: use of deprecated item: replaced by `best`"

    better(); // "warning: use of unmarked item"

    best(); // no warning
}
\end{verbatim}

\begin{quote}
\textbf{Note:} Currently these are only checked when applied to
individual functions, structs, methods and enum variants, \emph{not} to
entire modules, traits, impls or enums themselves.
\end{quote}

\hyperdef{}{compiler-features}{\subsubsection{Compiler
Features}\label{compiler-features}}

Certain aspects of Rust may be implemented in the compiler, but they're
not necessarily ready for every-day use. These features are often of
``prototype quality'' or ``almost production ready'', but may not be
stable enough to be considered a full-fledged language feature.

For this reason, Rust recognizes a special crate-level attribute of the
form:

\begin{verbatim}
#![feature(feature1, feature2, feature3)]
\end{verbatim}

This directive informs the compiler that the feature list:
\texttt{feature1}, \texttt{feature2}, and \texttt{feature3} should all
be enabled. This is only recognized at a crate-level, not at a
module-level. Without this directive, all features are considered off,
and using the features will result in a compiler error.

The currently implemented features of the reference compiler are:

\begin{itemize}
\item
  \texttt{macro\_rules} - The definition of new macros. This does not
  encompass macro-invocation, that is always enabled by default, this
  only covers the definition of new macros. There are currently various
  problems with invoking macros, how they interact with their
  environment, and possibly how they are used outside of location in
  which they are defined. Macro definitions are likely to change
  slightly in the future, so they are currently hidden behind this
  feature.
\item
  \texttt{globs} - Importing everything in a module through \texttt{*}.
  This is currently a large source of bugs in name resolution for Rust,
  and it's not clear whether this will continue as a feature or not. For
  these reasons, the glob import statement has been hidden behind this
  feature flag.
\item
  \texttt{struct\_variant} - Structural enum variants (those with named
  fields). It is currently unknown whether this style of enum variant is
  as fully supported as the tuple-forms, and it's not certain that this
  style of variant should remain in the language. For now this style of
  variant is hidden behind a feature flag.
\item
  \texttt{once\_fns} - Onceness guarantees a closure is only executed
  once. Defining a closure as \texttt{once} is unlikely to be supported
  going forward. So they are hidden behind this feature until they are
  to be removed.
\item
  \texttt{managed\_boxes} - Usage of \texttt{@} pointers is gated due to
  many planned changes to this feature. In the past, this has meant ``a
  GC pointer'', but the current implementation uses reference counting
  and will likely change drastically over time. Additionally, the
  \texttt{@} syntax will no longer be used to create GC boxes.
\item
  \texttt{asm} - The \texttt{asm!} macro provides a means for inline
  assembly. This is often useful, but the exact syntax for this feature
  along with its semantics are likely to change, so this macro usage
  must be opted into.
\item
  \texttt{non\_ascii\_idents} - The compiler supports the use of
  non-ascii identifiers, but the implementation is a little rough around
  the edges, so this can be seen as an experimental feature for now
  until the specification of identifiers is fully fleshed out.
\item
  \texttt{thread\_local} - The usage of the
  \texttt{\#{[}thread\_local{]}} attribute is experimental and should be
  seen as unstable. This attribute is used to declare a \texttt{static}
  as being unique per-thread leveraging LLVM's implementation which
  works in concert with the kernel loader and dynamic linker. This is
  not necessarily available on all platforms, and usage of it is
  discouraged (rust focuses more on task-local data instead of
  thread-local data).
\item
  \texttt{link\_args} - This attribute is used to specify custom flags
  to the linker, but usage is strongly discouraged. The compiler's usage
  of the system linker is not guaranteed to continue in the future, and
  if the system linker is not used then specifying custom flags doesn't
  have much meaning.
\end{itemize}

If a feature is promoted to a language feature, then all existing
programs will start to receive compilation warnings about
\#{[}feature{]} directives which enabled the new feature (because the
directive is no longer necessary). However, if a feature is decided to
be removed from the language, errors will be issued (if there isn't a
parser error first). The directive in this case is no longer necessary,
and it's likely that existing code will break if the feature isn't
removed.

If a unknown feature is found in a directive, it results in a compiler
error. An unknown feature is one which has never been recognized by the
compiler.

\section{Statements and expressions}\label{statements-and-expressions}

Rust is \emph{primarily} an expression language. This means that most
forms of value-producing or effect-causing evaluation are directed by
the uniform syntax category of \emph{expressions}. Each kind of
expression can typically \emph{nest} within each other kind of
expression, and rules for evaluation of expressions involve specifying
both the value produced by the expression and the order in which its
sub-expressions are themselves evaluated.

In contrast, statements in Rust serve \emph{mostly} to contain and
explicitly sequence expression evaluation.

\hyperdef{}{statements}{\subsection{Statements}\label{statements}}

A \emph{statement} is a component of a block, which is in turn a
component of an outer \hyperref[expressions]{expression} or
\hyperref[functions]{function}.

Rust has two kinds of statement:
\hyperref[declaration-statements]{declaration statements} and
\hyperref[expression-statements]{expression statements}.

\hyperdef{}{declaration-statements}{\subsubsection{Declaration
statements}\label{declaration-statements}}

A \emph{declaration statement} is one that introduces one or more
\emph{names} into the enclosing statement block. The declared names may
denote new slots or new items.

\paragraph{Item declarations}\label{item-declarations}

An \emph{item declaration statement} has a syntactic form identical to
an \hyperref[items]{item} declaration within a module. Declaring an item
--- a function, enumeration, structure, type, static, trait,
implementation or module --- locally within a statement block is simply
a way of restricting its scope to a narrow region containing all of its
uses; it is otherwise identical in meaning to declaring the item outside
the statement block.

Note: there is no implicit capture of the function's dynamic environment
when declaring a function-local item.

\paragraph{Slot declarations}\label{slot-declarations}

\begin{verbatim}
let_decl : "let" pat [':' type ] ? [ init ] ? ';' ;
init : [ '=' ] expr ;
\end{verbatim}

A \emph{slot declaration} introduces a new set of slots, given by a
pattern. The pattern may be followed by a type annotation, and/or an
initializer expression. When no type annotation is given, the compiler
will infer the type, or signal an error if insufficient type information
is available for definite inference. Any slots introduced by a slot
declaration are visible from the point of declaration until the end of
the enclosing block scope.

\hyperdef{}{expression-statements}{\subsubsection{Expression
statements}\label{expression-statements}}

An \emph{expression statement} is one that evaluates an
\hyperref[expressions]{expression} and ignores its result. The type of
an expression statement \texttt{e;} is always \texttt{()}, regardless of
the type of \texttt{e}. As a rule, an expression statement's purpose is
to trigger the effects of evaluating its expression.

\hyperdef{}{expressions}{\subsection{Expressions}\label{expressions}}

An expression may have two roles: it always produces a \emph{value}, and
it may have \emph{effects} (otherwise known as ``side effects''). An
expression \emph{evaluates to} a value, and has effects during
\emph{evaluation}. Many expressions contain sub-expressions (operands).
The meaning of each kind of expression dictates several things: *
Whether or not to evaluate the sub-expressions when evaluating the
expression * The order in which to evaluate the sub-expressions * How to
combine the sub-expressions' values to obtain the value of the
expression.

In this way, the structure of expressions dictates the structure of
execution. Blocks are just another kind of expression, so blocks,
statements, expressions, and blocks again can recursively nest inside
each other to an arbitrary depth.

\hyperdef{}{lvalues-rvalues-and-temporaries}{\paragraph{Lvalues, rvalues
and temporaries}\label{lvalues-rvalues-and-temporaries}}

Expressions are divided into two main categories: \emph{lvalues} and
\emph{rvalues}. Likewise within each expression, sub-expressions may
occur in \emph{lvalue context} or \emph{rvalue context}. The evaluation
of an expression depends both on its own category and the context it
occurs within.

An lvalue is an expression that represents a memory location. These
expressions are \hyperref[path-expressions]{paths} (which refer to local
variables, function and method arguments, or static variables),
dereferences (\texttt{*expr}), \hyperref[index-expressions]{indexing
expressions} (\texttt{expr{[}expr{]}}), and
\hyperref[field-expressions]{field references} (\texttt{expr.f}). All
other expressions are rvalues.

The left operand of an \hyperref[assignment-expressions]{assignment} or
\hyperref[compound-assignment-expressions]{compound-assignment}
expression is an lvalue context, as is the single operand of a unary
\hyperref[unary-operator-expressions]{borrow}. All other expression
contexts are rvalue contexts.

When an lvalue is evaluated in an \emph{lvalue context}, it denotes a
memory location; when evaluated in an \emph{rvalue context}, it denotes
the value held \emph{in} that memory location.

When an rvalue is used in lvalue context, a temporary un-named lvalue is
created and used instead. A temporary's lifetime equals the largest
lifetime of any reference that points to it.

\hyperdef{}{moved-and-copied-types}{\paragraph{Moved and copied
types}\label{moved-and-copied-types}}

When a \hyperref[memory-slots]{local variable} is used as an
\hyperref[lvalues-rvalues-and-temporaries]{rvalue} the variable will
either be moved or copied, depending on its type. For types that contain
\hyperref[pointer-types]{owning pointers} or values that implement the
special trait \texttt{Drop}, the variable is moved. All other types are
copied.

\subsubsection{Literal expressions}\label{literal-expressions}

A \emph{literal expression} consists of one of the
\hyperref[literals]{literal} forms described earlier. It directly
describes a number, character, string, boolean value, or the unit value.

\begin{verbatim}
();        // unit type
"hello";   // string type
'5';       // character type
5;         // integer type
\end{verbatim}

\hyperdef{}{path-expressions}{\subsubsection{Path
expressions}\label{path-expressions}}

A \hyperref[paths]{path} used as an expression context denotes either a
local variable or an item. Path expressions are
\hyperref[lvalues-rvalues-and-temporaries]{lvalues}.

\subsubsection{Tuple expressions}\label{tuple-expressions}

Tuples are written by enclosing one or more comma-separated expressions
in parentheses. They are used to create
\hyperref[tuple-types]{tuple-typed} values.

\begin{verbatim}
(0,);
(0.0, 4.5);
("a", 4u, true);
\end{verbatim}

\hyperdef{}{structure-expressions}{\subsubsection{Structure
expressions}\label{structure-expressions}}

\begin{verbatim}
struct_expr : expr_path '{' ident ':' expr
                      [ ',' ident ':' expr ] *
                      [ ".." expr ] '}' |
              expr_path '(' expr
                      [ ',' expr ] * ')' |
              expr_path ;
\end{verbatim}

There are several forms of structure expressions. A \emph{structure
expression} consists of the \hyperref[paths]{path} of a
\hyperref[structures]{structure item}, followed by a brace-enclosed list
of one or more comma-separated name-value pairs, providing the field
values of a new instance of the structure. A field name can be any
identifier, and is separated from its value expression by a colon. The
location denoted by a structure field is mutable if and only if the
enclosing structure is mutable.

A \emph{tuple structure expression} consists of the
\hyperref[paths]{path} of a \hyperref[structures]{structure item},
followed by a parenthesized list of one or more comma-separated
expressions (in other words, the path of a structure item followed by a
tuple expression). The structure item must be a tuple structure item.

A \emph{unit-like structure expression} consists only of the
\hyperref[paths]{path} of a \hyperref[structures]{structure item}.

The following are examples of structure expressions:

\begin{verbatim}
# struct Point { x: f64, y: f64 }
# struct TuplePoint(f64, f64);
# mod game { pub struct User<'a> { pub name: &'a str, pub age: uint, pub score: uint } }
# struct Cookie; fn some_fn<T>(t: T) {}
Point {x: 10.0, y: 20.0};
TuplePoint(10.0, 20.0);
let u = game::User {name: "Joe", age: 35, score: 100_000};
some_fn::<Cookie>(Cookie);
\end{verbatim}

A structure expression forms a new value of the named structure type.
Note that for a given \emph{unit-like} structure type, this will always
be the same value.

A structure expression can terminate with the syntax \texttt{..}
followed by an expression to denote a functional update. The expression
following \texttt{..} (the base) must have the same structure type as
the new structure type being formed. The entire expression denotes the
result of constructing a new structure (with the same type as the base
expression) with the given values for the fields that were explicitly
specified and the values in the base expression for all other fields.

\begin{verbatim}
# struct Point3d { x: int, y: int, z: int }
let base = Point3d {x: 1, y: 2, z: 3};
Point3d {y: 0, z: 10, .. base};
\end{verbatim}

\subsubsection{Block expressions}\label{block-expressions}

\begin{verbatim}
block_expr : '{' [ view_item ] *
                 [ stmt ';' | item ] *
                 [ expr ] '}' ;
\end{verbatim}

A \emph{block expression} is similar to a module in terms of the
declarations that are possible. Each block conceptually introduces a new
namespace scope. View items can bring new names into scopes and declared
items are in scope for only the block itself.

A block will execute each statement sequentially, and then execute the
expression (if given). If the final expression is omitted, the type and
return value of the block are \texttt{()}, but if it is provided, the
type and return value of the block are that of the expression itself.

\hyperdef{}{method-call-expressions}{\subsubsection{Method-call
expressions}\label{method-call-expressions}}

\begin{verbatim}
method_call_expr : expr '.' ident paren_expr_list ;
\end{verbatim}

A \emph{method call} consists of an expression followed by a single dot,
an identifier, and a parenthesized expression-list. Method calls are
resolved to methods on specific traits, either statically dispatching to
a method if the exact \texttt{self}-type of the left-hand-side is known,
or dynamically dispatching if the left-hand-side expression is an
indirect \hyperref[object-types]{object type}.

\hyperdef{}{field-expressions}{\subsubsection{Field
expressions}\label{field-expressions}}

\begin{verbatim}
field_expr : expr '.' ident ;
\end{verbatim}

A \emph{field expression} consists of an expression followed by a single
dot and an identifier, when not immediately followed by a parenthesized
expression-list (the latter is a
\hyperref[method-call-expressions]{method call expression}). A field
expression denotes a field of a \hyperref[structure-types]{structure}.

\begin{verbatim}
mystruct.myfield;
foo().x;
(Struct {a: 10, b: 20}).a;
\end{verbatim}

A field access is an \hyperref[lvalues-rvalues-and-temporaries]{lvalue}
referring to the value of that field. When the type providing the field
inherits mutabilty, it can be
\hyperref[assignment-expressions]{assigned} to.

Also, if the type of the expression to the left of the dot is a pointer,
it is automatically dereferenced to make the field access possible.

\subsubsection{Vector expressions}\label{vector-expressions}

\begin{verbatim}
vec_expr : '[' "mut" ? vec_elems? ']' ;

vec_elems : [expr [',' expr]*] | [expr ',' ".." expr] ;
\end{verbatim}

A \hyperref[vector-types]{\emph{vector}} \emph{expression} is written by
enclosing zero or more comma-separated expressions of uniform type in
square brackets.

In the \texttt{{[}expr ',' ".." expr{]}} form, the expression after the
\texttt{".."} must be a constant expression that can be evaluated at
compile time, such as a \hyperref[literals]{literal} or a
\hyperref[static-items]{static item}.

\begin{verbatim}
[1i, 2, 3, 4];
["a", "b", "c", "d"];
[0i, ..128];             // vector with 128 zeros
[0u8, 0u8, 0u8, 0u8];
\end{verbatim}

\hyperdef{}{index-expressions}{\subsubsection{Index
expressions}\label{index-expressions}}

\begin{verbatim}
idx_expr : expr '[' expr ']' ;
\end{verbatim}

\hyperref[vector-types]{Vector}-typed expressions can be indexed by
writing a square-bracket-enclosed expression (the index) after them.
When the vector is mutable, the resulting
\hyperref[lvalues-rvalues-and-temporaries]{lvalue} can be assigned to.

Indices are zero-based, and may be of any integral type. Vector access
is bounds-checked at run-time. When the check fails, it will put the
task in a \emph{failing state}.

\begin{verbatim}
# use std::task;
# task::spawn(proc() {

([1, 2, 3, 4])[0];
(["a", "b"])[10]; // fails

# })
\end{verbatim}

\hyperdef{}{unary-operator-expressions}{\subsubsection{Unary operator
expressions}\label{unary-operator-expressions}}

Rust defines six symbolic unary operators. They are all written as
prefix operators, before the expression they apply to.

\begin{itemize}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{-}]
  Negation. May only be applied to numeric types.
  \end{description}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{*}]
  Dereference. When applied to a \hyperref[pointer-types]{pointer} it
  denotes the pointed-to location.
  \end{description}

  For pointers to mutable locations, the resulting
  \hyperref[lvalues-rvalues-and-temporaries]{lvalue} can be assigned to.
  On non-pointer types, it calls the \texttt{deref} method of the
  \texttt{std::ops::Deref} trait, or the \texttt{deref\_mut} method of
  the \texttt{std::ops::DerefMut} trait (if implemented by the type and
  required for an outer expression that will or could mutate the
  dereference), and produces the result of dereferencing the \texttt{\&}
  or \texttt{\&mut} borrowed pointer returned from the overload method.
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{!}]
  Logical negation. On the boolean type, this flips between
  \texttt{true} and
  \end{description}

  \texttt{false}. On integer types, this inverts the individual bits in
  the two's complement representation of the value.
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{box}]
  \hyperref[pointer-types]{Boxing} operators. Allocate a box to hold the
  value they are applied to,
  \end{description}

  and store the value in it. \texttt{box} creates an owned box.
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{\&}]
  Borrow operator. Returns a reference, pointing to its operand.
  \end{description}

  The operand of a borrow is statically proven to outlive the resulting
  pointer. If the borrow-checker cannot prove this, it is a compilation
  error.
\end{itemize}

\hyperdef{}{binary-operator-expressions}{\subsubsection{Binary operator
expressions}\label{binary-operator-expressions}}

\begin{verbatim}
binop_expr : expr binop expr ;
\end{verbatim}

Binary operators expressions are given in terms of
\hyperref[operator-precedence]{operator precedence}.

\hyperdef{}{arithmetic-operators}{\paragraph{Arithmetic
operators}\label{arithmetic-operators}}

Binary arithmetic expressions are syntactic sugar for calls to built-in
traits, defined in the \texttt{std::ops} module of the \texttt{std}
library. This means that arithmetic operators can be overridden for
user-defined types. The default meaning of the operators on standard
types is given here.

\begin{itemize}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{+}]
  Addition and vector/string concatenation.
  \end{description}

  Calls the \texttt{add} method on the \texttt{std::ops::Add} trait.
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{-}]
  Subtraction.
  \end{description}

  Calls the \texttt{sub} method on the \texttt{std::ops::Sub} trait.
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{*}]
  Multiplication.
  \end{description}

  Calls the \texttt{mul} method on the \texttt{std::ops::Mul} trait.
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{/}]
  Quotient.
  \end{description}

  Calls the \texttt{div} method on the \texttt{std::ops::Div} trait.
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{\%}]
  Remainder.
  \end{description}

  Calls the \texttt{rem} method on the \texttt{std::ops::Rem} trait.
\end{itemize}

\hyperdef{}{bitwise-operators}{\paragraph{Bitwise
operators}\label{bitwise-operators}}

Like the \hyperref[arithmetic-operators]{arithmetic operators}, bitwise
operators are syntactic sugar for calls to methods of built-in traits.
This means that bitwise operators can be overridden for user-defined
types. The default meaning of the operators on standard types is given
here.

\begin{itemize}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{\&}]
  And.
  \end{description}

  Calls the \texttt{bitand} method of the \texttt{std::ops::BitAnd}
  trait.
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{\textbar{}}]
  Inclusive or.
  \end{description}

  Calls the \texttt{bitor} method of the \texttt{std::ops::BitOr} trait.
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{\^{}}]
  Exclusive or.
  \end{description}

  Calls the \texttt{bitxor} method of the \texttt{std::ops::BitXor}
  trait.
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{\textless{}\textless{}}]
  Logical left shift.
  \end{description}

  Calls the \texttt{shl} method of the \texttt{std::ops::Shl} trait.
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{\textgreater{}\textgreater{}}]
  Logical right shift.
  \end{description}

  Calls the \texttt{shr} method of the \texttt{std::ops::Shr} trait.
\end{itemize}

\paragraph{Lazy boolean operators}\label{lazy-boolean-operators}

The operators \texttt{\textbar{}\textbar{}} and \texttt{\&\&} may be
applied to operands of boolean type. The \texttt{\textbar{}\textbar{}}
operator denotes logical `or', and the \texttt{\&\&} operator denotes
logical `and'. They differ from \texttt{\textbar{}} and \texttt{\&} in
that the right-hand operand is only evaluated when the left-hand operand
does not already determine the result of the expression. That is,
\texttt{\textbar{}\textbar{}} only evaluates its right-hand operand when
the left-hand operand evaluates to \texttt{false}, and \texttt{\&\&}
only when it evaluates to \texttt{true}.

\paragraph{Comparison operators}\label{comparison-operators}

Comparison operators are, like the
\hyperref[arithmetic-operators]{arithmetic operators}, and
\hyperref[bitwise-operators]{bitwise operators}, syntactic sugar for
calls to built-in traits. This means that comparison operators can be
overridden for user-defined types. The default meaning of the operators
on standard types is given here.

\begin{itemize}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{==}]
  Equal to.
  \end{description}

  Calls the \texttt{eq} method on the \texttt{std::cmp::PartialEq}
  trait.
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{!=}]
  Unequal to.
  \end{description}

  Calls the \texttt{ne} method on the \texttt{std::cmp::PartialEq}
  trait.
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{\textless{}}]
  Less than.
  \end{description}

  Calls the \texttt{lt} method on the \texttt{std::cmp::PartialOrd}
  trait.
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{\textgreater{}}]
  Greater than.
  \end{description}

  Calls the \texttt{gt} method on the \texttt{std::cmp::PartialOrd}
  trait.
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{\textless{}=}]
  Less than or equal.
  \end{description}

  Calls the \texttt{le} method on the \texttt{std::cmp::PartialOrd}
  trait.
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{\textgreater{}=}]
  Greater than or equal.
  \end{description}

  Calls the \texttt{ge} method on the \texttt{std::cmp::PartialOrd}
  trait.
\end{itemize}

\hyperdef{}{type-cast-expressions}{\paragraph{Type cast
expressions}\label{type-cast-expressions}}

A type cast expression is denoted with the binary operator \texttt{as}.

Executing an \texttt{as} expression casts the value on the left-hand
side to the type on the right-hand side.

A numeric value can be cast to any numeric type. A raw pointer value can
be cast to or from any integral type or raw pointer type. Any other cast
is unsupported and will fail to compile.

An example of an \texttt{as} expression:

\begin{verbatim}
# fn sum(v: &[f64]) -> f64 { 0.0 }
# fn len(v: &[f64]) -> int { 0 }

fn avg(v: &[f64]) -> f64 {
  let sum: f64 = sum(v);
  let sz: f64 = len(v) as f64;
  return sum / sz;
}
\end{verbatim}

\hyperdef{}{assignment-expressions}{\paragraph{Assignment
expressions}\label{assignment-expressions}}

An \emph{assignment expression} consists of an
\hyperref[lvalues-rvalues-and-temporaries]{lvalue} expression followed
by an equals sign (\texttt{=}) and an
\hyperref[lvalues-rvalues-and-temporaries]{rvalue} expression.

Evaluating an assignment expression
\hyperref[moved-and-copied-types]{either copies or moves} its right-hand
operand to its left-hand operand.

\begin{verbatim}
# let mut x = 0i;
# let y = 0;

x = y;
\end{verbatim}

\hyperdef{}{compound-assignment-expressions}{\paragraph{Compound
assignment expressions}\label{compound-assignment-expressions}}

The \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, \texttt{\%},
\texttt{\&}, \texttt{\textbar{}}, \texttt{\^{}},
\texttt{\textless{}\textless{}}, and
\texttt{\textgreater{}\textgreater{}} operators may be composed with the
\texttt{=} operator. The expression \texttt{lval OP= val} is equivalent
to \texttt{lval = lval OP val}. For example, \texttt{x = x + 1} may be
written as \texttt{x += 1}.

Any such expression always has the
\hyperref[primitive-types]{\texttt{unit}} type.

\hyperdef{}{operator-precedence}{\paragraph{Operator
precedence}\label{operator-precedence}}

The precedence of Rust binary operators is ordered as follows, going
from strong to weak:

\begin{verbatim}
* / %
as
+ -
<< >>
&
^
|
< > <= >=
== !=
&&
||
=
\end{verbatim}

Operators at the same precedence level are evaluated left-to-right.
\hyperref[unary-operator-expressions]{Unary operators} have the same
precedence level and it is stronger than any of the binary operators'.

\subsubsection{Grouped expressions}\label{grouped-expressions}

An expression enclosed in parentheses evaluates to the result of the
enclosed expression. Parentheses can be used to explicitly specify
evaluation order within an expression.

\begin{verbatim}
paren_expr : '(' expr ')' ;
\end{verbatim}

An example of a parenthesized expression:

\begin{verbatim}
let x: int = (2 + 3) * 4;
\end{verbatim}

\hyperdef{}{call-expressions}{\subsubsection{Call
expressions}\label{call-expressions}}

\begin{verbatim}
expr_list : [ expr [ ',' expr ]* ] ? ;
paren_expr_list : '(' expr_list ')' ;
call_expr : expr paren_expr_list ;
\end{verbatim}

A \emph{call expression} invokes a function, providing zero or more
input slots and an optional reference slot to serve as the function's
output, bound to the \texttt{lval} on the right hand side of the call.
If the function eventually returns, then the expression completes.

Some examples of call expressions:

\begin{verbatim}
# use std::from_str::FromStr;
# fn add(x: int, y: int) -> int { 0 }

let x: int = add(1, 2);
let pi: Option<f32> = FromStr::from_str("3.14");
\end{verbatim}

\subsubsection{Lambda expressions}\label{lambda-expressions}

\begin{verbatim}
ident_list : [ ident [ ',' ident ]* ] ? ;
lambda_expr : '|' ident_list '|' expr ;
\end{verbatim}

A \emph{lambda expression} (sometimes called an ``anonymous function
expression'') defines a function and denotes it as a value, in a single
expression. A lambda expression is a pipe-symbol-delimited
(\texttt{\textbar{}}) list of identifiers followed by an expression.

A lambda expression denotes a function that maps a list of parameters
(\texttt{ident\_list}) onto the expression that follows the
\texttt{ident\_list}. The identifiers in the \texttt{ident\_list} are
the parameters to the function. These parameters' types need not be
specified, as the compiler infers them from context.

Lambda expressions are most useful when passing functions as arguments
to other functions, as an abbreviation for defining and capturing a
separate function.

Significantly, lambda expressions \emph{capture their environment},
which regular \hyperref[functions]{function definitions} do not. The
exact type of capture depends on the \hyperref[function-types]{function
type} inferred for the lambda expression. In the simplest and
least-expensive form (analogous to a \texttt{\textbar{}\textbar{} \{ \}}
expression), the lambda expression captures its environment by
reference, effectively borrowing pointers to all outer variables
mentioned inside the function. Alternately, the compiler may infer that
a lambda expression should copy or move values (depending on their
type.) from the environment into the lambda expression's captured
environment.

In this example, we define a function \texttt{ten\_times} that takes a
higher-order function argument, and call it with a lambda expression as
an argument.

\begin{verbatim}
fn ten_times(f: |int|) {
    let mut i = 0;
    while i < 10 {
        f(i);
        i += 1;
    }
}

ten_times(|j| println!("hello, {}", j));
\end{verbatim}

\subsubsection{While loops}\label{while-loops}

\begin{verbatim}
while_expr : "while" no_struct_literal_expr '{' block '}' ;
\end{verbatim}

A \texttt{while} loop begins by evaluating the boolean loop conditional
expression. If the loop conditional expression evaluates to
\texttt{true}, the loop body block executes and control returns to the
loop conditional expression. If the loop conditional expression
evaluates to \texttt{false}, the \texttt{while} expression completes.

An example:

\begin{verbatim}
let mut i = 0u;

while i < 10 {
    println!("hello");
    i = i + 1;
}
\end{verbatim}

\subsubsection{Infinite loops}\label{infinite-loops}

A \texttt{loop} expression denotes an infinite loop.

\begin{verbatim}
loop_expr : [ lifetime ':' ] "loop" '{' block '}';
\end{verbatim}

A \texttt{loop} expression may optionally have a \emph{label}. If a
label is present, then labeled \texttt{break} and \texttt{continue}
expressions nested within this loop may exit out of this loop or return
control to its head. See \hyperref[break-expressions]{Break expressions}
and \hyperref[continue-expressions]{Continue expressions}.

\hyperdef{}{break-expressions}{\subsubsection{Break
expressions}\label{break-expressions}}

\begin{verbatim}
break_expr : "break" [ lifetime ];
\end{verbatim}

A \texttt{break} expression has an optional \emph{label}. If the label
is absent, then executing a \texttt{break} expression immediately
terminates the innermost loop enclosing it. It is only permitted in the
body of a loop. If the label is present, then \texttt{break foo}
terminates the loop with label \texttt{foo}, which need not be the
innermost label enclosing the \texttt{break} expression, but must
enclose it.

\hyperdef{}{continue-expressions}{\subsubsection{Continue
expressions}\label{continue-expressions}}

\begin{verbatim}
continue_expr : "continue" [ lifetime ];
\end{verbatim}

A \texttt{continue} expression has an optional \emph{label}. If the
label is absent, then executing a \texttt{continue} expression
immediately terminates the current iteration of the innermost loop
enclosing it, returning control to the loop \emph{head}. In the case of
a \texttt{while} loop, the head is the conditional expression
controlling the loop. In the case of a \texttt{for} loop, the head is
the call-expression controlling the loop. If the label is present, then
\texttt{continue foo} returns control to the head of the loop with label
\texttt{foo}, which need not be the innermost label enclosing the
\texttt{break} expression, but must enclose it.

A \texttt{continue} expression is only permitted in the body of a loop.

\subsubsection{For expressions}\label{for-expressions}

\begin{verbatim}
for_expr : "for" pat "in" no_struct_literal_expr '{' block '}' ;
\end{verbatim}

A \texttt{for} expression is a syntactic construct for looping over
elements provided by an implementation of \texttt{std::iter::Iterator}.

An example of a for loop over the contents of a vector:

\begin{verbatim}
# type Foo = int;
# fn bar(f: Foo) { }
# let a = 0;
# let b = 0;
# let c = 0;

let v: &[Foo] = &[a, b, c];

for e in v.iter() {
    bar(*e);
}
\end{verbatim}

An example of a for loop over a series of integers:

\begin{verbatim}
# fn bar(b:uint) { }
for i in range(0u, 256) {
    bar(i);
}
\end{verbatim}

\subsubsection{If expressions}\label{if-expressions}

\begin{verbatim}
if_expr : "if" no_struct_literal_expr '{' block '}'
          else_tail ? ;

else_tail : "else" [ if_expr
                   | '{' block '}' ] ;
\end{verbatim}

An \texttt{if} expression is a conditional branch in program control.
The form of an \texttt{if} expression is a condition expression,
followed by a consequent block, any number of \texttt{else if}
conditions and blocks, and an optional trailing \texttt{else} block. The
condition expressions must have type \texttt{bool}. If a condition
expression evaluates to \texttt{true}, the consequent block is executed
and any subsequent \texttt{else if} or \texttt{else} block is skipped.
If a condition expression evaluates to \texttt{false}, the consequent
block is skipped and any subsequent \texttt{else if} condition is
evaluated. If all \texttt{if} and \texttt{else if} conditions evaluate
to \texttt{false} then any \texttt{else} block is executed.

\subsubsection{Match expressions}\label{match-expressions}

\begin{verbatim}
match_expr : "match" no_struct_literal_expr '{' match_arm * '}' ;

match_arm : attribute * match_pat "=>" [ expr "," | '{' block '}' ] ;

match_pat : pat [ '|' pat ] * [ "if" expr ] ? ;
\end{verbatim}

A \texttt{match} expression branches on a \emph{pattern}. The exact form
of matching that occurs depends on the pattern. Patterns consist of some
combination of literals, destructured vectors or enum constructors,
structures and tuples, variable binding specifications, wildcards
(\texttt{..}), and placeholders (\texttt{\_}). A \texttt{match}
expression has a \emph{head expression}, which is the value to compare
to the patterns. The type of the patterns must equal the type of the
head expression.

In a pattern whose head expression has an \texttt{enum} type, a
placeholder (\texttt{\_}) stands for a \emph{single} data field, whereas
a wildcard \texttt{..} stands for \emph{all} the fields of a particular
variant. For example:

\begin{verbatim}
enum List<X> { Nil, Cons(X, Box<List<X>>) }

let x: List<int> = Cons(10, box Cons(11, box Nil));

match x {
    Cons(_, box Nil) => fail!("singleton list"),
    Cons(..)         => return,
    Nil              => fail!("empty list")
}
\end{verbatim}

The first pattern matches lists constructed by applying \texttt{Cons} to
any head value, and a tail value of \texttt{box Nil}. The second pattern
matches \emph{any} list constructed with \texttt{Cons}, ignoring the
values of its arguments. The difference between \texttt{\_} and
\texttt{..} is that the pattern \texttt{C(\_)} is only type-correct if
\texttt{C} has exactly one argument, while the pattern \texttt{C(..)} is
type-correct for any enum variant \texttt{C}, regardless of how many
arguments \texttt{C} has.

Used inside a vector pattern, \texttt{..} stands for any number of
elements. This wildcard can be used at most once for a given vector,
which implies that it cannot be used to specifically match elements that
are at an unknown distance from both ends of a vector, like
\texttt{{[}.., 42, ..{]}}. If followed by a variable name, it will bind
the corresponding slice to the variable. Example:

\begin{verbatim}
fn is_symmetric(list: &[uint]) -> bool {
    match list {
        [] | [_]                   => true,
        [x, ..inside, y] if x == y => is_symmetric(inside),
        _                          => false
    }
}

fn main() {
    let sym     = &[0, 1, 4, 2, 4, 1, 0];
    let not_sym = &[0, 1, 7, 2, 4, 1, 0];
    assert!(is_symmetric(sym));
    assert!(!is_symmetric(not_sym));
}
\end{verbatim}

A \texttt{match} behaves differently depending on whether or not the
head expression is an \hyperref[lvalues-rvalues-and-temporaries]{lvalue
or an rvalue}. If the head expression is an rvalue, it is first
evaluated into a temporary location, and the resulting value is
sequentially compared to the patterns in the arms until a match is
found. The first arm with a matching pattern is chosen as the branch
target of the \texttt{match}, any variables bound by the pattern are
assigned to local variables in the arm's block, and control enters the
block.

When the head expression is an lvalue, the match does not allocate a
temporary location (however, a by-value binding may copy or move from
the lvalue). When possible, it is preferable to match on lvalues, as the
lifetime of these matches inherits the lifetime of the lvalue, rather
than being restricted to the inside of the match.

An example of a \texttt{match} expression:

\begin{verbatim}
# fn process_pair(a: int, b: int) { }
# fn process_ten() { }

enum List<X> { Nil, Cons(X, Box<List<X>>) }

let x: List<int> = Cons(10, box Cons(11, box Nil));

match x {
    Cons(a, box Cons(b, _)) => {
        process_pair(a, b);
    }
    Cons(10, _) => {
        process_ten();
    }
    Nil => {
        return;
    }
    _ => {
        fail!();
    }
}
\end{verbatim}

Patterns that bind variables default to binding to a copy or move of the
matched value (depending on the matched value's type). This can be
changed to bind to a reference by using the \texttt{ref} keyword, or to
a mutable reference using \texttt{ref mut}.

Subpatterns can also be bound to variables by the use of the syntax
\texttt{variable @ subpattern}. For example:

\begin{verbatim}
enum List { Nil, Cons(uint, Box<List>) }

fn is_sorted(list: &List) -> bool {
    match *list {
        Nil | Cons(_, box Nil) => true,
        Cons(x, ref r @ box Cons(y, _)) => (x <= y) && is_sorted(*r)
    }
}

fn main() {
    let a = Cons(6, box Cons(7, box Cons(42, box Nil)));
    assert!(is_sorted(&a));
}
\end{verbatim}

Patterns can also dereference pointers by using the \texttt{\&},
\texttt{box} or \texttt{@} symbols, as appropriate. For example, these
two matches on \texttt{x: \&int} are equivalent:

\begin{verbatim}
# let x = &3i;
let y = match *x { 0 => "zero", _ => "some" };
let z = match x { &0 => "zero", _ => "some" };

assert_eq!(y, z);
\end{verbatim}

A pattern that's just an identifier, like \texttt{Nil} in the previous
example, could either refer to an enum variant that's in scope, or bind
a new variable. The compiler resolves this ambiguity by forbidding
variable bindings that occur in \texttt{match} patterns from shadowing
names of variants that are in scope. For example, wherever \texttt{List}
is in scope, a \texttt{match} pattern would not be able to bind
\texttt{Nil} as a new name. The compiler interprets a variable pattern
\texttt{x} as a binding \emph{only} if there is no variant named
\texttt{x} in scope. A convention you can use to avoid conflicts is
simply to name variants with upper-case letters, and local variables
with lower-case letters.

Multiple match patterns may be joined with the \texttt{\textbar{}}
operator. A range of values may be specified with \texttt{..}. For
example:

\begin{verbatim}
# let x = 2i;

let message = match x {
  0 | 1  => "not many",
  2 .. 9 => "a few",
  _      => "lots"
};
\end{verbatim}

Range patterns only work on scalar types (like integers and characters;
not like vectors and structs, which have sub-components). A range
pattern may not be a sub-range of another range pattern inside the same
\texttt{match}.

Finally, match patterns can accept \emph{pattern guards} to further
refine the criteria for matching a case. Pattern guards appear after the
pattern and consist of a bool-typed expression following the \texttt{if}
keyword. A pattern guard may refer to the variables bound within the
pattern they follow.

\begin{verbatim}
# let maybe_digit = Some(0);
# fn process_digit(i: int) { }
# fn process_other(i: int) { }

let message = match maybe_digit {
  Some(x) if x < 10 => process_digit(x),
  Some(x) => process_other(x),
  None => fail!()
};
\end{verbatim}

\hyperdef{}{return-expressions}{\subsubsection{Return
expressions}\label{return-expressions}}

\begin{verbatim}
return_expr : "return" expr ? ;
\end{verbatim}

Return expressions are denoted with the keyword \texttt{return}.
Evaluating a \texttt{return} expression moves its argument into the
output slot of the current function, destroys the current function
activation frame, and transfers control to the caller frame.

An example of a \texttt{return} expression:

\begin{verbatim}
fn max(a: int, b: int) -> int {
   if a > b {
      return a;
   }
   return b;
}
\end{verbatim}

\section{Type system}\label{type-system}

\subsection{Types}\label{types-1}

Every slot, item and value in a Rust program has a type. The \emph{type}
of a \emph{value} defines the interpretation of the memory holding it.

Built-in types and type-constructors are tightly integrated into the
language, in nontrivial ways that are not possible to emulate in
user-defined types. User-defined types have limited capabilities.

\hyperdef{}{primitive-types}{\subsubsection{Primitive
types}\label{primitive-types}}

The primitive types are the following:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  The ``unit'' type \texttt{()}, having the single ``unit'' value
  \texttt{()} (occasionally called ``nil''). \footnote{The ``unit''
    value \texttt{()} is \emph{not} a sentinel ``null pointer'' value
    for reference slots; the ``unit'' type is the implicit return type
    from functions otherwise lacking a return type, and can be used in
    other contexts (such as message-sending or type-parametric code) as
    a zero-size type.{]}}
\item
  The boolean type \texttt{bool} with values \texttt{true} and
  \texttt{false}.
\item
  The machine types.
\item
  The machine-dependent integer and floating-point types.
\end{itemize}

\paragraph{Machine types}\label{machine-types}

The machine types are the following:

\begin{itemize}
\item
  The unsigned word types \texttt{u8}, \texttt{u16}, \texttt{u32} and
  \texttt{u64}, with values drawn from the integer intervals {[}0,
  2\^{}8 - 1{]}, {[}0, 2\^{}16 - 1{]}, {[}0, 2\^{}32 - 1{]} and {[}0,
  2\^{}64 - 1{]} respectively.
\item
  The signed two's complement word types \texttt{i8}, \texttt{i16},
  \texttt{i32} and \texttt{i64}, with values drawn from the integer
  intervals {[}-(2\^{}(7)), 2\^{}7 - 1{]}, {[}-(2\^{}(15)), 2\^{}15 -
  1{]}, {[}-(2\^{}(31)), 2\^{}31 - 1{]}, {[}-(2\^{}(63)), 2\^{}63 - 1{]}
  respectively.
\item
  The IEEE 754-2008 \texttt{binary32} and \texttt{binary64}
  floating-point types: \texttt{f32} and \texttt{f64}, respectively.
\end{itemize}

\paragraph{Machine-dependent integer
types}\label{machine-dependent-integer-types}

The Rust type \texttt{uint} \footnote{A Rust \texttt{uint} is analogous
  to a C99 \texttt{uintptr\_t}.} is an unsigned integer type with
target-machine-dependent size. Its size, in bits, is equal to the number
of bits required to hold any memory address on the target machine.

The Rust type \texttt{int} \footnote{A Rust \texttt{int} is analogous to
  a C99 \texttt{intptr\_t}.} is a two's complement signed integer type
with target-machine-dependent size. Its size, in bits, is equal to the
size of the rust type \texttt{uint} on the same target machine.

\subsubsection{Textual types}\label{textual-types}

The types \texttt{char} and \texttt{str} hold textual data.

A value of type \texttt{char} is a
\href{http://www.unicode.org/glossary/\#unicode_scalar_value}{Unicode
scalar value} (ie. a code point that is not a surrogate), represented as
a 32-bit unsigned word in the 0x0000 to 0xD7FF or 0xE000 to 0x10FFFF
range. A \texttt{{[}char{]}} vector is effectively an UCS-4 / UTF-32
string.

A value of type \texttt{str} is a Unicode string, represented as a
vector of 8-bit unsigned bytes holding a sequence of UTF-8 codepoints.
Since \texttt{str} is of unknown size, it is not a \emph{first class}
type, but can only be instantiated through a pointer type, such as
\texttt{\&str} or \texttt{String}.

\hyperdef{}{tuple-types}{\subsubsection{Tuple types}\label{tuple-types}}

A tuple \emph{type} is a heterogeneous product of other types, called
the \emph{elements} of the tuple. It has no nominal name and is instead
structurally typed.

Tuple types and values are denoted by listing the types or values of
their elements, respectively, in a parenthesized, comma-separated list.

Because tuple elements don't have a name, they can only be accessed by
pattern-matching.

The members of a tuple are laid out in memory contiguously, in order
specified by the tuple type.

An example of a tuple type and its use:

\begin{verbatim}
type Pair<'a> = (int, &'a str);
let p: Pair<'static> = (10, "hello");
let (a, b) = p;
assert!(b != "world");
\end{verbatim}

\hyperdef{}{vector-types}{\subsubsection{Vector
types}\label{vector-types}}

The vector type constructor represents a homogeneous array of values of
a given type. A vector has a fixed size. (Operations like
\texttt{vec.push} operate solely on owned vectors.) A vector type can be
annotated with a \emph{definite} size, such as \texttt{{[}int, ..10{]}}.
Such a definite-sized vector type is a first-class type, since its size
is known statically. A vector without such a size is said to be of
\emph{indefinite} size, and is therefore not a \emph{first-class} type.
An indefinite-size vector can only be instantiated through a pointer
type, such as \texttt{\&{[}T{]}} or
\texttt{Vec\textless{}T\textgreater{}}. The kind of a vector type
depends on the kind of its element type, as with other simple structural
types.

Expressions producing vectors of definite size cannot be evaluated in a
context expecting a vector of indefinite size; one must copy the
definite-sized vector contents into a distinct vector of indefinite
size.

An example of a vector type and its use:

\begin{verbatim}
let v: &[int] = &[7, 5, 3];
let i: int = v[2];
assert!(i == 3);
\end{verbatim}

All in-bounds elements of a vector are always initialized, and access to
a vector is always bounds-checked.

\hyperdef{}{structure-types}{\subsubsection{Structure
types}\label{structure-types}}

A \texttt{struct} \emph{type} is a heterogeneous product of other types,
called the \emph{fields} of the type.\footnote{\texttt{struct} types are
  analogous \texttt{struct} types in C, the \emph{record} types of the
  ML family, or the \emph{structure} types of the Lisp family.}

New instances of a \texttt{struct} can be constructed with a
\hyperref[structure-expressions]{struct expression}.

The memory layout of a \texttt{struct} is undefined by default to allow
for compiler optimziations like field reordering, but it can be fixed
with the \texttt{\#{[}repr(...){]}} attribute. In either case, fields
may be given in any order in a corresponding struct \emph{expression};
the resulting \texttt{struct} value will always have the same memory
layout.

The fields of a \texttt{struct} may be qualified by
\hyperref[re-exporting-and-visibility]{visibility modifiers}, to allow
access to data in a structure outside a module.

A \emph{tuple struct} type is just like a structure type, except that
the fields are anonymous.

A \emph{unit-like struct} type is like a structure type, except that it
has no fields. The one value constructed by the associated
\hyperref[structure-expressions]{structure expression} is the only value
that inhabits such a type.

\hyperdef{}{enumerated-types}{\subsubsection{Enumerated
types}\label{enumerated-types}}

An \emph{enumerated type} is a nominal, heterogeneous disjoint union
type, denoted by the name of an \hyperref[enumerations]{\texttt{enum}
item}. \footnote{The \texttt{enum} type is analogous to a \texttt{data}
  constructor declaration in ML, or a \emph{pick ADT} in Limbo.}

An \hyperref[enumerations]{\texttt{enum} item} declares both the type
and a number of \emph{variant constructors}, each of which is
independently named and takes an optional tuple of arguments.

New instances of an \texttt{enum} can be constructed by calling one of
the variant constructors, in a \hyperref[call-expressions]{call
expression}.

Any \texttt{enum} value consumes as much memory as the largest variant
constructor for its corresponding \texttt{enum} type.

Enum types cannot be denoted \emph{structurally} as types, but must be
denoted by named reference to an \hyperref[enumerations]{\texttt{enum}
item}.

\subsubsection{Recursive types}\label{recursive-types}

Nominal types --- \hyperref[enumerated-types]{enumerations} and
\hyperref[structure-types]{structures} --- may be recursive. That is,
each \texttt{enum} constructor or \texttt{struct} field may refer,
directly or indirectly, to the enclosing \texttt{enum} or
\texttt{struct} type itself. Such recursion has restrictions:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Recursive types must include a nominal type in the recursion (not mere
  \hyperref[type-definitions]{type definitions}, or other structural
  types such as \hyperref[vector-types]{vectors} or
  \hyperref[tuple-types]{tuples}).
\item
  A recursive \texttt{enum} item must have at least one non-recursive
  constructor (in order to give the recursion a basis case).
\item
  The size of a recursive type must be finite; in other words the
  recursive fields of the type must be \hyperref[pointer-types]{pointer
  types}.
\item
  Recursive type definitions can cross module boundaries, but not module
  \emph{visibility} boundaries, or crate boundaries (in order to
  simplify the module system and type checker).
\end{itemize}

An example of a \emph{recursive} type and its use:

\begin{verbatim}
enum List<T> {
  Nil,
  Cons(T, Box<List<T>>)
}

let a: List<int> = Cons(7, box Cons(13, box Nil));
\end{verbatim}

\hyperdef{}{pointer-types}{\subsubsection{Pointer
types}\label{pointer-types}}

All pointers in Rust are explicit first-class values. They can be
copied, stored into data structures, and returned from functions. There
are four varieties of pointer in Rust:

\begin{itemize}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[Owning pointers (\texttt{Box})]
  These point to owned heap allocations (or ``boxes'') in the shared,
  inter-task heap.
  \end{description}

  Each owned box has a single owning pointer; pointer and pointee retain
  a 1:1 relationship at all times. Owning pointers are written
  \texttt{Box\textless{}content\textgreater{}}, for example
  \texttt{Box\textless{}int\textgreater{}} means an owning pointer to an
  owned box containing an integer. Copying an owned box is a ``deep''
  operation: it involves allocating a new owned box and copying the
  contents of the old box into the new box. Releasing an owning pointer
  immediately releases its corresponding owned box.
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[References (\texttt{\&})]
  These point to memory \emph{owned by some other value}.
  \end{description}

  References arise by (automatic) conversion from owning pointers,
  managed pointers, or by applying the borrowing operator \texttt{\&} to
  some other value, including
  \hyperref[lvalues-rvalues-and-temporaries]{lvalues, rvalues or
  temporaries}. References are written \texttt{\&content}, or in some
  cases \texttt{\&'f content} for some lifetime-variable \texttt{f}, for
  example \texttt{\&int} means a reference to an integer. Copying a
  reference is a ``shallow'' operation: it involves only copying the
  pointer itself. Releasing a reference typically has no effect on the
  value it points to, with the exception of temporary values, which are
  released when the last reference to them is released.
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[Raw pointers (\texttt{*})]
  Raw pointers are pointers without safety or liveness guarantees.
  \end{description}

  Raw pointers are written as \texttt{*const T} or \texttt{*mut T}, for
  example \texttt{*const int} means a raw pointer to an integer. Copying
  or dropping a raw pointer has no effect on the lifecycle of any other
  value. Dereferencing a raw pointer or converting it to any other
  pointer type is an \hyperref[unsafe-functions]{\texttt{unsafe}
  operation}. Raw pointers are generally discouraged in Rust code; they
  exist to support interoperability with foreign code, and writing
  performance-critical or low-level functions.
\end{itemize}

\hyperdef{}{function-types}{\subsubsection{Function
types}\label{function-types}}

The function type constructor \texttt{fn} forms new function types. A
function type consists of a possibly-empty set of function-type
modifiers (such as \texttt{unsafe} or \texttt{extern}), a sequence of
input types and an output type.

An example of a \texttt{fn} type:

\begin{verbatim}
fn add(x: int, y: int) -> int {
  return x + y;
}

let mut x = add(5,7);

type Binop<'a> = |int,int|: 'a -> int;
let bo: Binop = add;
x = bo(5,7);
\end{verbatim}

\subsubsection{Closure types}\label{closure-types}

\begin{verbatim}
closure_type := [ 'unsafe' ] [ '<' lifetime-list '>' ] '|' arg-list '|'
                [ ':' bound-list ] [ '->' type ]
procedure_type := 'proc' [ '<' lifetime-list '>' ] '(' arg-list ')'
                  [ ':' bound-list ] [ '->' type ]
lifetime-list := lifetime | lifetime ',' lifetime-list
arg-list := ident ':' type | ident ':' type ',' arg-list
bound-list := bound | bound '+' bound-list
bound := path | lifetime
\end{verbatim}

The type of a closure mapping an input of type \texttt{A} to an output
of type \texttt{B} is \texttt{\textbar{}A\textbar{} -\textgreater{} B}.
A closure with no arguments or return values has type
\texttt{\textbar{}\textbar{}}. Similarly, a procedure mapping \texttt{A}
to \texttt{B} is \texttt{proc(A) -\textgreater{} B} and a no-argument
and no-return value closure has type \texttt{proc()}.

An example of creating and calling a closure:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{captured_var = }\DecValTok{10i}\NormalTok{;}

\KeywordTok{let} \NormalTok{closure_no_args = || }\OtherTok{println!}\NormalTok{(}\StringTok{"captured_var=\{\}"}\NormalTok{, captured_var);}

\KeywordTok{let} \NormalTok{closure_args = |arg: }\KeywordTok{int}\NormalTok{| -> }\KeywordTok{int} \NormalTok{\{}
  \OtherTok{println!}\NormalTok{(}\StringTok{"captured_var=\{\}, arg=\{\}"}\NormalTok{, captured_var, arg);}
  \NormalTok{arg }\CommentTok{// Note lack of semicolon after 'arg'}
\NormalTok{\};}

\KeywordTok{fn} \NormalTok{call_closure(c1: ||, c2: |}\KeywordTok{int}\NormalTok{| -> }\KeywordTok{int}\NormalTok{) \{}
  \NormalTok{c1();}
  \NormalTok{c2(}\DecValTok{2}\NormalTok{);}
\NormalTok{\}}

\NormalTok{call_closure(closure_no_args, closure_args);}
\end{Highlighting}
\end{Shaded}

Unlike closures, procedures may only be invoked once, but own their
environment, and are allowed to move out of their environment.
Procedures are allocated on the heap (unlike closures). An example of
creating and calling a procedure:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{string = }\StringTok{"Hello"}\NormalTok{.to_string();}

\CommentTok{// Creates a new procedure, passing it to the `spawn` function.}
\NormalTok{spawn(proc() \{}
  \OtherTok{println!}\NormalTok{(}\StringTok{"\{\} world!"}\NormalTok{, string);}
\NormalTok{\});}

\CommentTok{// the variable `string` has been moved into the previous procedure, so it is}
\CommentTok{// no longer usable.}


\CommentTok{// Create an invoke a procedure. Note that the procedure is *moved* when}
\CommentTok{// invoked, so it cannot be invoked again.}
\KeywordTok{let} \NormalTok{f = proc(n: }\KeywordTok{int}\NormalTok{) \{ n + }\DecValTok{22} \NormalTok{\};}
\OtherTok{println!}\NormalTok{(}\StringTok{"answer: \{\}"}\NormalTok{, f(}\DecValTok{20}\NormalTok{));}
\end{Highlighting}
\end{Shaded}

\hyperdef{}{object-types}{\subsubsection{Object
types}\label{object-types}}

Every trait item (see \hyperref[traits]{traits}) defines a type with the
same name as the trait. This type is called the \emph{object type} of
the trait. Object types permit ``late binding'' of methods, dispatched
using \emph{virtual method tables} (``vtables''). Whereas most calls to
trait methods are ``early bound'' (statically resolved) to specific
implementations at compile time, a call to a method on an object type is
only resolved to a vtable entry at compile time. The actual
implementation for each vtable entry can vary on an object-by-object
basis.

Given a pointer-typed expression \texttt{E} of type \texttt{\&T} or
\texttt{Box\textless{}T\textgreater{}}, where \texttt{T} implements
trait \texttt{R}, casting \texttt{E} to the corresponding pointer type
\texttt{\&R} or \texttt{Box\textless{}R\textgreater{}} results in a
value of the \emph{object type} \texttt{R}. This result is represented
as a pair of pointers: the vtable pointer for the \texttt{T}
implementation of \texttt{R}, and the pointer value of \texttt{E}.

An example of an object type:

\begin{verbatim}
trait Printable {
  fn to_string(&self) -> String;
}

impl Printable for int {
  fn to_string(&self) -> String { self.to_str() }
}

fn print(a: Box<Printable>) {
   println!("{}", a.to_string());
}

fn main() {
   print(box 10i as Box<Printable>);
}
\end{verbatim}

In this example, the trait \texttt{Printable} occurs as an object type
in both the type signature of \texttt{print}, and the cast expression in
\texttt{main}.

\subsubsection{Type parameters}\label{type-parameters-1}

Within the body of an item that has type parameter declarations, the
names of its type parameters are types:

\begin{verbatim}
fn map<A: Clone, B: Clone>(f: |A| -> B, xs: &[A]) -> Vec<B> {
    if xs.len() == 0 {
       return vec![];
    }
    let first: B = f(xs[0].clone());
    let rest: Vec<B> = map(f, xs.slice(1, xs.len()));
    return vec![first].append(rest.as_slice());
}
\end{verbatim}

Here, \texttt{first} has type \texttt{B}, referring to \texttt{map}'s
\texttt{B} type parameter; and \texttt{rest} has type
\texttt{Vec\textless{}B\textgreater{}}, a vector type with element type
\texttt{B}.

\hyperdef{}{self-types}{\subsubsection{Self types}\label{self-types}}

The special type \texttt{self} has a meaning within methods inside an
impl item. It refers to the type of the implicit \texttt{self} argument.
For example, in:

\begin{verbatim}
trait Printable {
  fn make_string(&self) -> String;
}

impl Printable for String {
    fn make_string(&self) -> String {
        (*self).clone()
    }
}
\end{verbatim}

\texttt{self} refers to the value of type \texttt{String} that is the
receiver for a call to the method \texttt{make\_string}.

\hyperdef{}{type-kinds}{\subsection{Type kinds}\label{type-kinds}}

Types in Rust are categorized into kinds, based on various properties of
the components of the type. The kinds are:

\begin{itemize}
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{Send}]
  Types of this kind can be safely sent between tasks.
  \end{description}

  This kind includes scalars, owning pointers, owned closures, and
  structural types containing only other owned types. All \texttt{Send}
  types are \texttt{'static}.
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{Copy}]
  Types of this kind consist of ``Plain Old Data''
  \end{description}

  which can be copied by simply moving bits. All values of this kind can
  be implicitly copied. This kind includes scalars and immutable
  references, as well as structural types containing other \texttt{Copy}
  types.
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{'static}]
  Types of this kind do not contain any references (except for
  \end{description}

  references with the \texttt{static} lifetime, which are allowed). This
  can be a useful guarantee for code that breaks borrowing assumptions
  using \hyperref[unsafe-functions]{\texttt{unsafe} operations}.
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\texttt{Drop}]
  This is not strictly a kind,
  \end{description}

  but its presence interacts with kinds: the \texttt{Drop} trait
  provides a single method \texttt{drop} that takes no parameters, and
  is run when values of the type are dropped. Such a method is called a
  ``destructor'', and are always executed in ``top-down'' order: a value
  is completely destroyed before any of the values it owns run their
  destructors. Only \texttt{Send} types can implement \texttt{Drop}.
\item
  \begin{description}
  \itemsep1pt\parskip0pt\parsep0pt
  \item[\emph{Default}]
  Types with destructors, closure environments,
  \end{description}

  and various other \emph{non-first-class} types, are not copyable at
  all. Such types can usually only be accessed through pointers, or in
  some cases, moved between mutable locations.
\end{itemize}

Kinds can be supplied as \emph{bounds} on type parameters, like traits,
in which case the parameter is constrained to types satisfying that
kind.

By default, type parameters do not carry any assumed kind-bounds at all.
When instantiating a type parameter, the kind bounds on the parameter
are checked to be the same or narrower than the kind of the type that it
is instantiated with.

Sending operations are not part of the Rust language, but are
implemented in the library. Generic functions that send values bound the
kind of these values to sendable.

\section{Memory and concurrency
models}\label{memory-and-concurrency-models}

Rust has a memory model centered around concurrently-executing
\emph{tasks}. Thus its memory model and its concurrency model are best
discussed simultaneously, as parts of each only make sense when
considered from the perspective of the other.

When reading about the memory model, keep in mind that it is partitioned
in order to support tasks; and when reading about tasks, keep in mind
that their isolation and communication mechanisms are only possible due
to the ownership and lifetime semantics of the memory model.

\subsection{Memory model}\label{memory-model}

A Rust program's memory consists of a static set of \emph{items}, a set
of \hyperref[tasks]{tasks} each with its own \emph{stack}, and a
\emph{heap}. Immutable portions of the heap may be shared between tasks,
mutable portions may not.

Allocations in the stack consist of \emph{slots}, and allocations in the
heap consist of \emph{boxes}.

\subsubsection{Memory allocation and
lifetime}\label{memory-allocation-and-lifetime}

The \emph{items} of a program are those functions, modules and types
that have their value calculated at compile-time and stored uniquely in
the memory image of the rust process. Items are neither dynamically
allocated nor freed.

A task's \emph{stack} consists of activation frames automatically
allocated on entry to each function as the task executes. A stack
allocation is reclaimed when control leaves the frame containing it.

The \emph{heap} is a general term that describes two separate sets of
boxes: managed boxes --- which may be subject to garbage collection ---
and owned boxes. The lifetime of an allocation in the heap depends on
the lifetime of the box values pointing to it. Since box values may
themselves be passed in and out of frames, or stored in the heap, heap
allocations may outlive the frame they are allocated within.

\subsubsection{Memory ownership}\label{memory-ownership}

A task owns all memory it can \emph{safely} reach through local
variables, as well as managed, owned boxes and references.

When a task sends a value that has the \texttt{Send} trait to another
task, it loses ownership of the value sent and can no longer refer to
it. This is statically guaranteed by the combined use of ``move
semantics'', and the compiler-checked \emph{meaning} of the
\texttt{Send} trait: it is only instantiated for (transitively) sendable
kinds of data constructor and pointers, never including managed boxes or
references.

When a stack frame is exited, its local allocations are all released,
and its references to boxes (both managed and owned) are dropped.

A managed box may (in the case of a recursive, mutable managed type) be
cyclic; in this case the release of memory inside the managed structure
may be deferred until task-local garbage collection can reclaim it. Code
can ensure no such delayed deallocation occurs by restricting itself to
owned boxes and similar unmanaged kinds of data.

When a task finishes, its stack is necessarily empty and it therefore
has no references to any boxes; the remainder of its heap is immediately
freed.

\hyperdef{}{memory-slots}{\subsubsection{Memory
slots}\label{memory-slots}}

A task's stack contains slots.

A \emph{slot} is a component of a stack frame, either a function
parameter, a \hyperref[lvalues-rvalues-and-temporaries]{temporary}, or a
local variable.

A \emph{local variable} (or \emph{stack-local} allocation) holds a value
directly, allocated within the stack's memory. The value is a part of
the stack frame.

Local variables are immutable unless declared otherwise like:
\texttt{let mut x = ...}.

Function parameters are immutable unless declared with \texttt{mut}. The
\texttt{mut} keyword applies only to the following parameter (so
\texttt{\textbar{}mut x, y\textbar{}} and
\texttt{fn f(mut x: Box\textless{}int\textgreater{}, y: Box\textless{}int\textgreater{})}
declare one mutable variable \texttt{x} and one immutable variable
\texttt{y}).

Methods that take either \texttt{self} or \texttt{\textasciitilde{}self}
can optionally place them in a mutable slot by prefixing them with
\texttt{mut} (similar to regular arguments):

\begin{verbatim}
trait Changer {
    fn change(mut self) -> Self;
    fn modify(mut ~self) -> Box<Self>;
}
\end{verbatim}

Local variables are not initialized when allocated; the entire frame
worth of local variables are allocated at once, on frame-entry, in an
uninitialized state. Subsequent statements within a function may or may
not initialize the local variables. Local variables can be used only
after they have been initialized; this is enforced by the compiler.

\subsubsection{Owned boxes}\label{owned-boxes}

An \emph{owned box} is a reference to a heap allocation holding another
value, which is constructed by the prefix operator \texttt{box}. When
the standard library is in use, the type of an owned box is
\texttt{std::owned::Box\textless{}T\textgreater{}}.

An example of an owned box type and value:

\begin{verbatim}

let x: Box<int> = box 10;
\end{verbatim}

Owned box values exist in 1:1 correspondence with their heap allocation
copying an owned box value makes a shallow copy of the pointer Rust will
consider a shallow copy of an owned box to move ownership of the value.
After a value has been moved, the source location cannot be used unless
it is reinitialized.

\begin{verbatim}
let x: Box<int> = box 10;
let y = x;
// attempting to use `x` will result in an error here
\end{verbatim}

\hyperdef{}{tasks}{\subsection{Tasks}\label{tasks}}

An executing Rust program consists of a tree of tasks. A Rust
\emph{task} consists of an entry function, a stack, a set of outgoing
communication channels and incoming communication ports, and ownership
of some portion of the heap of a single operating-system process. (We
expect that many programs will not use channels and ports directly, but
will instead use higher-level abstractions provided in standard
libraries, such as pipes.)

Multiple Rust tasks may coexist in a single operating-system process.
The runtime scheduler maps tasks to a certain number of operating-system
threads. By default, the scheduler chooses the number of threads based
on the number of concurrent physical CPUs detected at startup. It's also
possible to override this choice at runtime. When the number of tasks
exceeds the number of threads --- which is likely --- the scheduler
multiplexes the tasks onto threads.\footnote{This is an M:N scheduler,
  which is known to give suboptimal results for CPU-bound concurrency
  problems. In such cases, running with the same number of threads and
  tasks can yield better results. Rust has M:N scheduling in order to
  support very large numbers of tasks in contexts where threads are too
  resource-intensive to use in large number. The cost of threads varies
  substantially per operating system, and is sometimes quite low, so
  this flexibility is not always worth exploiting.}

\subsubsection{Communication between
tasks}\label{communication-between-tasks}

Rust tasks are isolated and generally unable to interfere with one
another's memory directly, except through
\hyperref[unsafe-functions]{\texttt{unsafe} code}. All contact between
tasks is mediated by safe forms of ownership transfer, and data races on
memory are prohibited by the type system.

Inter-task communication and co-ordination facilities are provided in
the standard library. These include:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  synchronous and asynchronous communication channels with various
  communication topologies
\item
  read-only and read-write shared variables with various safe mutual
  exclusion patterns
\item
  simple locks and semaphores
\end{itemize}

When such facilities carry values, the values are restricted to the
\hyperref[type-kinds]{\texttt{Send} type-kind}. Restricting
communication interfaces to this kind ensures that no references or
managed pointers move between tasks. Thus access to an entire data
structure can be mediated through its owning ``root'' value; no further
locking or copying is required to avoid data races within the
substructure of such a value.

\subsubsection{Task lifecycle}\label{task-lifecycle}

The \emph{lifecycle} of a task consists of a finite set of states and
events that cause transitions between the states. The lifecycle states
of a task are:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  running
\item
  blocked
\item
  failing
\item
  dead
\end{itemize}

A task begins its lifecycle --- once it has been spawned --- in the
\emph{running} state. In this state it executes the statements of its
entry function, and any functions called by the entry function.

A task may transition from the \emph{running} state to the
\emph{blocked} state any time it makes a blocking communication call.
When the call can be completed --- when a message arrives at a sender,
or a buffer opens to receive a message --- then the blocked task will
unblock and transition back to \emph{running}.

A task may transition to the \emph{failing} state at any time, due being
killed by some external event or internally, from the evaluation of a
\texttt{fail!()} macro. Once \emph{failing}, a task unwinds its stack
and transitions to the \emph{dead} state. Unwinding the stack of a task
is done by the task itself, on its own control stack. If a value with a
destructor is freed during unwinding, the code for the destructor is
run, also on the task's control stack. Running the destructor code
causes a temporary transition to a \emph{running} state, and allows the
destructor code to cause any subsequent state transitions. The original
task of unwinding and failing thereby may suspend temporarily, and may
involve (recursive) unwinding of the stack of a failed destructor.
Nonetheless, the outermost unwinding activity will continue until the
stack is unwound and the task transitions to the \emph{dead} state.
There is no way to ``recover'' from task failure. Once a task has
temporarily suspended its unwinding in the \emph{failing} state, failure
occurring from within this destructor results in \emph{hard} failure. A
hard failure currently results in the process aborting.

A task in the \emph{dead} state cannot transition to other states; it
exists only to have its termination status inspected by other tasks,
and/or to await reclamation when the last reference to it drops.

\subsubsection{Task scheduling}\label{task-scheduling}

The currently scheduled task is given a finite \emph{time slice} in
which to execute, after which it is \emph{descheduled} at a loop-edge or
similar preemption point, and another task within is scheduled,
pseudo-randomly.

An executing task can yield control at any time, by making a library
call to \texttt{std::task::yield}, which deschedules it immediately.
Entering any other non-executing state (blocked, dead) similarly
deschedules the task.

\section{Runtime services, linkage and
debugging}\label{runtime-services-linkage-and-debugging}

The Rust \emph{runtime} is a relatively compact collection of C++ and
Rust code that provides fundamental services and datatypes to all Rust
tasks at run-time. It is smaller and simpler than many modern language
runtimes. It is tightly integrated into the language's execution model
of memory, tasks, communication and logging.

\begin{quote}
\textbf{Note:} The runtime library will merge with the \texttt{std}
library in future versions of Rust.
\end{quote}

\subsubsection{Memory allocation}\label{memory-allocation}

The runtime memory-management system is based on a
\emph{service-provider interface}, through which the runtime requests
blocks of memory from its environment and releases them back to its
environment when they are no longer needed. The default implementation
of the service-provider interface consists of the C runtime functions
\texttt{malloc} and \texttt{free}.

The runtime memory-management system, in turn, supplies Rust tasks with
facilities for allocating releasing stacks, as well as allocating and
freeing heap data.

\subsubsection{Built in types}\label{built-in-types}

The runtime provides C and Rust code to assist with various built-in
types, such as vectors, strings, and the low level communication system
(ports, channels, tasks).

Support for other built-in types such as simple types, tuples and enums
is open-coded by the Rust compiler.

\subsubsection{Task scheduling and
communication}\label{task-scheduling-and-communication}

The runtime provides code to manage inter-task communication. This
includes the system of task-lifecycle state transitions depending on the
contents of queues, as well as code to copy values between queues and
their recipients and to serialize values for transmission over
operating-system inter-process communication facilities.

\hyperdef{}{linkage}{\subsubsection{Linkage}\label{linkage}}

The Rust compiler supports various methods to link crates together both
statically and dynamically. This section will explore the various
methods to link Rust crates together, and more information about native
libraries can be found in the \href{guide-ffi.html}{ffi tutorial}.

In one session of compilation, the compiler can generate multiple
artifacts through the usage of either command line flags or the
\texttt{crate\_type} attribute. If one or more command line flag is
specified, all \texttt{crate\_type} attributes will be ignored in favor
of only building the artifacts specified by command line.

\begin{itemize}
\item
  \texttt{-\/-crate-type=bin}, \texttt{\#{[}crate\_type = "bin"{]}} - A
  runnable executable will be produced. This requires that there is a
  \texttt{main} function in the crate which will be run when the program
  begins executing. This will link in all Rust and native dependencies,
  producing a distributable binary.
\item
  \texttt{-\/-crate-type=lib}, \texttt{\#{[}crate\_type = "lib"{]}} - A
  Rust library will be produced. This is an ambiguous concept as to what
  exactly is produced because a library can manifest itself in several
  forms. The purpose of this generic \texttt{lib} option is to generate
  the ``compiler recommended'' style of library. The output library will
  always be usable by rustc, but the actual type of library may change
  from time-to-time. The remaining output types are all different
  flavors of libraries, and the \texttt{lib} type can be seen as an
  alias for one of them (but the actual one is compiler-defined).
\item
  \texttt{-\/-crate-type=dylib}, \texttt{\#{[}crate\_type = "dylib"{]}}
  - A dynamic Rust library will be produced. This is different from the
  \texttt{lib} output type in that this forces dynamic library
  generation. The resulting dynamic library can be used as a dependency
  for other libraries and/or executables. This output type will create
  \texttt{*.so} files on linux, \texttt{*.dylib} files on osx, and
  \texttt{*.dll} files on windows.
\item
  \texttt{-\/-crate-type=staticlib},
  \texttt{\#{[}crate\_type = "staticlib"{]}} - A static system library
  will be produced. This is different from other library outputs in that
  the Rust compiler will never attempt to link to \texttt{staticlib}
  outputs. The purpose of this output type is to create a static library
  containing all of the local crate's code along with all upstream
  dependencies. The static library is actually a \texttt{*.a} archive on
  linux and osx and a \texttt{*.lib} file on windows. This format is
  recommended for use in situtations such as linking Rust code into an
  existing non-Rust application because it will not have dynamic
  dependencies on other Rust code.
\item
  \texttt{-\/-crate-type=rlib}, \texttt{\#{[}crate\_type = "rlib"{]}} -
  A ``Rust library'' file will be produced. This is used as an
  intermediate artifact and can be thought of as a ``static Rust
  library''. These \texttt{rlib} files, unlike \texttt{staticlib} files,
  are interpreted by the Rust compiler in future linkage. This
  essentially means that \texttt{rustc} will look for metadata in
  \texttt{rlib} files like it looks for metadata in dynamic libraries.
  This form of output is used to produce statically linked executables
  as well as \texttt{staticlib} outputs.
\end{itemize}

Note that these outputs are stackable in the sense that if multiple are
specified, then the compiler will produce each form of output at once
without having to recompile. However, this only applies for outputs
specified by the same method. If only \texttt{crate\_type} attributes
are specified, then they will all be built, but if one or more
\texttt{-\/-crate-type} command line flag is specified, then only those
outputs will be built.

With all these different kinds of outputs, if crate A depends on crate
B, then the compiler could find B in various different forms throughout
the system. The only forms looked for by the compiler, however, are the
\texttt{rlib} format and the dynamic library format. With these two
options for a dependent library, the compiler must at some point make a
choice between these two formats. With this in mind, the compiler
follows these rules when determining what format of dependencies will be
used:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\itemsep1pt\parskip0pt\parsep0pt
\item
  If a static library is being produced, all upstream dependencies are
  required to be available in \texttt{rlib} formats. This requirement
  stems from the reason that a dynamic library cannot be converted into
  a static format.
\end{enumerate}

Note that it is impossible to link in native dynamic dependencies to a
static library, and in this case warnings will be printed about all
unlinked native dynamic dependencies.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\itemsep1pt\parskip0pt\parsep0pt
\item
  If an \texttt{rlib} file is being produced, then there are no
  restrictions on what format the upstream dependencies are available
  in. It is simply required that all upstream dependencies be available
  for reading metadata from.
\end{enumerate}

The reason for this is that \texttt{rlib} files do not contain any of
their upstream dependencies. It wouldn't be very efficient for all
\texttt{rlib} files to contain a copy of \texttt{libstd.rlib}!

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  If an executable is being produced and the \texttt{-C prefer-dynamic}
  flag is not specified, then dependencies are first attempted to be
  found in the \texttt{rlib} format. If some dependencies are not
  available in an rlib format, then dynamic linking is attempted (see
  below).
\item
  If a dynamic library or an executable that is being dynamically linked
  is being produced, then the compiler will attempt to reconcile the
  available dependencies in either the rlib or dylib format to create a
  final product.
\end{enumerate}

A major goal of the compiler is to ensure that a library never appears
more than once in any artifact. For example, if dynamic libraries B and
C were each statically linked to library A, then a crate could not link
to B and C together because there would be two copies of A. The compiler
allows mixing the rlib and dylib formats, but this restriction must be
satisfied.

The compiler currently implements no method of hinting what format a
library should be linked with. When dynamically linking, the compiler
will attempt to maximize dynamic dependencies while still allowing some
dependencies to be linked in via an rlib.

For most situations, having all libraries available as a dylib is
recommended if dynamically linking. For other situations, the compiler
will emit a warning if it is unable to determine which formats to link
each library with.

In general, \texttt{-\/-crate-type=bin} or \texttt{-\/-crate-type=lib}
should be sufficient for all compilation needs, and the other options
are just available if more fine-grained control is desired over the
output format of a Rust crate.

\subsubsection{Logging system}\label{logging-system}

The runtime contains a system for directing
\hyperref[logging-expressions]{logging expressions} to a logging console
and/or internal logging buffers. Logging can be enabled per module.

Logging output is enabled by setting the \texttt{RUST\_LOG} environment
variable. \texttt{RUST\_LOG} accepts a logging specification made up of
a comma-separated list of paths, with optional log levels. For each
module containing log expressions, if \texttt{RUST\_LOG} contains the
path to that module or a parent of that module, then logs of the
appropriate level will be output to the console.

The path to a module consists of the crate name, any parent modules,
then the module itself, all separated by double colons (\texttt{::}).
The optional log level can be appended to the module path with an equals
sign (\texttt{=}) followed by the log level, from 1 to 4, inclusive.
Level 1 is the error level, 2 is warning, 3 info, and 4 debug. You can
also use the symbolic constants \texttt{error}, \texttt{warn},
\texttt{info}, and \texttt{debug}. Any logs less than or equal to the
specified level will be output. If not specified then log level 4 is
assumed. Debug messages can be omitted by passing
\texttt{-\/-cfg ndebug} to \texttt{rustc}.

As an example, to see all the logs generated by the compiler, you would
set \texttt{RUST\_LOG} to \texttt{rustc}, which is the crate name (as
specified in its \texttt{crate\_id} \hyperref[attributes]{attribute}).
To narrow down the logs to just crate resolution, you would set it to
\texttt{rustc::metadata::creader}. To see just error logging use
\texttt{rustc=0}.

Note that when compiling source files that don't specify a crate name
the crate is given a default name that matches the source file, with the
extension removed. In that case, to turn on logging for a program
compiled from, e.g. \texttt{helloworld.rs}, \texttt{RUST\_LOG} should be
set to \texttt{helloworld}.

\hyperdef{}{logging-expressions}{\paragraph{Logging
Expressions}\label{logging-expressions}}

Rust provides several macros to log information. Here's a simple Rust
program that demonstrates all four of them:

\begin{verbatim}
#![feature(phase)]
#[phase(plugin, link)] extern crate log;

fn main() {
    error!("This is an error log")
    warn!("This is a warn log")
    info!("this is an info log")
    debug!("This is a debug log")
}
\end{verbatim}

These four log levels correspond to levels 1-4, as controlled by
\texttt{RUST\_LOG}:

\begin{verbatim}
$ RUST_LOG=rust=3 ./rust
This is an error log
This is a warn log
this is an info log
\end{verbatim}

\section{Appendix: Rationales and design
tradeoffs}\label{appendix-rationales-and-design-tradeoffs}

\emph{TODO}.

\section{Appendix: Influences and further
references}\label{appendix-influences-and-further-references}

\subsection{Influences}\label{influences}

\begin{quote}
The essential problem that must be solved in making a fault-tolerant
software system is therefore that of fault-isolation. Different
programmers will write different modules, some modules will be correct,
others will have errors. We do not want the errors in one module to
adversely affect the behaviour of a module which does not have any
errors.

--- Joe Armstrong
\end{quote}

\begin{quote}
In our approach, all data is private to some process, and processes can
only communicate through communications channels. \emph{Security}, as
used in this paper, is the property which guarantees that processes in a
system cannot affect each other except by explicit communication.

When security is absent, nothing which can be proven about a single
module in isolation can be guaranteed to hold when that module is
embedded in a system {[}\ldots{}{]}

--- Robert Strom and Shaula Yemini
\end{quote}

\begin{quote}
Concurrent and applicative programming complement each other. The
ability to send messages on channels provides I/O without side effects,
while the avoidance of shared data helps keep concurrent processes from
colliding.

--- Rob Pike
\end{quote}

Rust is not a particularly original language. It may however appear
unusual by contemporary standards, as its design elements are drawn from
a number of ``historical'' languages that have, with a few exceptions,
fallen out of favour. Five prominent lineages contribute the most,
though their influences have come and gone during the course of Rust's
development:

\begin{itemize}
\item
  The NIL (1981) and Hermes (1990) family. These languages were
  developed by Robert Strom, Shaula Yemini, David Bacon and others in
  their group at IBM Watson Research Center (Yorktown Heights, NY, USA).
\item
  The Erlang (1987) language, developed by Joe Armstrong, Robert
  Virding, Claes Wikström, Mike Williams and others in their group at
  the Ericsson Computer Science Laboratory (Älvsjö, Stockholm, Sweden) .
\item
  The Sather (1990) language, developed by Stephen Omohundro, Chu-Cheow
  Lim, Heinz Schmidt and others in their group at The International
  Computer Science Institute of the University of California, Berkeley
  (Berkeley, CA, USA).
\item
  The Newsqueak (1988), Alef (1995), and Limbo (1996) family. These
  languages were developed by Rob Pike, Phil Winterbottom, Sean Dorward
  and others in their group at Bell Labs Computing Sciences Research
  Center (Murray Hill, NJ, USA).
\item
  The Napier (1985) and Napier88 (1988) family. These languages were
  developed by Malcolm Atkinson, Ron Morrison and others in their group
  at the University of St.~Andrews (St.~Andrews, Fife, UK).
\end{itemize}

Additional specific influences can be seen from the following languages:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  The structural algebraic types and compilation manager of SML.
\item
  The attribute and assembly systems of C\#.
\item
  The references and deterministic destructor system of C++.
\item
  The memory region systems of the ML Kit and Cyclone.
\item
  The typeclass system of Haskell.
\item
  The lexical identifier rule of Python.
\item
  The block syntax of Ruby.
\end{itemize}

\end{document}
