<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="The std library documentation.">

    <title>std::collections::hashmap::HashMap - Rust</title>

    <link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:400,600'
          rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="../../../main.css">

    <link rel="shortcut icon" href="http://www.rust-lang.org/favicon.ico">
    
</head>
<body>
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <section class="sidebar">
        <a href='../../../std/index.html'><img src='http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt='' width='100'></a>
        <p class='location'><a href='../../index.html'>std</a>&#8203;::<a href='../index.html'>collections</a>&#8203;::<a href='index.html'>hashmap</a></p><div class='block struct'><h2>Structs</h2><a class='struct current' href='struct.HashMap.html'>HashMap</a><a class='struct ' href='struct.HashSet.html'>HashSet</a></div>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press 'S' to search, '?' for more options..."
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content struct">
<h1 class='fqn'>Struct <a href='../../index.html'>std</a>::<a href='../index.html'>collections</a>::<a href='index.html'>hashmap</a>::<a class='struct' href=''>HashMap</a><a class='stability Experimental' title=''>Experimental</a><span class='out-of-band'><a id='src-15012' href='../../../src/std/Users/aturon/moz/working/stability-dashboard/src/libstd/collections/hashmap.rs.html#734-742'>[src]</a></span></h1>
<pre class='rust struct'>pub struct HashMap&lt;K, V, H = <a class='struct' href='../../../std/hash/struct.RandomSipHasher.html' title='std::hash::RandomSipHasher'>RandomSipHasher</a>&gt; {
    // some fields omitted
}</pre><div class='docblock'><p>A hash map implementation which uses linear probing with Robin
Hood bucket stealing.</p>

<p>The hashes are all keyed by the task-local random number generator
on creation by default, this means the ordering of the keys is
randomized, but makes the tables more resistant to
denial-of-service attacks (Hash DoS). This behaviour can be
overridden with one of the constructors.</p>

<p>It is required that the keys implement the <code>Eq</code> and <code>Hash</code> traits, although
this can frequently be achieved by using <code>#[deriving(Eq, Hash)]</code>.</p>

<p>Relevant papers/articles:</p>

<ol>
<li>Pedro Celis. <a href="https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf">&quot;Robin Hood Hashing&quot;</a></li>
<li>Emmanuel Goossaert. <a href="http://codecapsule.com/2013/11/11/robin-hood-hashing/">&quot;Robin Hood
hashing&quot;</a></li>
<li>Emmanuel Goossaert. <a href="http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/">&quot;Robin Hood hashing: backward shift
deletion&quot;</a></li>
</ol>

<h1 id="example" class='section-header'><a
                           href="#example">Example</a></h1><span id='rust-example-raw-0' class='rusttest'>fn main() {
    use std::collections::HashMap;
    
    // type inference lets us omit an explicit type signature (which
    // would be `HashMap&lt;&amp;str, &amp;str&gt;` in this example).
    let mut book_reviews = HashMap::new();
    
    // review some books.
    book_reviews.insert(&quot;Adventures of Huckleberry Finn&quot;,    &quot;My favorite book.&quot;);
    book_reviews.insert(&quot;Grimms&#39; Fairy Tales&quot;,               &quot;Masterpiece.&quot;);
    book_reviews.insert(&quot;Pride and Prejudice&quot;,               &quot;Very enjoyable.&quot;);
    book_reviews.insert(&quot;The Adventures of Sherlock Holmes&quot;, &quot;Eye lyked it alot.&quot;);
    
    // check for a specific one.
    if !book_reviews.contains_key(&amp;(&quot;Les Misérables&quot;)) {
        println!(&quot;We&#39;ve got {} reviews, but Les Misérables ain&#39;t one.&quot;,
                 book_reviews.len());
    }
    
    // oops, this review has a lot of spelling mistakes, let&#39;s delete it.
    book_reviews.remove(&amp;(&quot;The Adventures of Sherlock Holmes&quot;));
    
    // look up the values associated with some keys.
    let to_find = [&quot;Pride and Prejudice&quot;, &quot;Alice&#39;s Adventure in Wonderland&quot;];
    for book in to_find.iter() {
        match book_reviews.find(book) {
            Some(review) =&gt; println!(&quot;{}: {}&quot;, *book, *review),
            None =&gt; println!(&quot;{} is unreviewed.&quot;, *book)
        }
    }
    
    // iterate over everything.
    for (book, review) in book_reviews.iter() {
        println!(&quot;{}: \&quot;{}\&quot;&quot;, *book, *review);
    }
}</span><pre id='rust-example-rendered-0' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>HashMap</span>;<span class='comment'>

// type inference lets us omit an explicit type signature (which
// would be `HashMap&lt;&amp;str, &amp;str&gt;` in this example).
</span><span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>book_reviews</span> <span class='op'>=</span> <span class='ident'>HashMap</span>::<span class='ident'>new</span>();<span class='comment'>

// review some books.
</span><span class='ident'>book_reviews</span>.<span class='ident'>insert</span>(<span class='string'>&quot;Adventures of Huckleberry Finn&quot;</span>,    <span class='string'>&quot;My favorite book.&quot;</span>);
<span class='ident'>book_reviews</span>.<span class='ident'>insert</span>(<span class='string'>&quot;Grimms&#39; Fairy Tales&quot;</span>,               <span class='string'>&quot;Masterpiece.&quot;</span>);
<span class='ident'>book_reviews</span>.<span class='ident'>insert</span>(<span class='string'>&quot;Pride and Prejudice&quot;</span>,               <span class='string'>&quot;Very enjoyable.&quot;</span>);
<span class='ident'>book_reviews</span>.<span class='ident'>insert</span>(<span class='string'>&quot;The Adventures of Sherlock Holmes&quot;</span>, <span class='string'>&quot;Eye lyked it alot.&quot;</span>);<span class='comment'>

// check for a specific one.
</span><span class='kw'>if</span> <span class='op'>!</span><span class='ident'>book_reviews</span>.<span class='ident'>contains_key</span>(<span class='kw-2'>&amp;</span>(<span class='string'>&quot;Les Misérables&quot;</span>)) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;We&#39;ve got {} reviews, but Les Misérables ain&#39;t one.&quot;</span>,
             <span class='ident'>book_reviews</span>.<span class='ident'>len</span>());
}<span class='comment'>

// oops, this review has a lot of spelling mistakes, let&#39;s delete it.
</span><span class='ident'>book_reviews</span>.<span class='ident'>remove</span>(<span class='kw-2'>&amp;</span>(<span class='string'>&quot;The Adventures of Sherlock Holmes&quot;</span>));<span class='comment'>

// look up the values associated with some keys.
</span><span class='kw'>let</span> <span class='ident'>to_find</span> <span class='op'>=</span> [<span class='string'>&quot;Pride and Prejudice&quot;</span>, <span class='string'>&quot;Alice&#39;s Adventure in Wonderland&quot;</span>];
<span class='kw'>for</span> <span class='ident'>book</span> <span class='kw'>in</span> <span class='ident'>to_find</span>.<span class='ident'>iter</span>() {
    <span class='kw'>match</span> <span class='ident'>book_reviews</span>.<span class='ident'>find</span>(<span class='ident'>book</span>) {
        <span class='prelude-val'>Some</span>(<span class='ident'>review</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}: {}&quot;</span>, <span class='op'>*</span><span class='ident'>book</span>, <span class='op'>*</span><span class='ident'>review</span>),
        <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} is unreviewed.&quot;</span>, <span class='op'>*</span><span class='ident'>book</span>)
    }
}<span class='comment'>

// iterate over everything.
</span><span class='kw'>for</span> (<span class='ident'>book</span>, <span class='ident'>review</span>) <span class='kw'>in</span> <span class='ident'>book_reviews</span>.<span class='ident'>iter</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}: \&quot;{}\&quot;&quot;</span>, <span class='op'>*</span><span class='ident'>book</span>, <span class='op'>*</span><span class='ident'>review</span>);
}
</pre>
</div><h2 id='methods'>Methods</h2><h3 class='impl'><a class='stability Experimental' title='Experimental'></a><code>impl&lt;K: <a class='trait' href='../../../std/cmp/trait.Eq.html' title='std::cmp::Eq'>Eq</a> + <a class='trait' href='../../../std/hash/trait.Hash.html' title='std::hash::Hash'>Hash</a>&lt;S&gt;, V, S, H: <a class='trait' href='../../../std/hash/trait.Hasher.html' title='std::hash::Hasher'>Hasher</a>&lt;S&gt;&gt; <a class='struct' href='../../../std/collections/hashmap/struct.HashMap.html' title='std::collections::hashmap::HashMap'>HashMap</a>&lt;K, V, H&gt;</code></h3><div class='impl-methods'><h4 id='method.pop_equiv' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.pop_equiv' class='fnname'>pop_equiv</a>&lt;Q: <a class='trait' href='../../../std/hash/trait.Hash.html' title='std::hash::Hash'>Hash</a>&lt;S&gt; + <a class='trait' href='../../../std/cmp/trait.Equiv.html' title='std::cmp::Equiv'>Equiv</a>&lt;K&gt;&gt;(&amp;mut self, k: &amp;Q) -&gt; <a class='type' href='../../../std/option/type.Option.html' title='std::option::Option'>Option</a>&lt;V&gt;</code></h4>
<div class='docblock'><p>Like <code>pop</code>, but can operate on any type that is equivalent to a key.</p>
</div></div><h3 class='impl'><a class='stability Experimental' title='Experimental'></a><code>impl&lt;K: <a class='trait' href='../../../std/hash/trait.Hash.html' title='std::hash::Hash'>Hash</a> + <a class='trait' href='../../../std/cmp/trait.Eq.html' title='std::cmp::Eq'>Eq</a>, V&gt; <a class='struct' href='../../../std/collections/hashmap/struct.HashMap.html' title='std::collections::hashmap::HashMap'>HashMap</a>&lt;K, V, <a class='struct' href='../../../std/hash/struct.RandomSipHasher.html' title='std::hash::RandomSipHasher'>RandomSipHasher</a>&gt;</code></h3><div class='impl-methods'><h4 id='method.new' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.new' class='fnname'>new</a>() -&gt; <a class='struct' href='../../../std/collections/hashmap/struct.HashMap.html' title='std::collections::hashmap::HashMap'>HashMap</a>&lt;K, V, <a class='struct' href='../../../std/hash/struct.RandomSipHasher.html' title='std::hash::RandomSipHasher'>RandomSipHasher</a>&gt;</code></h4>
<div class='docblock'><p>Create an empty HashMap.</p>
</div><h4 id='method.with_capacity' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.with_capacity' class='fnname'>with_capacity</a>(capacity: <a href='../../primitive.uint.html'>uint</a>) -&gt; <a class='struct' href='../../../std/collections/hashmap/struct.HashMap.html' title='std::collections::hashmap::HashMap'>HashMap</a>&lt;K, V, <a class='struct' href='../../../std/hash/struct.RandomSipHasher.html' title='std::hash::RandomSipHasher'>RandomSipHasher</a>&gt;</code></h4>
<div class='docblock'><p>Creates an empty hash map with the given initial capacity.</p>
</div></div><h3 class='impl'><a class='stability Experimental' title='Experimental'></a><code>impl&lt;K: <a class='trait' href='../../../std/cmp/trait.Eq.html' title='std::cmp::Eq'>Eq</a> + <a class='trait' href='../../../std/hash/trait.Hash.html' title='std::hash::Hash'>Hash</a>&lt;S&gt;, V, S, H: <a class='trait' href='../../../std/hash/trait.Hasher.html' title='std::hash::Hasher'>Hasher</a>&lt;S&gt;&gt; <a class='struct' href='../../../std/collections/hashmap/struct.HashMap.html' title='std::collections::hashmap::HashMap'>HashMap</a>&lt;K, V, H&gt;</code></h3><div class='impl-methods'><h4 id='method.with_hasher' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.with_hasher' class='fnname'>with_hasher</a>(hasher: H) -&gt; <a class='struct' href='../../../std/collections/hashmap/struct.HashMap.html' title='std::collections::hashmap::HashMap'>HashMap</a>&lt;K, V, H&gt;</code></h4>
<div class='docblock'><p>Creates an empty hashmap which will use the given hasher to hash keys.</p>

<p>The creates map has the default initial capacity.</p>
</div><h4 id='method.with_capacity_and_hasher' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.with_capacity_and_hasher' class='fnname'>with_capacity_and_hasher</a>(capacity: <a href='../../primitive.uint.html'>uint</a>, hasher: H) -&gt; <a class='struct' href='../../../std/collections/hashmap/struct.HashMap.html' title='std::collections::hashmap::HashMap'>HashMap</a>&lt;K, V, H&gt;</code></h4>
<div class='docblock'><p>Create an empty HashMap with space for at least <code>capacity</code>
elements, using <code>hasher</code> to hash the keys.</p>

<p>Warning: <code>hasher</code> is normally randomly generated, and
is designed to allow HashMaps to be resistant to attacks that
cause many collisions and very poor performance. Setting it
manually using this function can expose a DoS attack vector.</p>
</div><h4 id='method.reserve' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.reserve' class='fnname'>reserve</a>(&amp;mut self, new_minimum_capacity: <a href='../../primitive.uint.html'>uint</a>)</code></h4>
<div class='docblock'><p>The hashtable will never try to shrink below this size. You can use
this function to reduce reallocations if your hashtable frequently
grows and shrinks by large amounts.</p>

<p>This function has no effect on the operational semantics of the
hashtable, only on performance.</p>
</div><h4 id='method.find_or_insert' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.find_or_insert' class='fnname'>find_or_insert</a>&lt;'a&gt;(&amp;'a mut self, k: K, v: V) -&gt; &amp;'a mut V</code></h4>
<div class='docblock'><p>Return the value corresponding to the key in the map, or insert
and return the value if it doesn&#39;t exist.</p>
</div><h4 id='method.find_or_insert_with' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.find_or_insert_with' class='fnname'>find_or_insert_with</a>&lt;'a&gt;(&amp;'a mut self, k: K, f: |&amp;K| -&gt; V) -&gt; &amp;'a mut V</code></h4>
<div class='docblock'><p>Return the value corresponding to the key in the map, or create,
insert, and return a new value if it doesn&#39;t exist.</p>
</div><h4 id='method.insert_or_update_with' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.insert_or_update_with' class='fnname'>insert_or_update_with</a>&lt;'a&gt;(&amp;'a mut self, k: K, v: V, f: |&amp;K, &amp;mut V|) -&gt; &amp;'a mut V</code></h4>
<div class='docblock'><p>Insert a key-value pair into the map if the key is not already present.
Otherwise, modify the existing value for the key.
Returns the new or modified value for the key.</p>
</div><h4 id='method.find_with_or_insert_with' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.find_with_or_insert_with' class='fnname'>find_with_or_insert_with</a>&lt;'a, A&gt;(&amp;'a mut self, k: K, a: A, found: |&amp;K, &amp;mut V, A|, not_found: |&amp;K, A| -&gt; V) -&gt; &amp;'a mut V</code></h4>
<div class='docblock'><p>Modify and return the value corresponding to the key in the map, or
insert and return a new value if it doesn&#39;t exist.</p>

<p>This method allows for all insertion behaviours of a hashmap;
see methods like <code>insert</code>, <code>find_or_insert</code> and
<code>insert_or_update_with</code> for less general and more friendly
variations of this.</p>

<h1 id="example-1" class='section-header'><a
                           href="#example-1">Example</a></h1><span id='rust-example-raw-1' class='rusttest'>fn main() {
    use std::collections::HashMap;
    
    // map some strings to vectors of strings
    let mut map = HashMap::new();
    map.insert(&quot;a key&quot;, vec![&quot;value&quot;]);
    map.insert(&quot;z key&quot;, vec![&quot;value&quot;]);
    
    let new = vec![&quot;a key&quot;, &quot;b key&quot;, &quot;z key&quot;];
    
    for k in new.move_iter() {
        map.find_with_or_insert_with(
            k, &quot;new value&quot;,
            // if the key does exist either prepend or append this
            // new value based on the first letter of the key.
            |key, already, new| {
                if key.as_slice().starts_with(&quot;z&quot;) {
                    already.unshift(new);
                } else {
                    already.push(new);
                }
            },
            // if the key doesn&#39;t exist in the map yet, add it in
            // the obvious way.
            |_k, v| vec![v]);
    }
    
    assert_eq!(map.len(), 3);
    assert_eq!(map.get(&amp;&quot;a key&quot;), &amp;vec![&quot;value&quot;, &quot;new value&quot;]);
    assert_eq!(map.get(&amp;&quot;b key&quot;), &amp;vec![&quot;new value&quot;]);
    assert_eq!(map.get(&amp;&quot;z key&quot;), &amp;vec![&quot;new value&quot;, &quot;value&quot;]);
}</span><pre id='rust-example-rendered-1' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>HashMap</span>;<span class='comment'>

// map some strings to vectors of strings
</span><span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>map</span> <span class='op'>=</span> <span class='ident'>HashMap</span>::<span class='ident'>new</span>();
<span class='ident'>map</span>.<span class='ident'>insert</span>(<span class='string'>&quot;a key&quot;</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;value&quot;</span>]);
<span class='ident'>map</span>.<span class='ident'>insert</span>(<span class='string'>&quot;z key&quot;</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;value&quot;</span>]);

<span class='kw'>let</span> <span class='ident'>new</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;a key&quot;</span>, <span class='string'>&quot;b key&quot;</span>, <span class='string'>&quot;z key&quot;</span>];

<span class='kw'>for</span> <span class='ident'>k</span> <span class='kw'>in</span> <span class='ident'>new</span>.<span class='ident'>move_iter</span>() {
    <span class='ident'>map</span>.<span class='ident'>find_with_or_insert_with</span>(
        <span class='ident'>k</span>, <span class='string'>&quot;new value&quot;</span>,<span class='comment'>
        // if the key does exist either prepend or append this
        // new value based on the first letter of the key.
        </span><span class='op'>|</span><span class='ident'>key</span>, <span class='ident'>already</span>, <span class='ident'>new</span><span class='op'>|</span> {
            <span class='kw'>if</span> <span class='ident'>key</span>.<span class='ident'>as_slice</span>().<span class='ident'>starts_with</span>(<span class='string'>&quot;z&quot;</span>) {
                <span class='ident'>already</span>.<span class='ident'>unshift</span>(<span class='ident'>new</span>);
            } <span class='kw'>else</span> {
                <span class='ident'>already</span>.<span class='ident'>push</span>(<span class='ident'>new</span>);
            }
        },<span class='comment'>
        // if the key doesn&#39;t exist in the map yet, add it in
        // the obvious way.
        </span><span class='op'>|</span><span class='ident'>_k</span>, <span class='ident'>v</span><span class='op'>|</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='ident'>v</span>]);
}

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>map</span>.<span class='ident'>len</span>(), <span class='number'>3</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>map</span>.<span class='ident'>get</span>(<span class='kw-2'>&amp;</span><span class='string'>&quot;a key&quot;</span>), <span class='kw-2'>&amp;</span><span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;value&quot;</span>, <span class='string'>&quot;new value&quot;</span>]);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>map</span>.<span class='ident'>get</span>(<span class='kw-2'>&amp;</span><span class='string'>&quot;b key&quot;</span>), <span class='kw-2'>&amp;</span><span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;new value&quot;</span>]);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>map</span>.<span class='ident'>get</span>(<span class='kw-2'>&amp;</span><span class='string'>&quot;z key&quot;</span>), <span class='kw-2'>&amp;</span><span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;new value&quot;</span>, <span class='string'>&quot;value&quot;</span>]);
</pre>
</div><h4 id='method.get' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.get' class='fnname'>get</a>&lt;'a&gt;(&amp;'a self, k: &amp;K) -&gt; &amp;'a V</code></h4>
<div class='docblock'><p>Retrieves a value for the given key, failing if the key is not present.</p>
</div><h4 id='method.get_mut' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.get_mut' class='fnname'>get_mut</a>&lt;'a&gt;(&amp;'a mut self, k: &amp;K) -&gt; &amp;'a mut V</code></h4>
<div class='docblock'><p>Retrieves a (mutable) value for the given key, failing if the key is not present.</p>
</div><h4 id='method.contains_key_equiv' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.contains_key_equiv' class='fnname'>contains_key_equiv</a>&lt;Q: <a class='trait' href='../../../std/hash/trait.Hash.html' title='std::hash::Hash'>Hash</a>&lt;S&gt; + <a class='trait' href='../../../std/cmp/trait.Equiv.html' title='std::cmp::Equiv'>Equiv</a>&lt;K&gt;&gt;(&amp;self, key: &amp;Q) -&gt; <a href='../../primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Return true if the map contains a value for the specified key,
using equivalence.</p>
</div><h4 id='method.find_equiv' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.find_equiv' class='fnname'>find_equiv</a>&lt;'a, Q: <a class='trait' href='../../../std/hash/trait.Hash.html' title='std::hash::Hash'>Hash</a>&lt;S&gt; + <a class='trait' href='../../../std/cmp/trait.Equiv.html' title='std::cmp::Equiv'>Equiv</a>&lt;K&gt;&gt;(&amp;'a self, k: &amp;Q) -&gt; <a class='type' href='../../../std/option/type.Option.html' title='std::option::Option'>Option</a>&lt;&amp;'a V&gt;</code></h4>
<div class='docblock'><p>Return the value corresponding to the key in the map, using
equivalence.</p>
</div><h4 id='method.keys' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.keys' class='fnname'>keys</a>&lt;'a&gt;(&amp;'a self) -&gt; <a class='type' href='../../../std/collections/hashmap/type.Keys.html' title='std::collections::hashmap::Keys'>Keys</a>&lt;'a, K, V&gt;</code></h4>
<div class='docblock'><p>An iterator visiting all keys in arbitrary order.
Iterator element type is &amp;&#39;a K.</p>
</div><h4 id='method.values' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.values' class='fnname'>values</a>&lt;'a&gt;(&amp;'a self) -&gt; <a class='type' href='../../../std/collections/hashmap/type.Values.html' title='std::collections::hashmap::Values'>Values</a>&lt;'a, K, V&gt;</code></h4>
<div class='docblock'><p>An iterator visiting all values in arbitrary order.
Iterator element type is &amp;&#39;a V.</p>
</div><h4 id='method.iter' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.iter' class='fnname'>iter</a>&lt;'a&gt;(&amp;'a self) -&gt; <a class='type' href='../../../std/collections/hashmap/type.Entries.html' title='std::collections::hashmap::Entries'>Entries</a>&lt;'a, K, V&gt;</code></h4>
<div class='docblock'><p>An iterator visiting all key-value pairs in arbitrary order.
Iterator element type is (&amp;&#39;a K, &amp;&#39;a V).</p>
</div><h4 id='method.mut_iter' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.mut_iter' class='fnname'>mut_iter</a>&lt;'a&gt;(&amp;'a mut self) -&gt; <a class='type' href='../../../std/collections/hashmap/type.MutEntries.html' title='std::collections::hashmap::MutEntries'>MutEntries</a>&lt;'a, K, V&gt;</code></h4>
<div class='docblock'><p>An iterator visiting all key-value pairs in arbitrary order,
with mutable references to the values.
Iterator element type is (&amp;&#39;a K, &amp;&#39;a mut V).</p>
</div><h4 id='method.move_iter' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.move_iter' class='fnname'>move_iter</a>(self) -&gt; <a class='type' href='../../../std/collections/hashmap/type.MoveEntries.html' title='std::collections::hashmap::MoveEntries'>MoveEntries</a>&lt;K, V&gt;</code></h4>
<div class='docblock'><p>Creates a consuming iterator, that is, one that moves each key-value
pair out of the map in arbitrary order. The map cannot be used after
calling this.</p>
</div></div><h3 class='impl'><a class='stability Experimental' title='Experimental'></a><code>impl&lt;K: <a class='trait' href='../../../std/cmp/trait.Eq.html' title='std::cmp::Eq'>Eq</a> + <a class='trait' href='../../../std/hash/trait.Hash.html' title='std::hash::Hash'>Hash</a>&lt;S&gt;, V: <a class='trait' href='../../../std/clone/trait.Clone.html' title='std::clone::Clone'>Clone</a>, S, H: <a class='trait' href='../../../std/hash/trait.Hasher.html' title='std::hash::Hasher'>Hasher</a>&lt;S&gt;&gt; <a class='struct' href='../../../std/collections/hashmap/struct.HashMap.html' title='std::collections::hashmap::HashMap'>HashMap</a>&lt;K, V, H&gt;</code></h3><div class='impl-methods'><h4 id='method.find_copy' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.find_copy' class='fnname'>find_copy</a>(&amp;self, k: &amp;K) -&gt; <a class='type' href='../../../std/option/type.Option.html' title='std::option::Option'>Option</a>&lt;V&gt;</code></h4>
<div class='docblock'><p>Like <code>find</code>, but returns a copy of the value.</p>
</div><h4 id='method.get_copy' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.get_copy' class='fnname'>get_copy</a>(&amp;self, k: &amp;K) -&gt; V</code></h4>
<div class='docblock'><p>Like <code>get</code>, but returns a copy of the value.</p>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><a class='stability Experimental' title='Experimental'></a><code>impl&lt;K: <a class='trait' href='../../../std/cmp/trait.Eq.html' title='std::cmp::Eq'>Eq</a> + <a class='trait' href='../../../std/hash/trait.Hash.html' title='std::hash::Hash'>Hash</a>&lt;S&gt;, V, S, H: <a class='trait' href='../../../std/hash/trait.Hasher.html' title='std::hash::Hasher'>Hasher</a>&lt;S&gt;&gt; <a class='trait' href='../../../std/collections/trait.Collection.html' title='std::collections::Collection'>Collection</a> for <a class='struct' href='../../../std/collections/hashmap/struct.HashMap.html' title='std::collections::hashmap::HashMap'>HashMap</a>&lt;K, V, H&gt;</code></h3><div class='impl-methods'><h4 id='method.len' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.len' class='fnname'>len</a>(&amp;self) -&gt; <a href='../../primitive.uint.html'>uint</a></code></h4>
<div class='docblock'><p>Return the number of elements in the map</p>
</div><h4 id='method.is_empty' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#tymethod.is_empty' class='fnname'>is_empty</a>(&amp;self) -&gt; <a href='../../primitive.bool.html'>bool</a></code></h4>
</div><h3 class='impl'><a class='stability Experimental' title='Experimental'></a><code>impl&lt;K: <a class='trait' href='../../../std/cmp/trait.Eq.html' title='std::cmp::Eq'>Eq</a> + <a class='trait' href='../../../std/hash/trait.Hash.html' title='std::hash::Hash'>Hash</a>&lt;S&gt;, V, S, H: <a class='trait' href='../../../std/hash/trait.Hasher.html' title='std::hash::Hasher'>Hasher</a>&lt;S&gt;&gt; <a class='trait' href='../../../std/collections/trait.Mutable.html' title='std::collections::Mutable'>Mutable</a> for <a class='struct' href='../../../std/collections/hashmap/struct.HashMap.html' title='std::collections::hashmap::HashMap'>HashMap</a>&lt;K, V, H&gt;</code></h3><div class='impl-methods'><h4 id='method.clear' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.clear' class='fnname'>clear</a>(&amp;mut self)</code></h4>
<div class='docblock'><p>Clear the map, removing all key-value pairs. Keeps the allocated memory
for reuse.</p>
</div></div><h3 class='impl'><a class='stability Experimental' title='Experimental'></a><code>impl&lt;K: <a class='trait' href='../../../std/cmp/trait.Eq.html' title='std::cmp::Eq'>Eq</a> + <a class='trait' href='../../../std/hash/trait.Hash.html' title='std::hash::Hash'>Hash</a>&lt;S&gt;, V, S, H: <a class='trait' href='../../../std/hash/trait.Hasher.html' title='std::hash::Hasher'>Hasher</a>&lt;S&gt;&gt; <a class='trait' href='../../../std/collections/trait.Map.html' title='std::collections::Map'>Map</a>&lt;K, V&gt; for <a class='struct' href='../../../std/collections/hashmap/struct.HashMap.html' title='std::collections::hashmap::HashMap'>HashMap</a>&lt;K, V, H&gt;</code></h3><div class='impl-methods'><h4 id='method.find' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.find' class='fnname'>find</a>&lt;'a&gt;(&amp;'a self, k: &amp;K) -&gt; <a class='type' href='../../../std/option/type.Option.html' title='std::option::Option'>Option</a>&lt;&amp;'a V&gt;</code></h4>
<h4 id='method.contains_key' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.contains_key' class='fnname'>contains_key</a>(&amp;self, k: &amp;K) -&gt; <a href='../../primitive.bool.html'>bool</a></code></h4>
</div><h3 class='impl'><a class='stability Experimental' title='Experimental'></a><code>impl&lt;K: <a class='trait' href='../../../std/cmp/trait.Eq.html' title='std::cmp::Eq'>Eq</a> + <a class='trait' href='../../../std/hash/trait.Hash.html' title='std::hash::Hash'>Hash</a>&lt;S&gt;, V, S, H: <a class='trait' href='../../../std/hash/trait.Hasher.html' title='std::hash::Hasher'>Hasher</a>&lt;S&gt;&gt; <a class='trait' href='../../../std/collections/trait.MutableMap.html' title='std::collections::MutableMap'>MutableMap</a>&lt;K, V&gt; for <a class='struct' href='../../../std/collections/hashmap/struct.HashMap.html' title='std::collections::hashmap::HashMap'>HashMap</a>&lt;K, V, H&gt;</code></h3><div class='impl-methods'><h4 id='method.find_mut' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.find_mut' class='fnname'>find_mut</a>&lt;'a&gt;(&amp;'a mut self, k: &amp;K) -&gt; <a class='type' href='../../../std/option/type.Option.html' title='std::option::Option'>Option</a>&lt;&amp;'a mut V&gt;</code></h4>
<h4 id='method.swap' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.swap' class='fnname'>swap</a>(&amp;mut self, k: K, v: V) -&gt; <a class='type' href='../../../std/option/type.Option.html' title='std::option::Option'>Option</a>&lt;V&gt;</code></h4>
<h4 id='method.pop' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.pop' class='fnname'>pop</a>(&amp;mut self, k: &amp;K) -&gt; <a class='type' href='../../../std/option/type.Option.html' title='std::option::Option'>Option</a>&lt;V&gt;</code></h4>
<h4 id='method.insert' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#tymethod.insert' class='fnname'>insert</a>&lt;K, V&gt;(&amp;mut self, key: K, value: V) -&gt; <a href='../../primitive.bool.html'>bool</a></code></h4>
<h4 id='method.remove' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#tymethod.remove' class='fnname'>remove</a>&lt;K, V&gt;(&amp;mut self, key: &amp;K) -&gt; <a href='../../primitive.bool.html'>bool</a></code></h4>
</div><h3 class='impl'><a class='stability Experimental' title='Experimental'></a><code>impl&lt;K: <a class='trait' href='../../../std/cmp/trait.Eq.html' title='std::cmp::Eq'>Eq</a> + <a class='trait' href='../../../std/hash/trait.Hash.html' title='std::hash::Hash'>Hash</a>&lt;S&gt;, V: <a class='trait' href='../../../std/cmp/trait.PartialEq.html' title='std::cmp::PartialEq'>PartialEq</a>, S, H: <a class='trait' href='../../../std/hash/trait.Hasher.html' title='std::hash::Hasher'>Hasher</a>&lt;S&gt;&gt; <a class='trait' href='../../../std/cmp/trait.PartialEq.html' title='std::cmp::PartialEq'>PartialEq</a> for <a class='struct' href='../../../std/collections/hashmap/struct.HashMap.html' title='std::collections::hashmap::HashMap'>HashMap</a>&lt;K, V, H&gt;</code></h3><div class='impl-methods'><h4 id='method.eq' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.eq' class='fnname'>eq</a>(&amp;self, other: &amp;<a class='struct' href='../../../std/collections/hashmap/struct.HashMap.html' title='std::collections::hashmap::HashMap'>HashMap</a>&lt;K, V, H&gt;) -&gt; <a href='../../primitive.bool.html'>bool</a></code></h4>
<h4 id='method.ne' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#tymethod.ne' class='fnname'>ne</a>(&amp;self, other: &amp;Self) -&gt; <a href='../../primitive.bool.html'>bool</a></code></h4>
</div><h3 class='impl'><a class='stability Experimental' title='Experimental'></a><code>impl&lt;K: <a class='trait' href='../../../std/cmp/trait.Eq.html' title='std::cmp::Eq'>Eq</a> + <a class='trait' href='../../../std/hash/trait.Hash.html' title='std::hash::Hash'>Hash</a>&lt;S&gt;, V: <a class='trait' href='../../../std/cmp/trait.Eq.html' title='std::cmp::Eq'>Eq</a>, S, H: <a class='trait' href='../../../std/hash/trait.Hasher.html' title='std::hash::Hasher'>Hasher</a>&lt;S&gt;&gt; <a class='trait' href='../../../std/cmp/trait.Eq.html' title='std::cmp::Eq'>Eq</a> for <a class='struct' href='../../../std/collections/hashmap/struct.HashMap.html' title='std::collections::hashmap::HashMap'>HashMap</a>&lt;K, V, H&gt;</code></h3><div class='impl-methods'></div><h3 class='impl'><a class='stability Experimental' title='Experimental'></a><code>impl&lt;K: <a class='trait' href='../../../std/cmp/trait.Eq.html' title='std::cmp::Eq'>Eq</a> + <a class='trait' href='../../../std/hash/trait.Hash.html' title='std::hash::Hash'>Hash</a>&lt;S&gt; + <a class='trait' href='../../../std/fmt/trait.Show.html' title='std::fmt::Show'>Show</a>, V: <a class='trait' href='../../../std/fmt/trait.Show.html' title='std::fmt::Show'>Show</a>, S, H: <a class='trait' href='../../../std/hash/trait.Hasher.html' title='std::hash::Hasher'>Hasher</a>&lt;S&gt;&gt; <a class='trait' href='../../../std/fmt/trait.Show.html' title='std::fmt::Show'>Show</a> for <a class='struct' href='../../../std/collections/hashmap/struct.HashMap.html' title='std::collections::hashmap::HashMap'>HashMap</a>&lt;K, V, H&gt;</code></h3><div class='impl-methods'><h4 id='method.fmt' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.fmt' class='fnname'>fmt</a>(&amp;self, f: &amp;mut <a class='struct' href='../../../std/fmt/struct.Formatter.html' title='std::fmt::Formatter'>Formatter</a>) -&gt; <a class='type' href='../../../std/fmt/type.Result.html' title='std::fmt::Result'>Result</a></code></h4>
</div><h3 class='impl'><a class='stability Experimental' title='Experimental'></a><code>impl&lt;K: <a class='trait' href='../../../std/cmp/trait.Eq.html' title='std::cmp::Eq'>Eq</a> + <a class='trait' href='../../../std/hash/trait.Hash.html' title='std::hash::Hash'>Hash</a>&lt;S&gt;, V, S, H: <a class='trait' href='../../../std/hash/trait.Hasher.html' title='std::hash::Hasher'>Hasher</a>&lt;S&gt; + <a class='trait' href='../../../std/default/trait.Default.html' title='std::default::Default'>Default</a>&gt; <a class='trait' href='../../../std/default/trait.Default.html' title='std::default::Default'>Default</a> for <a class='struct' href='../../../std/collections/hashmap/struct.HashMap.html' title='std::collections::hashmap::HashMap'>HashMap</a>&lt;K, V, H&gt;</code></h3><div class='impl-methods'><h4 id='method.default' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.default' class='fnname'>default</a>() -&gt; <a class='struct' href='../../../std/collections/hashmap/struct.HashMap.html' title='std::collections::hashmap::HashMap'>HashMap</a>&lt;K, V, H&gt;</code></h4>
</div><h3 class='impl'><a class='stability Experimental' title='Experimental'></a><code>impl&lt;K: <a class='trait' href='../../../std/cmp/trait.Eq.html' title='std::cmp::Eq'>Eq</a> + <a class='trait' href='../../../std/hash/trait.Hash.html' title='std::hash::Hash'>Hash</a>&lt;S&gt;, V, S, H: <a class='trait' href='../../../std/hash/trait.Hasher.html' title='std::hash::Hasher'>Hasher</a>&lt;S&gt; + <a class='trait' href='../../../std/default/trait.Default.html' title='std::default::Default'>Default</a>&gt; <a class='trait' href='../../../std/iter/trait.FromIterator.html' title='std::iter::FromIterator'>FromIterator</a>&lt;<a href='../../primitive.tuple.html'>(K, V)</a>&gt; for <a class='struct' href='../../../std/collections/hashmap/struct.HashMap.html' title='std::collections::hashmap::HashMap'>HashMap</a>&lt;K, V, H&gt;</code></h3><div class='impl-methods'><h4 id='method.from_iter' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.from_iter' class='fnname'>from_iter</a>&lt;T: <a class='trait' href='../../../std/iter/trait.Iterator.html' title='std::iter::Iterator'>Iterator</a>&lt;<a href='../../primitive.tuple.html'>(K, V)</a>&gt;&gt;(iter: T) -&gt; <a class='struct' href='../../../std/collections/hashmap/struct.HashMap.html' title='std::collections::hashmap::HashMap'>HashMap</a>&lt;K, V, H&gt;</code></h4>
</div><h3 class='impl'><a class='stability Experimental' title='Experimental'></a><code>impl&lt;K: <a class='trait' href='../../../std/cmp/trait.Eq.html' title='std::cmp::Eq'>Eq</a> + <a class='trait' href='../../../std/hash/trait.Hash.html' title='std::hash::Hash'>Hash</a>&lt;S&gt;, V, S, H: <a class='trait' href='../../../std/hash/trait.Hasher.html' title='std::hash::Hasher'>Hasher</a>&lt;S&gt; + <a class='trait' href='../../../std/default/trait.Default.html' title='std::default::Default'>Default</a>&gt; <a class='trait' href='../../../std/iter/trait.Extendable.html' title='std::iter::Extendable'>Extendable</a>&lt;<a href='../../primitive.tuple.html'>(K, V)</a>&gt; for <a class='struct' href='../../../std/collections/hashmap/struct.HashMap.html' title='std::collections::hashmap::HashMap'>HashMap</a>&lt;K, V, H&gt;</code></h3><div class='impl-methods'><h4 id='method.extend' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.extend' class='fnname'>extend</a>&lt;T: <a class='trait' href='../../../std/iter/trait.Iterator.html' title='std::iter::Iterator'>Iterator</a>&lt;<a href='../../primitive.tuple.html'>(K, V)</a>&gt;&gt;(&amp;mut self, iter: T)</code></h4>
</div><h3 id='derived_implementations'>Derived Implementations </h3><h3 class='impl'><a class='stability Experimental' title='Experimental'></a><code>impl&lt;K: <a class='trait' href='../../../std/clone/trait.Clone.html' title='std::clone::Clone'>Clone</a>, V: <a class='trait' href='../../../std/clone/trait.Clone.html' title='std::clone::Clone'>Clone</a>, H: <a class='trait' href='../../../std/clone/trait.Clone.html' title='std::clone::Clone'>Clone</a>&gt; <a class='trait' href='../../../std/clone/trait.Clone.html' title='std::clone::Clone'>Clone</a> for <a class='struct' href='../../../std/collections/hashmap/struct.HashMap.html' title='std::collections::hashmap::HashMap'>HashMap</a>&lt;K, V, H&gt;</code></h3><div class='impl-methods'><h4 id='method.clone' class='method'><a class='stability Unstable' title='Unstable'></a><code>fn <a href='#method.clone' class='fnname'>clone</a>(&amp;self) -&gt; <a class='struct' href='../../../std/collections/hashmap/struct.HashMap.html' title='std::collections::hashmap::HashMap'>HashMap</a>&lt;K, V, H&gt;</code></h4>
<h4 id='method.clone_from' class='method'><a class='stability Experimental' title='Experimental: this function is mostly unused'></a><code>fn <a href='#tymethod.clone_from' class='fnname'>clone_from</a>(&amp;mut self, source: &amp;Self)</code></h4>
</div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&larrb;</dt>
                <dd>Move up in search results</dd>
                <dt>&rarrb;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code> (or <code>str</code>), <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>

    

    <script>
        window.rootPath = "../../../";
        window.currentCrate = "std";
        window.playgroundUrl = "http://play.rust-lang.org/";
    </script>
    <script src="../../../jquery.js"></script>
    <script src="../../../main.js"></script>
    <script src="../../../playpen.js"></script>
    <script async src="../../../search-index.js"></script>
</body>
</html>