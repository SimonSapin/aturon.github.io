<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="generator" content="rustdoc">
    <title>The Rust Guide</title>

    <link rel="stylesheet" type="text/css" href="rust.css">

    <link rel="shortcut icon" href="http://www.rust-lang.org/favicon.ico">


</head>
<body>
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="versioninfo">
  <img src="http://www.rust-lang.org/logos/rust-logo-32x32-blk.png" width="32" height="32" alt><br>
  <span class="white-sticker"><a href="http://rust-lang.org">Rust</a> 0.12.0-pre</span><br>
  <a href="http://github.com/rust-lang/rust/commit/2c50add48273cf1ef44b47eceb5d9446fc81ce41"
    class="hash white-sticker"></a>
</div>


    <h1 class="title">The Rust Guide</h1>
    <nav id="TOC"><ul>
<li><a href="#welcome!">1 Welcome!</a><ul></ul></li>
<li><a href="#installing-rust">2 Installing Rust</a><ul></ul></li>
<li><a href="#hello,-world!">3 Hello, world!</a><ul></ul></li>
<li><a href="#hello,-cargo!">4 Hello, Cargo!</a><ul></ul></li>
<li><a href="#variable-bindings">5 Variable bindings</a><ul></ul></li>
<li><a href="#if">6 If</a><ul>
<li><a href="#expressions-vs.-statements">6.1 Expressions vs. Statements</a><ul></ul></li></ul></li>
<li><a href="#functions">7 Functions</a><ul></ul></li>
<li><a href="#comments">8 Comments</a><ul></ul></li>
<li><a href="#compound-data-types">9 Compound Data Types</a><ul>
<li><a href="#tuples">9.1 Tuples</a><ul></ul></li>
<li><a href="#structs">9.2 Structs</a><ul></ul></li>
<li><a href="#tuple-structs-and-newtypes">9.3 Tuple Structs and Newtypes</a><ul></ul></li>
<li><a href="#enums">9.4 Enums</a><ul></ul></li></ul></li>
<li><a href="#match">10 Match</a><ul></ul></li>
<li><a href="#looping">11 Looping</a><ul>
<li><a href="#for">11.1 <code>for</code></a><ul></ul></li>
<li><a href="#while">11.2 <code>while</code></a><ul></ul></li>
<li><a href="#ending-iteration-early">11.3 Ending iteration early</a><ul></ul></li></ul></li>
<li><a href="#standard-input">12 Standard Input</a><ul></ul></li>
<li><a href="#guessing-game">13 Guessing Game</a><ul>
<li><a href="#set-up">13.1 Set up</a><ul></ul></li>
<li><a href="#processing-a-guess">13.2 Processing a Guess</a><ul></ul></li>
<li><a href="#generating-a-secret-number">13.3 Generating a secret number</a><ul></ul></li>
<li><a href="#comparing-guesses">13.4 Comparing guesses</a><ul></ul></li>
<li><a href="#looping-1">13.5 Looping</a><ul></ul></li>
<li><a href="#complete!">13.6 Complete!</a><ul></ul></li></ul></li>
<li><a href="#iterators">14 iterators</a><ul></ul></li>
<li><a href="#lambdas">15 Lambdas</a><ul></ul></li>
<li><a href="#testing">16 Testing</a><ul></ul></li>
<li><a href="#crates-and-modules">17 Crates and Modules</a><ul></ul></li>
<li><a href="#generics">18 Generics</a><ul></ul></li>
<li><a href="#traits">19 Traits</a><ul></ul></li>
<li><a href="#operators-and-built-in-traits">20 Operators and built-in Traits</a><ul></ul></li>
<li><a href="#ownership-and-lifetimes">21 Ownership and Lifetimes</a><ul></ul></li>
<li><a href="#tasks">22 Tasks</a><ul></ul></li>
<li><a href="#macros">23 Macros</a><ul></ul></li>
<li><a href="#unsafe">24 Unsafe</a><ul></ul></li></ul></nav><div style="border: 2px solid red; padding:5px;">
This guide is a work in progress. Until it is ready, we highly recommend that
you read the <a href="tutorial.html">Tutorial</a> instead. This work-in-progress Guide is being
displayed here in line with Rust's open development policy. Please open any
issues you find as usual.
</div>

<h1 id="welcome!" class='section-header'><a
                           href="#welcome!">1 Welcome!</a></h1>
<p>Hey there! Welcome to the Rust guide. This is the place to be if you&#39;d like to
learn how to program in Rust. Rust is a systems programming language with a
focus on &quot;high-level, bare-metal programming&quot;: the lowest level control a
programming language can give you, but with zero-cost, higher level
abstractions, because people aren&#39;t computers. We really think Rust is
something special, and we hope you do too.</p>

<p>To show you how to get going with Rust, we&#39;re going to write the traditional
&quot;Hello, World!&quot; program. Next, we&#39;ll introduce you to a tool that&#39;s useful for
writing real-world Rust programs and libraries: &quot;Cargo.&quot; After that, we&#39;ll talk
about the basics of Rust, write a little program to try them out, and then learn
more advanced things.</p>

<p>Sound good? Let&#39;s go!</p>

<h1 id="installing-rust" class='section-header'><a
                           href="#installing-rust">2 Installing Rust</a></h1>
<p>The first step to using Rust is to install it! There are a number of ways to
install Rust, but the easiest is to use the the <code>rustup</code> script. If you&#39;re on
Linux or a Mac, all you need to do is this (note that you don&#39;t need to type
in the <code>$</code>s, they just indicate the start of each command):</p>
<span id='rust-example-raw-0' class='rusttest'>fn main() {
    $ curl -s http://www.rust-lang.org/rustup.sh | sudo sh
}</span><pre id='rust-example-rendered-0' class='rust '>
$ <span class='ident'>curl</span> <span class='op'>-</span><span class='ident'>s</span> <span class='ident'>http</span>:<span class='comment'>//www.rust-lang.org/rustup.sh | sudo sh</span>
</pre>

<p>(If you&#39;re concerned about <code>curl | sudo sh</code>, please keep reading. Disclaimer
below.)</p>

<p>If you&#39;re on Windows, please <a href="http://static.rust-lang.org/dist/rust-nightly-install.exe">download this .exe and run
it</a>.</p>

<p>If you decide you don&#39;t want Rust anymore, we&#39;ll be a bit sad, but that&#39;s okay.
Not every programming language is great for everyone. Just pass an argument to
the script:</p>
<span id='rust-example-raw-1' class='rusttest'>fn main() {
    $ curl -s http://www.rust-lang.org/rustup.sh | sudo sh -s -- --uninstall
}</span><pre id='rust-example-rendered-1' class='rust '>
$ <span class='ident'>curl</span> <span class='op'>-</span><span class='ident'>s</span> <span class='ident'>http</span>:<span class='comment'>//www.rust-lang.org/rustup.sh | sudo sh -s -- --uninstall</span>
</pre>

<p>If you used the Windows installer, just re-run the <code>.exe</code> and it will give you
an uninstall option.</p>

<p>You can re-run this script any time you want to update Rust. Which, at this
point, is often. Rust is still pre-1.0, and so people assume that you&#39;re using
a very recent Rust.</p>

<p>This brings me to one other point: some people, and somewhat rightfully so, get
very upset when we tell you to <code>curl | sudo sh</code>. And they should be! Basically,
when you do this, you are trusting that the good people who maintain Rust
aren&#39;t going to hack your computer and do bad things. That&#39;s a good instinct!
If you&#39;re one of those people, please check out the documentation on <a href="https://github.com/rust-lang/rust#building-from-source">building
Rust from Source</a>, or
<a href="http://www.rust-lang.org/install.html">the official binary downloads</a>. And we
promise that this method will not be the way to install Rust forever: it&#39;s just
the easiest way to keep people updated while Rust is in its alpha state.</p>

<p>Oh, we should also mention the officially supported platforms:</p>

<ul>
<li>Windows (7, 8, Server 2008 R2), x86 only</li>
<li>Linux (2.6.18 or later, various distributions), x86 and x86-64</li>
<li>OSX 10.7 (Lion) or greater, x86 and x86-64</li>
</ul>

<p>We extensively test Rust on these platforms, and a few others, too, like
Android. But these are the ones most likely to work, as they have the most
testing.</p>

<p>Finally, a comment about Windows. Rust considers Windows to be a first-class
platform upon release, but if we&#39;re honest, the Windows experience isn&#39;t as
integrated as the Linux/OS X experience is. We&#39;re working on it! If anything
does not work, it is a bug. Please let us know if that happens. Each and every
commit is tested against Windows just like any other platform.</p>

<p>If you&#39;ve got Rust installed, you can open up a shell, and type this:</p>
<span id='rust-example-raw-2' class='rusttest'>fn main() {
    $ rustc --version
}</span><pre id='rust-example-rendered-2' class='rust '>
$ <span class='ident'>rustc</span> <span class='op'>-</span><span class='op'>-</span><span class='ident'>version</span>
</pre>

<p>You should see some output that looks something like this:</p>
<span id='rust-example-raw-3' class='rusttest'>fn main() {
    rustc 0.12.0-pre (443a1cd 2014-06-08 14:56:52 -0700)
}</span><pre id='rust-example-rendered-3' class='rust '>
<span class='ident'>rustc</span> <span class='number'>0.12</span>.<span class='number'>0</span><span class='op'>-</span><span class='ident'>pre</span> (<span class='number'>443</span><span class='ident'>a1cd</span> <span class='number'>2014</span><span class='op'>-</span><span class='number'>06</span><span class='op'>-</span><span class='number'>08</span> <span class='number'>14</span>:<span class='number'>56</span>:<span class='number'>52</span> <span class='op'>-</span><span class='number'>0700</span>)
</pre>

<p>If you did, Rust has been installed successfully! Congrats!</p>

<p>If not, there are a number of places where you can get help. The easiest is
<a href="irc://irc.mozilla.org/#rust">the #rust IRC channel on irc.mozilla.org</a>, which
you can access through
<a href="http://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">Mibbit</a>. Click
that link, and you&#39;ll be chatting with other Rustaceans (a silly nickname we
call ourselves), and we can help you out. Other great resources include <a href="https://mail.mozilla.org/listinfo/rust-dev">our
mailing list</a>, <a href="http://www.reddit.com/r/rust">the /r/rust
subreddit</a>, and <a href="http://stackoverflow.com/questions/tagged/rust">Stack
Overflow</a>.</p>

<h1 id="hello,-world!" class='section-header'><a
                           href="#hello,-world!">3 Hello, world!</a></h1>
<p>Now that you have Rust installed, let&#39;s write your first Rust program. It&#39;s
traditional to make your first program in any new language one that prints the
text &quot;Hello, world!&quot; to the screen. The nice thing about starting with such a
simple program is that you can verify that your compiler isn&#39;t just installed,
but also working properly. And printing information to the screen is a pretty
common thing to do.</p>

<p>The first thing that we need to do is make a file to put our code in. I like
to make a projects directory in my home directory, and keep all my projects
there. Rust does not care where your code lives.</p>

<p>This actually leads to one other concern we should address: this tutorial will
assume that you have basic familiarity with the command-line. Rust does not
require that you know a whole ton about the command line, but until the
language is in a more finished state, IDE support is spotty. Rust makes no
specific demands on your editing tooling, or where your code lives.</p>

<p>With that said, let&#39;s make a directory in our projects directory.</p>

<pre><code class="language-{bash}">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world</code></pre>

<p>If you&#39;re on Windows and not using PowerShell, the <code>~</code> may not work. Consult
the documentation for your shell for more details.</p>

<p>Let&#39;s make a new source file next. I&#39;m going to use the syntax <code>editor
filename</code> to represent editing a file in these examples, but you should use
whatever method you want. We&#39;ll call our file <code>hello_world.rs</code>:</p>

<pre><code class="language-{bash}">$ editor hello_world.rs</code></pre>

<p>Rust files always end in a <code>.rs</code> extension. If you&#39;re using more than one word
in your file name, use an underscore. <code>hello_world.rs</code> versus <code>goodbye.rs</code>.</p>

<p>Now that you&#39;ve got your file open, type this in:</p>
<span id='rust-example-raw-4' class='rusttest'>fn main() {
    println!(&quot;Hello, world&quot;);
}</span><pre id='rust-example-rendered-4' class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello, world&quot;</span>);
}
</pre>

<p>Save the file, and then type this into your terminal window:</p>

<pre><code class="language-{bash}">$ rustc hello_world.rs
$ ./hello_world # or hello_world.exe on Windows
Hello, world</code></pre>

<p>Success! Let&#39;s go over what just happened in detail.</p>
<span id='rust-example-raw-5' class='rusttest'>fn main() {

}</span><pre id='rust-example-rendered-5' class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {

}
</pre>

<p>These two lines define a <strong>function</strong> in Rust. The <code>main</code> function is special:
it&#39;s the beginning of every Rust program. The first line says &quot;I&#39;m declaring a
function named <code>main</code>, which takes no arguments and returns nothing.&quot; If there
were arguments, they would go inside the parentheses (<code>(</code> and <code>)</code>), and because
we aren&#39;t returning anything from this function, we&#39;ve dropped that notation
entirely.  We&#39;ll get to it later.</p>

<p>You&#39;ll also note that the function is wrapped in curly braces (<code>{</code> and <code>}</code>).
Rust requires these around all function bodies. It is also considered good
style to put the opening curly brace on the same line as the function
declaration, with one space in between.</p>

<p>Next up is this line:</p>
<span id='rust-example-raw-6' class='rusttest'>fn main() {
        println!(&quot;Hello, world&quot;);
}</span><pre id='rust-example-rendered-6' class='rust '>
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello, world&quot;</span>);
</pre>

<p>This line does all of the work in our little program. There are a number of
details that are important here. The first is that it&#39;s indented with four
spaces, not tabs. Please configure your editor of choice to insert four spaces
with the tab key. We provide some sample configurations for various editors
<a href="https://github.com/rust-lang/rust/tree/master/src/etc">here</a>.</p>

<p>The second point is the <code>println!()</code> part. This is calling a Rust <strong>macro</strong>,
which is how metaprogramming is done in Rust. If it were a function instead, it
would look like this: <code>println()</code>. For our purposes, we don&#39;t need to worry
about this difference. Just know that sometimes, you&#39;ll see a <code>!</code>, and that
means that you&#39;re calling a macro instead of a normal function. One last thing
to mention: Rust&#39;s macros are significantly different than C macros, if you&#39;ve
used those. Don&#39;t be scared of using macros. We&#39;ll get to the details
eventually, you&#39;ll just have to trust us for now.</p>

<p>Next, <code>&quot;Hello, world&quot;</code> is a <strong>string</strong>. Strings are a surprisingly complicated
topic in a systems programming language, and this is a <strong>statically allocated</strong>
string. We will talk more about different kinds of allocation later. We pass
this string as an argument to <code>println!</code>, which prints the string to the
screen. Easy enough!</p>

<p>Finally, the line ends with a semicolon (<code>;</code>). Rust is an <strong>expression
oriented</strong> language, which means that most things are expressions. The <code>;</code> is
used to indicate that this expression is over, and the next one is ready to
begin. Most lines of Rust code end with a <code>;</code>. We will cover this in-depth
later in the tutorial.</p>

<p>Finally, actually <strong>compiling</strong> and <strong>running</strong> our program. We can compile
with our compiler, <code>rustc</code>, by passing it the name of our source file:</p>

<pre><code class="language-{bash}">$ rustc hello_world.rs</code></pre>

<p>This is similar to <code>gcc</code> or <code>clang</code>, if you come from a C or C++ background. Rust
will output a binary executable. You can see it with <code>ls</code>:</p>

<pre><code class="language-{bash}">$ ls
hello_world  hello_world.rs</code></pre>

<p>Or on Windows:</p>

<pre><code class="language-{bash}">$ dir
hello_world.exe  hello_world.rs</code></pre>

<p>There are now two files: our source code, with the <code>.rs</code> extension, and the
executable (<code>hello_world.exe</code> on Windows, <code>hello_world</code> everywhere else)</p>

<pre><code class="language-{bash}">$ ./hello_world  # or hello_world.exe on Windows</code></pre>

<p>This prints out our <code>Hello, world!</code> text to our terminal.</p>

<p>If you come from a dynamically typed language like Ruby, Python, or JavaScript,
you may not be used to these two steps being separate. Rust is an
<strong>ahead-of-time compiled language</strong>, which means that you can compile a
program, give it to someone else, and they don&#39;t need to have Rust installed.
If you give someone a <code>.rb</code> or <code>.py</code> or <code>.js</code> file, they need to have
Ruby/Python/JavaScript installed, but you just need one command to both compile
and run your program. Everything is a tradeoff in language design, and Rust has
made its choice.</p>

<p>Congratulations! You have officially written a Rust program. That makes you a
Rust programmer! Welcome.</p>

<p>Next, I&#39;d like to introduce you to another tool, Cargo, which is used to write
real-world Rust programs. Just using <code>rustc</code> is nice for simple things, but as
your project grows, you&#39;ll want something to help you manage all of the options
that it has, and to make it easy to share your code with other people and
projects.</p>

<h1 id="hello,-cargo!" class='section-header'><a
                           href="#hello,-cargo!">4 Hello, Cargo!</a></h1>
<p><a href="http://crates.io">Cargo</a> is a tool that Rustaceans use to help manage their
Rust projects. Cargo is currently in an alpha state, just like Rust, and so it
is still a work in progress. However, it is already good enough to use for many
Rust projects, and so it is assumed that Rust projects will use Cargo from the
beginning.</p>

<p>Cargo manages three things: building your code, downloading the dependencies
your code needs, and building the dependencies your code needs.  At first, your
program doesn&#39;t have any dependencies, so we&#39;ll only be using the first part of
its functionality. Eventually, we&#39;ll add more. Since we started off by using
Cargo, it&#39;ll be easy to add later.</p>

<p>Let&#39;s convert Hello World to Cargo. The first thing we need to do to begin
using Cargo is to install Cargo. Luckily for us, the script we ran to install
Rust includes Cargo by default. If you installed Rust some other way, you may
want to <a href="https://github.com/rust-lang/cargo#installing-cargo-from-nightlies">check the Cargo
README</a>
for specific instructions about installing it.</p>

<p>To Cargo-ify our project, we need to do two things: Make a <code>Cargo.toml</code>
configuration file, and put our source file in the right place. Let&#39;s
do that part first:</p>

<pre><code class="language-{bash}">$ mkdir src
$ mv hello_world.rs src/hello_world.rs</code></pre>

<p>Cargo expects your source files to live inside a <code>src</code> directory. That leaves
the top level for other things, like READMEs, licence information, and anything
not related to your code. Cargo helps us keep our projects nice and tidy. A
place for everything, and everything in its place.</p>

<p>Next, our configuration file:</p>

<pre><code class="language-{bash}">$ editor Cargo.toml</code></pre>

<p>Make sure to get this name right: you need the capital <code>C</code>!</p>

<p>Put this inside:</p>
<span id='rust-example-raw-7' class='rusttest'>fn main() {
    [package]
    
    name = &quot;hello_world&quot;
    version = &quot;0.1.0&quot;
    authors = [ &quot;someone@example.com&quot; ]
    
    [[bin]]
    
    name = &quot;hello_world&quot;
}</span><pre id='rust-example-rendered-7' class='rust '>
[<span class='ident'>package</span>]

<span class='ident'>name</span> <span class='op'>=</span> <span class='string'>&quot;hello_world&quot;</span>
<span class='ident'>version</span> <span class='op'>=</span> <span class='string'>&quot;0.1.0&quot;</span>
<span class='ident'>authors</span> <span class='op'>=</span> [ <span class='string'>&quot;someone@example.com&quot;</span> ]

[[<span class='ident'>bin</span>]]

<span class='ident'>name</span> <span class='op'>=</span> <span class='string'>&quot;hello_world&quot;</span>
</pre>

<p>This file is in the <a href="https://github.com/toml-lang/toml">TOML</a> format. Let&#39;s let
it explain itself to you:</p>

<blockquote>
<p>TOML aims to be a minimal configuration file format that&#39;s easy to read due
to obvious semantics. TOML is designed to map unambiguously to a hash table.
TOML should be easy to parse into data structures in a wide variety of
languages.</p>
</blockquote>

<p>TOML is very similar to INI, but with some extra goodies.</p>

<p>Anyway, there are two <strong>table</strong>s in this file: <code>package</code> and <code>bin</code>. The first
tells Cargo metadata about your package. The second tells Cargo that we&#39;re
interested in building a binary, not a library (though we could do both!), as
well as what it is named.</p>

<p>Once you have this file in place, we should be ready to build! Try this:</p>

<pre><code class="language-{bash}">$ cargo build
   Compiling hello_world v0.1.0 (file:/home/yourname/projects/hello_world)
$ ./target/hello_world
Hello, world!</code></pre>

<p>Bam! We build our project with <code>cargo build</code>, and run it with
<code>./target/hello_world</code>. This hasn&#39;t bought us a whole lot over our simple use
of <code>rustc</code>, but think about the future: when our project has more than one
file, we would need to call <code>rustc</code> twice, and pass it a bunch of options to
tell it to build everything together. With Cargo, as our project grows, we can
just <code>cargo build</code> and it&#39;ll work the right way.</p>

<p>That&#39;s it! We&#39;ve successfully built <code>hello_world</code> with Cargo. Even though our
program is simple, it&#39;s using much of the real tooling that you&#39;ll use for the
rest of your Rust career.</p>

<p>Now that you&#39;ve got the tools down, let&#39;s actually learn more about the Rust
language itself. These are the basics that will serve you well through the rest
of your time with Rust.</p>

<h1 id="variable-bindings" class='section-header'><a
                           href="#variable-bindings">5 Variable bindings</a></h1>
<p>The first thing we&#39;ll learn about are &#39;variable bindings.&#39; They look like this:</p>
<span id='rust-example-raw-8' class='rusttest'>fn main() {
    let x = 5i;
}</span><pre id='rust-example-rendered-8' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5i</span>;
</pre>

<p>In many languages, this is called a &#39;variable.&#39; But Rust&#39;s variable bindings
have a few tricks up their sleeves. Rust has a very powerful feature called
&#39;pattern matching&#39; that we&#39;ll get into detail with later, but the left
hand side of a <code>let</code> expression is a full pattern, not just a variable name.
This means we can do things like:</p>
<span id='rust-example-raw-9' class='rusttest'>fn main() {
    let (x, y) = (1i, 2i);
}</span><pre id='rust-example-rendered-9' class='rust '>
<span class='kw'>let</span> (<span class='ident'>x</span>, <span class='ident'>y</span>) <span class='op'>=</span> (<span class='number'>1i</span>, <span class='number'>2i</span>);
</pre>

<p>After this expression is evaluated, <code>x</code> will be one, and <code>y</code> will be two.
Patterns are really powerful, but this is about all we can do with them so far.
So let&#39;s just keep this in the back of our minds as we go forward.</p>

<p>By the way, in these examples, <code>i</code> indicates that the number is an integer.</p>

<p>Rust is a statically typed language, which means that we specify our types up
front. So why does our first example compile? Well, Rust has this thing called
&quot;<a href="http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system">Hindley-Milner type
inference</a>&quot;,
named after some really smart type theorists. If you clicked that link, don&#39;t
be scared: what this means for you is that Rust will attempt to infer the types
in your program, and it&#39;s pretty good at it. If it can infer the type, Rust
doesn&#39;t require you to actually type it out.</p>

<p>We can add the type if we want to. Types come after a colon (<code>:</code>):</p>
<span id='rust-example-raw-10' class='rusttest'>fn main() {
    let x: int = 5;
}</span><pre id='rust-example-rendered-10' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>int</span> <span class='op'>=</span> <span class='number'>5</span>;
</pre>

<p>If I asked you to read this out loud to the rest of the class, you&#39;d say &quot;<code>x</code>
is a binding with the type <code>int</code> and the value <code>five</code>.&quot;</p>

<p>By default, bindings are <strong>immutable</strong>. This code will not compile:</p>
<span id='rust-example-raw-11' class='rusttest'>fn main() {
    let x = 5i;
    x = 10i;
}</span><pre id='rust-example-rendered-11' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5i</span>;
<span class='ident'>x</span> <span class='op'>=</span> <span class='number'>10i</span>;
</pre>

<p>It will give you this error:</p>

<pre><code class="language-{ignore,notrust}">error: re-assignment of immutable variable `x`
     x = 10i;
     ^~~~~~~</code></pre>

<p>If you want a binding to be mutable, you can use <code>mut</code>:</p>
<span id='rust-example-raw-12' class='rusttest'>fn main() {
    let mut x = 5i;
    x = 10i;
}</span><pre id='rust-example-rendered-12' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5i</span>;
<span class='ident'>x</span> <span class='op'>=</span> <span class='number'>10i</span>;
</pre>

<p>There is no single reason that bindings are immutable by default, but we can
think about it through one of Rust&#39;s primary focuses: safety. If you forget to
say <code>mut</code>, the compiler will catch it, and let you know that you have mutated
something you may not have cared to mutate. If bindings were mutable by
default, the compiler would not be able to tell you this. If you <em>did</em> intend
mutation, then the solution is quite easy: add <code>mut</code>.</p>

<p>There are other good reasons to avoid mutable state when possible, but they&#39;re
out of the scope of this guide. In general, you can often avoid explicit
mutation, and so it is preferable in Rust. That said, sometimes, mutation is
what you need, so it&#39;s not verboten.</p>

<p>Let&#39;s get back to bindings. Rust variable bindings have one more aspect that
differs from other languages: bindings are required to be initialized with a
value before you&#39;re allowed to use it. If we try...</p>
<span id='rust-example-raw-13' class='rusttest'>fn main() {
    let x;
}</span><pre id='rust-example-rendered-13' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span>;
</pre>

<p>...we&#39;ll get an error:</p>
<span id='rust-example-raw-14' class='rusttest'>fn main() {
    src/guessing_game.rs:2:9: 2:10 error: cannot determine a type for this local variable: unconstrained type
    src/guessing_game.rs:2     let x;
                                   ^
}</span><pre id='rust-example-rendered-14' class='rust '>
<span class='ident'>src</span><span class='op'>/</span><span class='ident'>guessing_game</span>.<span class='ident'>rs</span>:<span class='number'>2</span>:<span class='number'>9</span>: <span class='number'>2</span>:<span class='number'>10</span> <span class='ident'>error</span>: <span class='ident'>cannot</span> <span class='ident'>determine</span> <span class='ident'>a</span> <span class='kw'>type</span> <span class='kw'>for</span> <span class='ident'>this</span> <span class='ident'>local</span> <span class='ident'>variable</span>: <span class='ident'>unconstrained</span> <span class='kw'>type</span>
<span class='ident'>src</span><span class='op'>/</span><span class='ident'>guessing_game</span>.<span class='ident'>rs</span>:<span class='number'>2</span>     <span class='kw'>let</span> <span class='ident'>x</span>;
                               <span class='op'>^</span>
</pre>

<p>Giving it a type will compile, though:</p>
<span id='rust-example-raw-15' class='rusttest'>fn main() {
    let x: int;
}</span><pre id='rust-example-rendered-15' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>int</span>;
</pre>

<p>Let&#39;s try it out. Change your <code>src/guessing_game.rs</code> file to look like this:</p>
<span id='rust-example-raw-16' class='rusttest'>fn main() {
    let x: int;

    println!(&quot;Hello world!&quot;);
}</span><pre id='rust-example-rendered-16' class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>int</span>;

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello world!&quot;</span>);
}
</pre>

<p>You can use <code>cargo build</code> on the command line to build it. You&#39;ll get a warning,
but it will still print &quot;Hello, world!&quot;:</p>

<pre><code class="language-{ignore,notrust}">   Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)
src/guessing_game.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variable)] on by default
src/guessing_game.rs:2     let x: int;
                               ^</code></pre>

<p>Rust warns us that we never use the variable binding, but since we never use it,
no harm, no foul. Things change if we try to actually use this <code>x</code>, however. Let&#39;s
do that. Change your program to look like this:</p>
<span id='rust-example-raw-17' class='rusttest'>fn main() {
    let x: int;

    println!(&quot;The value of x is: {}&quot;, x);
}</span><pre id='rust-example-rendered-17' class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>int</span>;

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The value of x is: {}&quot;</span>, <span class='ident'>x</span>);
}
</pre>

<p>And try to build it. You&#39;ll get an error:</p>

<pre><code class="language-{bash}">$ cargo build
   Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)
src/guessing_game.rs:4:39: 4:40 error: use of possibly uninitialized variable: `x`
src/guessing_game.rs:4     println!(&quot;The value of x is: {}&quot;, x);
                                                             ^
note: in expansion of format_args!
&lt;std macros&gt;:2:23: 2:77 note: expansion site
&lt;std macros&gt;:1:1: 3:2 note: in expansion of println!
src/guessing_game.rs:4:5: 4:42 note: expansion site
error: aborting due to previous error
Could not execute process `rustc src/guessing_game.rs --crate-type bin --out-dir /home/you/projects/guessing_game/target -L /home/you/projects/guessing_game/target -L /home/you/projects/guessing_game/target/deps` (status=101)</code></pre>

<p>Rust will not let us use a value that has not been initialized. So why let us
declare a binding without initializing it? You&#39;d think our first example would
have errored. Well, Rust is smarter than that. Before we get to that, let&#39;s talk
about this stuff we&#39;ve added to <code>println!</code>.</p>

<p>If you include two curly braces (<code>{}</code>, some call them moustaches...) in your
string to print, Rust will interpret this as a request to interpolate some sort
of value. <strong>String interpolation</strong> is a computer science term that means &quot;stick
in the middle of a string.&quot; We add a comma, and then <code>x</code>, to indicate that we
want <code>x</code> to be the value we&#39;re interpolating. The comma is used to separate
arguments we pass to functions and macros, if you&#39;re passing more than one.</p>

<p>When you just use the double curly braces, Rust will attempt to display the
value in a meaningful way by checking out its type. If you want to specify the
format in a more detailed manner, there are a <a href="/std/fmt/index.html">wide number of options
available</a>. For now, we&#39;ll just stick to the default:
integers aren&#39;t very complicated to print.</p>

<p>So, we&#39;ve cleared up all of the confusion around bindings, with one exception:
why does Rust let us declare a variable binding without an initial value if we
must initialize the binding before we use it? And how does it know that we have
or have not initialized the binding? For that, we need to learn our next
concept: <code>if</code>.</p>

<h1 id="if" class='section-header'><a
                           href="#if">6 If</a></h1>
<p>Rust&#39;s take on <code>if</code> is not particularly complex, but it&#39;s much more like the
<code>if</code> you&#39;ll find in a dynamically typed language than in a more traditional
systems language. So let&#39;s talk about it, to make sure you grasp the nuances.</p>

<p><code>if</code> is a specific form of a more general concept, the &#39;branch.&#39; The name comes
from a branch in a tree: a decision point, where depending on a choice,
multiple paths can be taken.</p>

<p>In the case of <code>if</code>, there is one choice that leads down two paths:</p>
<span id='rust-example-raw-18' class='rusttest'>fn main() {
    let x = 5i;
    
    if x == 5i {
        println!(&quot;x is five!&quot;);
    }
}</span><pre id='rust-example-rendered-18' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5i</span>;

<span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>==</span> <span class='number'>5i</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x is five!&quot;</span>);
}
</pre>

<p>If we changed the value of <code>x</code> to something else, this line would not print.
More specifically, if the expression after the <code>if</code> evaluates to <code>true</code>, then
the block is executed. If it&#39;s <code>false</code>, then it is not.</p>

<p>If you want something to happen in the <code>false</code> case, use an <code>else</code>:</p>
<span id='rust-example-raw-19' class='rusttest'>fn main() {
    let x = 5i;
    
    if x == 5i {
        println!(&quot;x is five!&quot;);
    } else {
        println!(&quot;x is not five :(&quot;);
    }
}</span><pre id='rust-example-rendered-19' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5i</span>;

<span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>==</span> <span class='number'>5i</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x is five!&quot;</span>);
} <span class='kw'>else</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x is not five :(&quot;</span>);
}
</pre>

<p>This is all pretty standard. However, you can also do this:</p>
<span id='rust-example-raw-20' class='rusttest'>fn main() {
    let x = 5i;
    
    let y = if x == 5i {
        10i
    } else {
        15i
    };
}</span><pre id='rust-example-rendered-20' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5i</span>;

<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>==</span> <span class='number'>5i</span> {
    <span class='number'>10i</span>
} <span class='kw'>else</span> {
    <span class='number'>15i</span>
};
</pre>

<p>Which we can (and probably should) write like this:</p>
<span id='rust-example-raw-21' class='rusttest'>fn main() {
    let x = 5i;
    
    let y = if x == 5i { 10i } else { 15i };
}</span><pre id='rust-example-rendered-21' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5i</span>;

<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>==</span> <span class='number'>5i</span> { <span class='number'>10i</span> } <span class='kw'>else</span> { <span class='number'>15i</span> };
</pre>

<p>This reveals two interesting things about Rust: it is an expression-based
language, and semicolons are different than in other &#39;curly brace and
semicolon&#39;-based languages. These two things are related.</p>

<h2 id="expressions-vs.-statements" class='section-header'><a
                           href="#expressions-vs.-statements">6.1 Expressions vs. Statements</a></h2>
<p>Rust is primarily an expression based language. There are only two kinds of
statements, and everything else is an expression.</p>

<p>So what&#39;s the difference? Expressions return a value, and statements do not.
In many languages, <code>if</code> is a statement, and therefore, <code>let x = if ...</code> would
make no sense. But in Rust, <code>if</code> is an expression, which means that it returns
a value. We can then use this value to initialize the binding.</p>

<p>Speaking of which, bindings are a kind of the first of Rust&#39;s two statements.
The proper name is a <strong>declaration statement</strong>. So far, <code>let</code> is the only kind
of declaration statement we&#39;ve seen. Let&#39;s talk about that some more.</p>

<p>In some languages, variable bindings can be written as expressions, not just
statements. Like Ruby:</p>

<pre><code class="language-{ruby}">x = y = 5</code></pre>

<p>In Rust, however, using <code>let</code> to introduce a binding is <em>not</em> an expression. The
following will produce a compile-time error:</p>
<span id='rust-example-raw-22' class='rusttest'>fn main() {
    let x = (let y = 5i); // found `let` in ident position
}</span><pre id='rust-example-rendered-22' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> (<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>5i</span>); <span class='comment'>// found `let` in ident position</span>
</pre>

<p>The compiler is telling us here that it was expecting to see the beginning of
an expression, and a <code>let</code> can only begin a statement, not an expression.</p>

<p>Note that assigning to an already-bound variable (e.g. <code>y = 5i</code>) is still an
expression, although its value is not particularly useful. Unlike C, where an
assignment evaluates to the assigned value (e.g. <code>5i</code> in the previous example),
in Rust the value of an assignment is the unit type <code>()</code> (which we&#39;ll cover later).</p>

<p>The second kind of statement in Rust is the <strong>expression statement</strong>. Its
purpose is to turn any expression into a statement. In practical terms, Rust&#39;s
grammar expects statements to follow other statements. This means that you use
semicolons to separate expressions from each other. This means that Rust
looks a lot like most other languages that require you to use semicolons
at the end of every line, and you will see semicolons at the end of almost
every line of Rust code you see.</p>

<p>What is this exception that makes us say &#39;almost?&#39; You saw it already, in this
code:</p>
<span id='rust-example-raw-23' class='rusttest'>fn main() {
    let x = 5i;
    
    let y: int = if x == 5i { 10i } else { 15i };
}</span><pre id='rust-example-rendered-23' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5i</span>;

<span class='kw'>let</span> <span class='ident'>y</span>: <span class='ident'>int</span> <span class='op'>=</span> <span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>==</span> <span class='number'>5i</span> { <span class='number'>10i</span> } <span class='kw'>else</span> { <span class='number'>15i</span> };
</pre>

<p>Note that I&#39;ve added the type annotation to <code>y</code>, to specify explicitly that I
want <code>y</code> to be an integer.</p>

<p>This is not the same as this, which won&#39;t compile:</p>
<span id='rust-example-raw-24' class='rusttest'>fn main() {
    let x = 5i;
    
    let y: int = if x == 5 { 10i; } else { 15i; };
}</span><pre id='rust-example-rendered-24' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5i</span>;

<span class='kw'>let</span> <span class='ident'>y</span>: <span class='ident'>int</span> <span class='op'>=</span> <span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>==</span> <span class='number'>5</span> { <span class='number'>10i</span>; } <span class='kw'>else</span> { <span class='number'>15i</span>; };
</pre>

<p>Note the semicolons after the 10 and 15. Rust will give us the following error:</p>

<pre><code class="language-{ignore,notrust}">error: mismatched types: expected `int` but found `()` (expected int but found ())</code></pre>

<p>We expected an integer, but we got <code>()</code>. <code>()</code> is pronounced &#39;unit&#39;, and is a
special type in Rust&#39;s type system. <code>()</code> is different than <code>null</code> in other
languages, because <code>()</code> is distinct from other types. For example, in C, <code>null</code>
is a valid value for a variable of type <code>int</code>. In Rust, <code>()</code> is <em>not</em> a valid
value for a variable of type <code>int</code>. It&#39;s only a valid value for variables of
the type <code>()</code>, which aren&#39;t very useful. Remember how we said statements don&#39;t
return a value? Well, that&#39;s the purpose of unit in this case. The semicolon
turns any expression into a statement by throwing away its value and returning
unit instead.</p>

<p>There&#39;s one more time in which you won&#39;t see a semicolon at the end of a line
of Rust code. For that, we&#39;ll need our next concept: functions.</p>

<h1 id="functions" class='section-header'><a
                           href="#functions">7 Functions</a></h1>
<p>You&#39;ve already seen one function so far, the <code>main</code> function:</p>
<span id='rust-example-raw-25' class='rusttest'>fn main() {
}</span><pre id='rust-example-rendered-25' class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
}
</pre>

<p>This is the simplest possible function declaration. As we mentioned before,
<code>fn</code> says &#39;this is a function,&#39; followed by the name, some parenthesis because
this function takes no arguments, and then some curly braces to indicate the
body. Here&#39;s a function named <code>foo</code>:</p>
<span id='rust-example-raw-26' class='rusttest'>fn main() {
    fn foo() {
    }
}</span><pre id='rust-example-rendered-26' class='rust '>
<span class='kw'>fn</span> <span class='ident'>foo</span>() {
}
</pre>

<p>So, what about taking arguments? Here&#39;s a function that prints a number:</p>
<span id='rust-example-raw-27' class='rusttest'>fn main() {
    fn print_number(x: int) {
        println!(&quot;x is: {}&quot;, x);
    }
}</span><pre id='rust-example-rendered-27' class='rust '>
<span class='kw'>fn</span> <span class='ident'>print_number</span>(<span class='ident'>x</span>: <span class='ident'>int</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x is: {}&quot;</span>, <span class='ident'>x</span>);
}
</pre>

<p>Here&#39;s a complete program that uses <code>print_number</code>:</p>
<span id='rust-example-raw-28' class='rusttest'>fn main() {
    print_number(5);
}

fn print_number(x: int) {
    println!(&quot;x is: {}&quot;, x);
}</span><pre id='rust-example-rendered-28' class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>print_number</span>(<span class='number'>5</span>);
}

<span class='kw'>fn</span> <span class='ident'>print_number</span>(<span class='ident'>x</span>: <span class='ident'>int</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x is: {}&quot;</span>, <span class='ident'>x</span>);
}
</pre>

<p>As you can see, function arguments work very similar to <code>let</code> declarations:
you add a type to the argument name, after a colon.</p>

<p>Here&#39;s a complete program that adds two numbers together and prints them:</p>
<span id='rust-example-raw-29' class='rusttest'>fn main() {
    print_sum(5, 6);
}

fn print_sum(x: int, y: int) {
    println!(&quot;sum is: {}&quot;, x + y);
}</span><pre id='rust-example-rendered-29' class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>print_sum</span>(<span class='number'>5</span>, <span class='number'>6</span>);
}

<span class='kw'>fn</span> <span class='ident'>print_sum</span>(<span class='ident'>x</span>: <span class='ident'>int</span>, <span class='ident'>y</span>: <span class='ident'>int</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;sum is: {}&quot;</span>, <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>y</span>);
}
</pre>

<p>You separate arguments with a comma, both when you call the function, as well
as when you declare it.</p>

<p>Unlike <code>let</code>, you <em>must</em> declare the types of function arguments. This does
not work:</p>
<span id='rust-example-raw-30' class='rusttest'>fn main() {
    fn print_number(x, y) {
        println!(&quot;x is: {}&quot;, x + y);
    }
}</span><pre id='rust-example-rendered-30' class='rust '>
<span class='kw'>fn</span> <span class='ident'>print_number</span>(<span class='ident'>x</span>, <span class='ident'>y</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x is: {}&quot;</span>, <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>y</span>);
}
</pre>

<p>You get this error:</p>

<pre><code class="language-{ignore,notrust}">hello.rs:5:18: 5:19 error: expected `:` but found `,`
hello.rs:5 fn print_number(x, y) {</code></pre>

<p>This is a deliberate design decision. While full-program inference is possible,
languages which have it, like Haskell, often suggest that documenting your
types explicitly is a best-practice. We agree that forcing functions to declare
types while allowing for inference inside of function bodies is a wonderful
compromise between full inference and no inference.</p>

<p>What about returning a value? Here&#39;s a function that adds one to an integer:</p>
<span id='rust-example-raw-31' class='rusttest'>fn main() {
    fn add_one(x: int) -&gt; int {
        x + 1
    }
}</span><pre id='rust-example-rendered-31' class='rust '>
<span class='kw'>fn</span> <span class='ident'>add_one</span>(<span class='ident'>x</span>: <span class='ident'>int</span>) <span class='op'>-&gt;</span> <span class='ident'>int</span> {
    <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>
}
</pre>

<p>Rust functions return exactly one value, and you declare the type after an
&#39;arrow&#39;, which is a dash (<code>-</code>) followed by a greater-than sign (<code>&gt;</code>).</p>

<p>You&#39;ll note the lack of a semicolon here. If we added it in:</p>
<span id='rust-example-raw-32' class='rusttest'>fn main() {
    fn add_one(x: int) -&gt; int {
        x + 1;
    }
}</span><pre id='rust-example-rendered-32' class='rust '>
<span class='kw'>fn</span> <span class='ident'>add_one</span>(<span class='ident'>x</span>: <span class='ident'>int</span>) <span class='op'>-&gt;</span> <span class='ident'>int</span> {
    <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>;
}
</pre>

<p>We would get an error:</p>

<pre><code class="language-{ignore,notrust}">error: not all control paths return a value
fn add_one(x: int) -&gt; int {
     x + 1;
}

note: consider removing this semicolon:
     x + 1;
          ^</code></pre>

<p>Remember our earlier discussions about semicolons and <code>()</code>? Our function claims
to return an <code>int</code>, but with a semicolon, it would return <code>()</code> instead. Rust
realizes this probably isn&#39;t what we want, and suggests removing the semicolon.</p>

<p>This is very much like our <code>if</code> statement before: the result of the block
(<code>{}</code>) is the value of the expression. Other expression-oriented languages,
such as Ruby, work like this, but it&#39;s a bit unusual in the systems programming
world. When people first learn about this, they usually assume that it
introduces bugs. But because Rust&#39;s type system is so strong, and because unit
is its own unique type, we have never seen an issue where adding or removing a
semicolon in a return position would cause a bug.</p>

<p>But what about early returns? Rust does have a keyword for that, <code>return</code>:</p>
<span id='rust-example-raw-33' class='rusttest'>fn main() {
    fn foo(x: int) -&gt; int {
        if x &lt; 5 { return x; }
    
        x + 1
    }
}</span><pre id='rust-example-rendered-33' class='rust '>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='ident'>int</span>) <span class='op'>-&gt;</span> <span class='ident'>int</span> {
    <span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>&lt;</span> <span class='number'>5</span> { <span class='kw'>return</span> <span class='ident'>x</span>; }

    <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>
}
</pre>

<p>Using a <code>return</code> as the last line of a function works, but is considered poor
style:</p>
<span id='rust-example-raw-34' class='rusttest'>fn main() {
    fn foo(x: int) -&gt; int {
        if x &lt; 5 { return x; }
    
        return x + 1;
    }
}</span><pre id='rust-example-rendered-34' class='rust '>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='ident'>int</span>) <span class='op'>-&gt;</span> <span class='ident'>int</span> {
    <span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>&lt;</span> <span class='number'>5</span> { <span class='kw'>return</span> <span class='ident'>x</span>; }

    <span class='kw'>return</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>;
}
</pre>

<p>There are some additional ways to define functions, but they involve features
that we haven&#39;t learned about yet, so let&#39;s just leave it at that for now.</p>

<h1 id="comments" class='section-header'><a
                           href="#comments">8 Comments</a></h1>
<p>Now that we have some functions, it&#39;s a good idea to learn about comments.
Comments are notes that you leave to other programmers to help explain things
about your code. The compiler mostly ignores them.</p>

<p>Rust has two kinds of comments that you should care about: <strong>line comment</strong>s
and <strong>doc comment</strong>s.</p>
<span id='rust-example-raw-35' class='rusttest'>fn main() {
    // Line comments are anything after &#39;//&#39; and extend to the end of the line.
    
    let x = 5i; // this is also a line comment.
    
    // If you have a long explanation for something, you can put line comments next
    // to each other. Put a space between the // and your comment so that it&#39;s
    // more readable.
}</span><pre id='rust-example-rendered-35' class='rust '>
<span class='comment'>// Line comments are anything after &#39;//&#39; and extend to the end of the line.</span>

<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5i</span>; <span class='comment'>// this is also a line comment.</span>

<span class='comment'>// If you have a long explanation for something, you can put line comments next</span>
<span class='comment'>// to each other. Put a space between the // and your comment so that it&#39;s</span>
<span class='comment'>// more readable.</span>
</pre>

<p>The other kind of comment is a doc comment. Doc comments use <code>///</code> instead of
<code>//</code>, and support Markdown notation inside:</p>
<span id='rust-example-raw-36' class='rusttest'>fn main() {
    /// `hello` is a function that prints a greeting that is personalized based on
    /// the name given.
    ///
    /// # Arguments
    ///
    /// * `name` - The name of the person you&#39;d like to greet.
    ///
    /// # Example
    ///
    /// ```rust
    /// let name = &quot;Steve&quot;;
    /// hello(name); // prints &quot;Hello, Steve!&quot;
    /// ```
    fn hello(name: &amp;str) {
        println!(&quot;Hello, {}!&quot;, name);
    }
}</span><pre id='rust-example-rendered-36' class='rust '>
<span class='doccomment'>/// `hello` is a function that prints a greeting that is personalized based on</span>
<span class='doccomment'>/// the name given.</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// # Arguments</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// * `name` - The name of the person you&#39;d like to greet.</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// # Example</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// ```rust</span>
<span class='doccomment'>/// let name = &quot;Steve&quot;;</span>
<span class='doccomment'>/// hello(name); // prints &quot;Hello, Steve!&quot;</span>
<span class='doccomment'>/// ```</span>
<span class='kw'>fn</span> <span class='ident'>hello</span>(<span class='ident'>name</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello, {}!&quot;</span>, <span class='ident'>name</span>);
}
</pre>

<p>When writing doc comments, adding sections for any arguments, return values,
and providing some examples of usage is very, very helpful.</p>

<p>You can use the <code>rustdoc</code> tool to generate HTML documentation from these doc
comments. We will talk more about <code>rustdoc</code> when we get to modules, as
generally, you want to export documentation for a full module.</p>

<h1 id="compound-data-types" class='section-header'><a
                           href="#compound-data-types">9 Compound Data Types</a></h1>
<p>Rust, like many programming languages, has a number of different data types
that are built-in. You&#39;ve already done some simple work with integers and
strings, but next, let&#39;s talk about some more complicated ways of storing data.</p>

<h2 id="tuples" class='section-header'><a
                           href="#tuples">9.1 Tuples</a></h2>
<p>The first compound data type we&#39;re going to talk about are called <strong>tuple</strong>s.
Tuples are an ordered list of a fixed size. Like this:</p>
<span id='rust-example-raw-37' class='rusttest'>fn main() {
    let x = (1i, &quot;hello&quot;);
}</span><pre id='rust-example-rendered-37' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> (<span class='number'>1i</span>, <span class='string'>&quot;hello&quot;</span>);
</pre>

<p>The parenthesis and commas form this two-length tuple. Here&#39;s the same code, but
with the type annotated:</p>
<span id='rust-example-raw-38' class='rusttest'>fn main() {
    let x: (int, &amp;str) = (1, &quot;hello&quot;);
}</span><pre id='rust-example-rendered-38' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span>: (<span class='ident'>int</span>, <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>=</span> (<span class='number'>1</span>, <span class='string'>&quot;hello&quot;</span>);
</pre>

<p>As you can see, the type of a tuple looks just like the tuple, but with each
position having a type name rather than the value. Careful readers will also
note that tuples are heterogeneous: we have an <code>int</code> and a <code>&amp;str</code> in this tuple.
You haven&#39;t seen <code>&amp;str</code> as a type before, and we&#39;ll discuss the details of
strings later. In systems programming languages, strings are a bit more complex
than in other languages. For now, just read <code>&amp;str</code> as &quot;a string slice,&quot; and
we&#39;ll learn more soon.</p>

<p>You can access the fields in a tuple through a <strong>destructuring let</strong>. Here&#39;s
an example:</p>
<span id='rust-example-raw-39' class='rusttest'>fn main() {
    let (x, y, z) = (1i, 2i, 3i);
    
    println!(&quot;x is {}&quot;, x);
}</span><pre id='rust-example-rendered-39' class='rust '>
<span class='kw'>let</span> (<span class='ident'>x</span>, <span class='ident'>y</span>, <span class='ident'>z</span>) <span class='op'>=</span> (<span class='number'>1i</span>, <span class='number'>2i</span>, <span class='number'>3i</span>);

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x is {}&quot;</span>, <span class='ident'>x</span>);
</pre>

<p>Remember before when I said the left hand side of a <code>let</code> statement was more
powerful than just assigning a binding? Here we are. We can put a pattern on
the left hand side of the <code>let</code>, and if it matches up to the right hand side,
we can assign multiple bindings at once. In this case, <code>let</code> &#39;destructures,&#39;
or &#39;breaks up,&#39; the tuple, and assigns the bits to three bindings.</p>

<p>This pattern is very powerful, and we&#39;ll see it repeated more later.</p>

<p>The last thing to say about tuples is that they are only equivalent if
the arity, types, and values are all identical.</p>
<span id='rust-example-raw-40' class='rusttest'>fn main() {
    let x = (1i, 2i, 3i);
    let y = (2i, 3i, 4i);
    
    if x == y {
        println!(&quot;yes&quot;);
    } else {
        println!(&quot;no&quot;);
    }
}</span><pre id='rust-example-rendered-40' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> (<span class='number'>1i</span>, <span class='number'>2i</span>, <span class='number'>3i</span>);
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> (<span class='number'>2i</span>, <span class='number'>3i</span>, <span class='number'>4i</span>);

<span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>==</span> <span class='ident'>y</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;yes&quot;</span>);
} <span class='kw'>else</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;no&quot;</span>);
}
</pre>

<p>This will print <code>no</code>, as the values aren&#39;t equal.</p>

<p>One other use of tuples is to return multiple values from a function:</p>
<span id='rust-example-raw-41' class='rusttest'>fn next_two(x: int) -&gt; (int, int) { (x + 1i, x + 2i) }

fn main() {
    let (x, y) = next_two(5i);
    println!(&quot;x, y = {}, {}&quot;, x, y);
}</span><pre id='rust-example-rendered-41' class='rust '>
<span class='kw'>fn</span> <span class='ident'>next_two</span>(<span class='ident'>x</span>: <span class='ident'>int</span>) <span class='op'>-&gt;</span> (<span class='ident'>int</span>, <span class='ident'>int</span>) { (<span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1i</span>, <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>2i</span>) }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> (<span class='ident'>x</span>, <span class='ident'>y</span>) <span class='op'>=</span> <span class='ident'>next_two</span>(<span class='number'>5i</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x, y = {}, {}&quot;</span>, <span class='ident'>x</span>, <span class='ident'>y</span>);
}
</pre>

<p>Even though Rust functions can only return one value, a tuple <em>is</em> one value,
that happens to be made up of two. You can also see in this example how you
can destructure a pattern returned by a function, as well.</p>

<p>Tuples are a very simple data structure, and so are not often what you want.
Let&#39;s move on to their bigger sibling, structs.</p>

<h2 id="structs" class='section-header'><a
                           href="#structs">9.2 Structs</a></h2>
<p>A struct is another form of a &#39;record type,&#39; just like a tuple. There&#39;s a
difference: structs give each element that they contain a name, called a
&#39;field&#39; or a &#39;member.&#39; Check it out:</p>
<span id='rust-example-raw-42' class='rusttest'>struct Point {
    x: int,
    y: int,
}

fn main() {
    let origin = Point { x: 0i, y:  0i };

    println!(&quot;The origin is at ({}, {})&quot;, origin.x, origin.y);
}</span><pre id='rust-example-rendered-42' class='rust '>
<span class='kw'>struct</span> <span class='ident'>Point</span> {
    <span class='ident'>x</span>: <span class='ident'>int</span>,
    <span class='ident'>y</span>: <span class='ident'>int</span>,
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>origin</span> <span class='op'>=</span> <span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='number'>0i</span>, <span class='ident'>y</span>:  <span class='number'>0i</span> };

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The origin is at ({}, {})&quot;</span>, <span class='ident'>origin</span>.<span class='ident'>x</span>, <span class='ident'>origin</span>.<span class='ident'>y</span>);
}
</pre>

<p>There&#39;s a lot going on here, so let&#39;s break it down. We declare a struct with
the <code>struct</code> keyword, and then with a name. By convention, structs begin with a
capital letter and are also camel cased: <code>PointInSpace</code>, not <code>Point_In_Space</code>.</p>

<p>We can create an instance of our struct via <code>let</code>, as usual, but we use a <code>key:
value</code> style syntax to set each field. The order doesn&#39;t need to be the same as
in the original declaration.</p>

<p>Finally, because fields have names, we can access the field through dot
notation: <code>origin.x</code>.</p>

<p>The values in structs are immutable, like other bindings in Rust. However, you
can use <code>mut</code> to make them mutable:</p>
<span id='rust-example-raw-43' class='rusttest'>struct Point {
    x: int,
    y: int,
}

fn main() {
    let mut point = Point { x: 0i, y:  0i };

    point.x = 5;

    println!(&quot;The point is at ({}, {})&quot;, point.x, point.y);
}</span><pre id='rust-example-rendered-43' class='rust '>
<span class='kw'>struct</span> <span class='ident'>Point</span> {
    <span class='ident'>x</span>: <span class='ident'>int</span>,
    <span class='ident'>y</span>: <span class='ident'>int</span>,
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>point</span> <span class='op'>=</span> <span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='number'>0i</span>, <span class='ident'>y</span>:  <span class='number'>0i</span> };

    <span class='ident'>point</span>.<span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The point is at ({}, {})&quot;</span>, <span class='ident'>point</span>.<span class='ident'>x</span>, <span class='ident'>point</span>.<span class='ident'>y</span>);
}
</pre>

<p>This will print <code>The point is at (5, 0)</code>.</p>

<h2 id="tuple-structs-and-newtypes" class='section-header'><a
                           href="#tuple-structs-and-newtypes">9.3 Tuple Structs and Newtypes</a></h2>
<p>Rust has another data type that&#39;s like a hybrid between a tuple and a struct,
called a <strong>tuple struct</strong>. Tuple structs do have a name, but their fields
don&#39;t:</p>
<span id='rust-example-raw-44' class='rusttest'>fn main() {
    struct Color(int, int, int);
    struct Point(int, int, int);
}</span><pre id='rust-example-rendered-44' class='rust '>
<span class='kw'>struct</span> <span class='ident'>Color</span>(<span class='ident'>int</span>, <span class='ident'>int</span>, <span class='ident'>int</span>);
<span class='kw'>struct</span> <span class='ident'>Point</span>(<span class='ident'>int</span>, <span class='ident'>int</span>, <span class='ident'>int</span>);
</pre>

<p>These two will not be equal, even if they have the same values:</p>
<span id='rust-example-raw-45' class='rusttest'>fn main() {
    let black  = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}</span><pre id='rust-example-rendered-45' class='rust '>
<span class='kw'>let</span> <span class='ident'>black</span>  <span class='op'>=</span> <span class='ident'>Color</span>(<span class='number'>0</span>, <span class='number'>0</span>, <span class='number'>0</span>);
<span class='kw'>let</span> <span class='ident'>origin</span> <span class='op'>=</span> <span class='ident'>Point</span>(<span class='number'>0</span>, <span class='number'>0</span>, <span class='number'>0</span>);
</pre>

<p>It is almost always better to use a struct than a tuple struct. We would write
<code>Color</code> and <code>Point</code> like this instead:</p>
<span id='rust-example-raw-46' class='rusttest'>fn main() {
    struct Color {
        red: int,
        blue: int,
        green: int,
    }
    
    struct Point {
        x: int,
        y: int,
        z: int,
    }
}</span><pre id='rust-example-rendered-46' class='rust '>
<span class='kw'>struct</span> <span class='ident'>Color</span> {
    <span class='ident'>red</span>: <span class='ident'>int</span>,
    <span class='ident'>blue</span>: <span class='ident'>int</span>,
    <span class='ident'>green</span>: <span class='ident'>int</span>,
}

<span class='kw'>struct</span> <span class='ident'>Point</span> {
    <span class='ident'>x</span>: <span class='ident'>int</span>,
    <span class='ident'>y</span>: <span class='ident'>int</span>,
    <span class='ident'>z</span>: <span class='ident'>int</span>,
}
</pre>

<p>Now, we have actual names, rather than positions. Good names are important,
and with a struct, we have actual names.</p>

<p>There <em>is</em> one case when a tuple struct is very useful, though, and that&#39;s a
tuple struct with only one element. We call this a &#39;newtype,&#39; because it lets
you create a new type that&#39;s a synonym for another one:</p>
<span id='rust-example-raw-47' class='rusttest'>fn main() {
    struct Inches(int);
    struct Centimeters(int);
    
    let length = Inches(10);
    
    let Inches(integer_length) = length;
    println!(&quot;length is {} inches&quot;, integer_length);
}</span><pre id='rust-example-rendered-47' class='rust '>
<span class='kw'>struct</span> <span class='ident'>Inches</span>(<span class='ident'>int</span>);
<span class='kw'>struct</span> <span class='ident'>Centimeters</span>(<span class='ident'>int</span>);

<span class='kw'>let</span> <span class='ident'>length</span> <span class='op'>=</span> <span class='ident'>Inches</span>(<span class='number'>10</span>);

<span class='kw'>let</span> <span class='ident'>Inches</span>(<span class='ident'>integer_length</span>) <span class='op'>=</span> <span class='ident'>length</span>;
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;length is {} inches&quot;</span>, <span class='ident'>integer_length</span>);
</pre>

<p>As you can see here, you can extract the inner integer type through a
destructuring <code>let</code>.</p>

<h2 id="enums" class='section-header'><a
                           href="#enums">9.4 Enums</a></h2>
<p>Finally, Rust has a &quot;sum type&quot;, an <strong>enum</strong>. Enums are an incredibly useful
feature of Rust, and are used throughout the standard library. Enums look
like this:</p>
<span id='rust-example-raw-48' class='rusttest'>fn main() {
    enum Ordering {
        Less,
        Equal,
        Greater,
    }
}</span><pre id='rust-example-rendered-48' class='rust '>
<span class='kw'>enum</span> <span class='ident'>Ordering</span> {
    <span class='ident'>Less</span>,
    <span class='ident'>Equal</span>,
    <span class='ident'>Greater</span>,
}
</pre>

<p>This is an enum that is provided by the Rust standard library. An <code>Ordering</code>
can only be <em>one</em> of <code>Less</code>, <code>Equal</code>, or <code>Greater</code> at any given time. Here&#39;s
an example:</p>
<span id='rust-example-raw-49' class='rusttest'>fn cmp(a: int, b: int) -&gt; Ordering {
    if a &lt; b { Less }
    else if a &gt; b { Greater }
    else { Equal }
}

fn main() {
    let x = 5i;
    let y = 10i;

    let ordering = cmp(x, y);

    if ordering == Less {
        println!(&quot;less&quot;);
    } else if ordering == Greater {
        println!(&quot;greater&quot;);
    } else if ordering == Equal {
        println!(&quot;equal&quot;);
    }
}</span><pre id='rust-example-rendered-49' class='rust '>
<span class='kw'>fn</span> <span class='ident'>cmp</span>(<span class='ident'>a</span>: <span class='ident'>int</span>, <span class='ident'>b</span>: <span class='ident'>int</span>) <span class='op'>-&gt;</span> <span class='ident'>Ordering</span> {
    <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&lt;</span> <span class='ident'>b</span> { <span class='ident'>Less</span> }
    <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&gt;</span> <span class='ident'>b</span> { <span class='ident'>Greater</span> }
    <span class='kw'>else</span> { <span class='ident'>Equal</span> }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5i</span>;
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>10i</span>;

    <span class='kw'>let</span> <span class='ident'>ordering</span> <span class='op'>=</span> <span class='ident'>cmp</span>(<span class='ident'>x</span>, <span class='ident'>y</span>);

    <span class='kw'>if</span> <span class='ident'>ordering</span> <span class='op'>==</span> <span class='ident'>Less</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;less&quot;</span>);
    } <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>ordering</span> <span class='op'>==</span> <span class='ident'>Greater</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;greater&quot;</span>);
    } <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>ordering</span> <span class='op'>==</span> <span class='ident'>Equal</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;equal&quot;</span>);
    }
}
</pre>

<p><code>cmp</code> is a function that compares two things, and returns an <code>Ordering</code>. We
return either <code>Less</code>, <code>Greater</code>, or <code>Equal</code>, depending on if the two values
are greater, less, or equal.</p>

<p>The <code>ordering</code> variable has the type <code>Ordering</code>, and so contains one of the
three values. We can then do a bunch of <code>if</code>/<code>else</code> comparisons to check
which one it is.</p>

<p>However, repeated <code>if</code>/<code>else</code> comparisons get quite tedious. Rust has a feature
that not only makes them nicer to read, but also makes sure that you never
miss a case. Before we get to that, though, let&#39;s talk about another kind of
enum: one with values.</p>

<p>This enum has two variants, one of which has a value:</p>
<span id='rust-example-raw-50' class='rusttest'>enum OptionalInt {
    Value(int),
    Missing,
}

fn main() {
    let x = Value(5);
    let y = Missing;

    match x {
        Value(n) =&gt; println!(&quot;x is {:d}&quot;, n),
        Missing  =&gt; println!(&quot;x is missing!&quot;),
    }

    match y {
        Value(n) =&gt; println!(&quot;y is {:d}&quot;, n),
        Missing  =&gt; println!(&quot;y is missing!&quot;),
    }
}</span><pre id='rust-example-rendered-50' class='rust '>
<span class='kw'>enum</span> <span class='ident'>OptionalInt</span> {
    <span class='ident'>Value</span>(<span class='ident'>int</span>),
    <span class='ident'>Missing</span>,
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Value</span>(<span class='number'>5</span>);
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='ident'>Missing</span>;

    <span class='kw'>match</span> <span class='ident'>x</span> {
        <span class='ident'>Value</span>(<span class='ident'>n</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x is {:d}&quot;</span>, <span class='ident'>n</span>),
        <span class='ident'>Missing</span>  <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x is missing!&quot;</span>),
    }

    <span class='kw'>match</span> <span class='ident'>y</span> {
        <span class='ident'>Value</span>(<span class='ident'>n</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;y is {:d}&quot;</span>, <span class='ident'>n</span>),
        <span class='ident'>Missing</span>  <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;y is missing!&quot;</span>),
    }
}
</pre>

<p>This enum represents an <code>int</code> that we may or may not have. In the <code>Missing</code>
case, we have no value, but in the <code>Value</code> case, we do. This enum is specific
to <code>int</code>s, though. We can make it usable by any type, but we haven&#39;t quite
gotten there yet!</p>

<p>You can have any number of values in an enum:</p>
<span id='rust-example-raw-51' class='rusttest'>fn main() {
    enum OptionalColor {
        Color(int, int, int),
        Missing
    }
}</span><pre id='rust-example-rendered-51' class='rust '>
<span class='kw'>enum</span> <span class='ident'>OptionalColor</span> {
    <span class='ident'>Color</span>(<span class='ident'>int</span>, <span class='ident'>int</span>, <span class='ident'>int</span>),
    <span class='ident'>Missing</span>
}
</pre>

<p>Enums with values are quite useful, but as I mentioned, they&#39;re even more
useful when they&#39;re generic across types. But before we get to generics, let&#39;s
talk about how to fix this big <code>if</code>/<code>else</code> statements we&#39;ve been writing. We&#39;ll
do that with <code>match</code>.</p>

<h1 id="match" class='section-header'><a
                           href="#match">10 Match</a></h1>
<p>Often, a simple <code>if</code>/<code>else</code> isn&#39;t enough, because you have more than two
possible options. And <code>else</code> conditions can get incredibly complicated. So
what&#39;s the solution?</p>

<p>Rust has a keyword, <code>match</code>, that allows you to replace complicated <code>if</code>/<code>else</code>
groupings with something more powerful. Check it out:</p>
<span id='rust-example-raw-52' class='rusttest'>fn main() {
    let x = 5i;
    
    match x {
        1 =&gt; println!(&quot;one&quot;),
        2 =&gt; println!(&quot;two&quot;),
        3 =&gt; println!(&quot;three&quot;),
        4 =&gt; println!(&quot;four&quot;),
        5 =&gt; println!(&quot;five&quot;),
        _ =&gt; println!(&quot;something else&quot;),
    }
}</span><pre id='rust-example-rendered-52' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5i</span>;

<span class='kw'>match</span> <span class='ident'>x</span> {
    <span class='number'>1</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;one&quot;</span>),
    <span class='number'>2</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;two&quot;</span>),
    <span class='number'>3</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;three&quot;</span>),
    <span class='number'>4</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;four&quot;</span>),
    <span class='number'>5</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;five&quot;</span>),
    _ <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;something else&quot;</span>),
}
</pre>

<p><code>match</code> takes an expression, and then branches based on its value. Each &#39;arm&#39; of
the branch is of the form <code>val =&gt; expression</code>. When the value matches, that arm&#39;s
expression will be evaluated. It&#39;s called <code>match</code> because of the term &#39;pattern
matching,&#39; which <code>match</code> is an implementation of.</p>

<p>So what&#39;s the big advantage here? Well, there are a few. First of all, <code>match</code>
does &#39;exhaustiveness checking.&#39; Do you see that last arm, the one with the
underscore (<code>_</code>)? If we remove that arm, Rust will give us an error:</p>

<pre><code class="language-{ignore,notrust}">error: non-exhaustive patterns: `_` not covered</code></pre>

<p>In other words, Rust is trying to tell us we forgot a value. Because <code>x</code> is an
integer, Rust knows that it can have a number of different values. For example,
<code>6i</code>. But without the <code>_</code>, there is no arm that could match, and so Rust refuses
to compile. <code>_</code> is sort of like a catch-all arm. If none of the other arms match,
the arm with <code>_</code> will. And since we have this catch-all arm, we now have an arm
for every possible value of <code>x</code>, and so our program will now compile.</p>

<p><code>match</code> statements also destructure enums, as well. Remember this code from the
section on enums?</p>
<span id='rust-example-raw-53' class='rusttest'>fn cmp(a: int, b: int) -&gt; Ordering {
    if a &lt; b { Less }
    else if a &gt; b { Greater }
    else { Equal }
}

fn main() {
    let x = 5i;
    let y = 10i;

    let ordering = cmp(x, y);

    if ordering == Less {
        println!(&quot;less&quot;);
    } else if ordering == Greater {
        println!(&quot;greater&quot;);
    } else if ordering == Equal {
        println!(&quot;equal&quot;);
    }
}</span><pre id='rust-example-rendered-53' class='rust '>
<span class='kw'>fn</span> <span class='ident'>cmp</span>(<span class='ident'>a</span>: <span class='ident'>int</span>, <span class='ident'>b</span>: <span class='ident'>int</span>) <span class='op'>-&gt;</span> <span class='ident'>Ordering</span> {
    <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&lt;</span> <span class='ident'>b</span> { <span class='ident'>Less</span> }
    <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&gt;</span> <span class='ident'>b</span> { <span class='ident'>Greater</span> }
    <span class='kw'>else</span> { <span class='ident'>Equal</span> }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5i</span>;
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>10i</span>;

    <span class='kw'>let</span> <span class='ident'>ordering</span> <span class='op'>=</span> <span class='ident'>cmp</span>(<span class='ident'>x</span>, <span class='ident'>y</span>);

    <span class='kw'>if</span> <span class='ident'>ordering</span> <span class='op'>==</span> <span class='ident'>Less</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;less&quot;</span>);
    } <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>ordering</span> <span class='op'>==</span> <span class='ident'>Greater</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;greater&quot;</span>);
    } <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>ordering</span> <span class='op'>==</span> <span class='ident'>Equal</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;equal&quot;</span>);
    }
}
</pre>

<p>We can re-write this as a <code>match</code>:</p>
<span id='rust-example-raw-54' class='rusttest'>fn cmp(a: int, b: int) -&gt; Ordering {
    if a &lt; b { Less }
    else if a &gt; b { Greater }
    else { Equal }
}

fn main() {
    let x = 5i;
    let y = 10i;

    match cmp(x, y) {
        Less    =&gt; println!(&quot;less&quot;),
        Greater =&gt; println!(&quot;greater&quot;),
        Equal   =&gt; println!(&quot;equal&quot;),
    }
}</span><pre id='rust-example-rendered-54' class='rust '>
<span class='kw'>fn</span> <span class='ident'>cmp</span>(<span class='ident'>a</span>: <span class='ident'>int</span>, <span class='ident'>b</span>: <span class='ident'>int</span>) <span class='op'>-&gt;</span> <span class='ident'>Ordering</span> {
    <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&lt;</span> <span class='ident'>b</span> { <span class='ident'>Less</span> }
    <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&gt;</span> <span class='ident'>b</span> { <span class='ident'>Greater</span> }
    <span class='kw'>else</span> { <span class='ident'>Equal</span> }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5i</span>;
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>10i</span>;

    <span class='kw'>match</span> <span class='ident'>cmp</span>(<span class='ident'>x</span>, <span class='ident'>y</span>) {
        <span class='ident'>Less</span>    <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;less&quot;</span>),
        <span class='ident'>Greater</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;greater&quot;</span>),
        <span class='ident'>Equal</span>   <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;equal&quot;</span>),
    }
}
</pre>

<p>This version has way less noise, and it also checks exhaustively to make sure
that we have covered all possible variants of <code>Ordering</code>. With our <code>if</code>/<code>else</code>
version, if we had forgotten the <code>Greater</code> case, for example, our program would
have happily compiled. If we forget in the <code>match</code>, it will not. Rust helps us
make sure to cover all of our bases.</p>

<p><code>match</code> is also an expression, which means we can use it on the right hand side
of a <code>let</code> binding. We could also implement the previous line like this:</p>
<span id='rust-example-raw-55' class='rusttest'>fn cmp(a: int, b: int) -&gt; Ordering {
    if a &lt; b { Less }
    else if a &gt; b { Greater }
    else { Equal }
}

fn main() {
    let x = 5i;
    let y = 10i;

    let result = match cmp(x, y) {
        Less    =&gt; &quot;less&quot;,
        Greater =&gt; &quot;greater&quot;,
        Equal   =&gt; &quot;equal&quot;,
    };

    println!(&quot;{}&quot;, result);
}</span><pre id='rust-example-rendered-55' class='rust '>
<span class='kw'>fn</span> <span class='ident'>cmp</span>(<span class='ident'>a</span>: <span class='ident'>int</span>, <span class='ident'>b</span>: <span class='ident'>int</span>) <span class='op'>-&gt;</span> <span class='ident'>Ordering</span> {
    <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&lt;</span> <span class='ident'>b</span> { <span class='ident'>Less</span> }
    <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&gt;</span> <span class='ident'>b</span> { <span class='ident'>Greater</span> }
    <span class='kw'>else</span> { <span class='ident'>Equal</span> }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5i</span>;
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>10i</span>;

    <span class='kw'>let</span> <span class='ident'>result</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>cmp</span>(<span class='ident'>x</span>, <span class='ident'>y</span>) {
        <span class='ident'>Less</span>    <span class='op'>=&gt;</span> <span class='string'>&quot;less&quot;</span>,
        <span class='ident'>Greater</span> <span class='op'>=&gt;</span> <span class='string'>&quot;greater&quot;</span>,
        <span class='ident'>Equal</span>   <span class='op'>=&gt;</span> <span class='string'>&quot;equal&quot;</span>,
    };

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>result</span>);
}
</pre>

<p>In this case, it doesn&#39;t make a lot of sense, as we are just making a temporary
string where we don&#39;t need to, but sometimes, it&#39;s a nice pattern.</p>

<h1 id="looping" class='section-header'><a
                           href="#looping">11 Looping</a></h1>
<p>Looping is the last basic construct that we haven&#39;t learned yet in Rust. Rust has
two main looping constructs: <code>for</code> and <code>while</code>.</p>

<h2 id="for" class='section-header'><a
                           href="#for">11.1 <code>for</code></a></h2>
<p>The <code>for</code> loop is used to loop a particular number of times. Rust&#39;s <code>for</code> loops
work a bit differently than in other systems languages, however. Rust&#39;s <code>for</code>
loop doesn&#39;t look like this C <code>for</code> loop:</p>
<span id='rust-example-raw-56' class='rusttest'>fn main() {
    for (x = 0; x &lt; 10; x++) {
        printf( &quot;%d\n&quot;, x );
    }
}</span><pre id='rust-example-rendered-56' class='rust '>
<span class='kw'>for</span> (<span class='ident'>x</span> <span class='op'>=</span> <span class='number'>0</span>; <span class='ident'>x</span> <span class='op'>&lt;</span> <span class='number'>10</span>; <span class='ident'>x</span><span class='op'>+</span><span class='op'>+</span>) {
    <span class='ident'>printf</span>( <span class='string'>&quot;%d\n&quot;</span>, <span class='ident'>x</span> );
}
</pre>

<p>It looks like this:</p>
<span id='rust-example-raw-57' class='rusttest'>fn main() {
    for x in range(0i, 10i) {
        println!(&quot;{:d}&quot;, x);
    }
}</span><pre id='rust-example-rendered-57' class='rust '>
<span class='kw'>for</span> <span class='ident'>x</span> <span class='kw'>in</span> <span class='ident'>range</span>(<span class='number'>0i</span>, <span class='number'>10i</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:d}&quot;</span>, <span class='ident'>x</span>);
}
</pre>

<p>In slightly more abstract terms,</p>

<pre><code class="language-{ignore,notrust}">for var in expression {
    code
}</code></pre>

<p>The expression is an iterator, which we will discuss in more depth later in the
guide. The iterator gives back a series of elements. Each element is one
iteration of the loop. That value is then bound to the name <code>var</code>, which is
valid for the loop body. Once the body is over, the next value is fetched from
the iterator, and we loop another time. When there are no more values, the
<code>for</code> loop is over.</p>

<p>In our example, the <code>range</code> function is a function, provided by Rust, that
takes a start and an end position, and gives an iterator over those values. The
upper bound is exclusive, though, so our loop will print <code>0</code> through <code>9</code>, not
<code>10</code>.</p>

<p>Rust does not have the &quot;C style&quot; <code>for</code> loop on purpose. Manually controlling
each element of the loop is complicated and error prone, even for experienced C
developers. There&#39;s an old joke that goes, &quot;There are two hard problems in
computer science: naming things, cache invalidation, and off-by-one errors.&quot;
The joke, of course, being that the setup says &quot;two hard problems&quot; but then
lists three things. This happens quite a bit with &quot;C style&quot; <code>for</code> loops.</p>

<p>We&#39;ll talk more about <code>for</code> when we cover <strong>vector</strong>s, later in the Guide.</p>

<h2 id="while" class='section-header'><a
                           href="#while">11.2 <code>while</code></a></h2>
<p>The other kind of looping construct in Rust is the <code>while</code> loop. It looks like
this:</p>
<span id='rust-example-raw-58' class='rusttest'>fn main() {
    let mut x = 5u;
    let mut done = false;
    
    while !done {
        x += x - 3;
        println!(&quot;{}&quot;, x);
        if x % 5 == 0 { done = true; }
    }
}</span><pre id='rust-example-rendered-58' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5u</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>done</span> <span class='op'>=</span> <span class='boolval'>false</span>;

<span class='kw'>while</span> <span class='op'>!</span><span class='ident'>done</span> {
    <span class='ident'>x</span> <span class='op'>+=</span> <span class='ident'>x</span> <span class='op'>-</span> <span class='number'>3</span>;
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);
    <span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>%</span> <span class='number'>5</span> <span class='op'>==</span> <span class='number'>0</span> { <span class='ident'>done</span> <span class='op'>=</span> <span class='boolval'>true</span>; }
}
</pre>

<p><code>while</code> loops are the correct choice when you&#39;re not sure how many times
you need to loop. </p>

<p>If you need an infinite loop, you may be tempted to write this:</p>
<span id='rust-example-raw-59' class='rusttest'>fn main() {
    while true {
}</span><pre id='rust-example-rendered-59' class='rust '>
<span class='kw'>while</span> <span class='boolval'>true</span> {
</pre>

<p>Rust has a dedicated keyword, <code>loop</code>, to handle this case:</p>
<span id='rust-example-raw-60' class='rusttest'>fn main() {
    loop {
}</span><pre id='rust-example-rendered-60' class='rust '>
<span class='kw'>loop</span> {
</pre>

<p>Rust&#39;s control-flow analysis treats this construct differently than a
<code>while true</code>, since we know that it will always loop. The details of what
that <em>means</em> aren&#39;t super important to understand at this stage, but in
general, the more information we can give to the compiler, the better it
can do with safety and code generation. So you should always prefer
<code>loop</code> when you plan to loop infinitely.</p>

<h2 id="ending-iteration-early" class='section-header'><a
                           href="#ending-iteration-early">11.3 Ending iteration early</a></h2>
<p>Let&#39;s take a look at that <code>while</code> loop we had earlier:</p>
<span id='rust-example-raw-61' class='rusttest'>fn main() {
    let mut x = 5u;
    let mut done = false;
    
    while !done {
        x += x - 3;
        println!(&quot;{}&quot;, x);
        if x % 5 == 0 { done = true; }
    }
}</span><pre id='rust-example-rendered-61' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5u</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>done</span> <span class='op'>=</span> <span class='boolval'>false</span>;

<span class='kw'>while</span> <span class='op'>!</span><span class='ident'>done</span> {
    <span class='ident'>x</span> <span class='op'>+=</span> <span class='ident'>x</span> <span class='op'>-</span> <span class='number'>3</span>;
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);
    <span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>%</span> <span class='number'>5</span> <span class='op'>==</span> <span class='number'>0</span> { <span class='ident'>done</span> <span class='op'>=</span> <span class='boolval'>true</span>; }
}
</pre>

<p>We had to keep a dedicated <code>mut</code> boolean variable binding, <code>done</code>, to know
when we should skip out of the loop. Rust has two keywords to help us with
modifying iteration: <code>break</code> and <code>continue</code>.</p>

<p>In this case, we can write the loop in a better way with <code>break</code>:</p>
<span id='rust-example-raw-62' class='rusttest'>fn main() {
    let mut x = 5u;
    
    loop {
        x += x - 3;
        println!(&quot;{}&quot;, x);
        if x % 5 == 0 { break; }
    }
}</span><pre id='rust-example-rendered-62' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5u</span>;

<span class='kw'>loop</span> {
    <span class='ident'>x</span> <span class='op'>+=</span> <span class='ident'>x</span> <span class='op'>-</span> <span class='number'>3</span>;
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);
    <span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>%</span> <span class='number'>5</span> <span class='op'>==</span> <span class='number'>0</span> { <span class='kw'>break</span>; }
}
</pre>

<p>We now loop forever with <code>loop</code>, and use <code>break</code> to break out early.</p>

<p><code>continue</code> is similar, but instead of ending the loop, goes to the next
iteration: This will only print the odd numbers:</p>
<span id='rust-example-raw-63' class='rusttest'>fn main() {
    for x in range(0i, 10i) {
        if x % 2 == 0 { continue; }
    
        println!(&quot;{:d}&quot;, x);
    }
}</span><pre id='rust-example-rendered-63' class='rust '>
<span class='kw'>for</span> <span class='ident'>x</span> <span class='kw'>in</span> <span class='ident'>range</span>(<span class='number'>0i</span>, <span class='number'>10i</span>) {
    <span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>%</span> <span class='number'>2</span> <span class='op'>==</span> <span class='number'>0</span> { <span class='kw'>continue</span>; }

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:d}&quot;</span>, <span class='ident'>x</span>);
}
</pre>

<p>Both <code>continue</code> and <code>break</code> are valid in both kinds of loops.</p>

<p>We have now learned all of the most basic Rust concepts. We&#39;re ready to start
building our guessing game, but we need to know how to do one last thing first:
get input from the keyboard. You can&#39;t have a guessing game without the ability
to guess!</p>

<h1 id="standard-input" class='section-header'><a
                           href="#standard-input">12 Standard Input</a></h1>
<p>Getting input from the keyboard is pretty easy, but uses some things
we haven&#39;t seen before. Here&#39;s a simple program that reads some input,
and then prints it back out:</p>
<span id='rust-example-raw-64' class='rusttest'>use std::io;

fn main() {
    println!(&quot;Type something!&quot;);

    let input = std::io::stdin().read_line().ok().expect(&quot;Failed to read line&quot;);

    println!(&quot;{}&quot;, input);
}</span><pre id='rust-example-rendered-64' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Type something!&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>input</span> <span class='op'>=</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>().<span class='ident'>ok</span>().<span class='ident'>expect</span>(<span class='string'>&quot;Failed to read line&quot;</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>input</span>);
}
</pre>

<p>Let&#39;s go over these chunks, one by one:</p>
<span id='rust-example-raw-65' class='rusttest'>fn main() {
    std::io::stdin();
}</span><pre id='rust-example-rendered-65' class='rust '>
<span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>stdin</span>();
</pre>

<p>This calls a function, <code>stdin()</code>, that lives inside the <code>std::io</code> module. As
you can imagine, everything in <code>std</code> is provided by Rust, the &#39;standard
library.&#39; We&#39;ll talk more about the module system later.</p>

<p>Since writing the fully qualified name all the time is annoying, we can use
the <code>use</code> statement to import it in:</p>
<span id='rust-example-raw-66' class='rusttest'>fn main() {
    use std::io::stdin;
    
    stdin();
}</span><pre id='rust-example-rendered-66' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>stdin</span>;

<span class='ident'>stdin</span>();
</pre>

<p>However, it&#39;s considered better practice to not import individual functions, but
to import the module, and only use one level of qualification:</p>
<span id='rust-example-raw-67' class='rusttest'>fn main() {
    use std::io;
    
    io::stdin();
}</span><pre id='rust-example-rendered-67' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;

<span class='ident'>io</span>::<span class='ident'>stdin</span>();
</pre>

<p>Let&#39;s update our example to use this style:</p>
<span id='rust-example-raw-68' class='rusttest'>use std::io;

fn main() {
    println!(&quot;Type something!&quot;);

    let input = io::stdin().read_line().ok().expect(&quot;Failed to read line&quot;);

    println!(&quot;{}&quot;, input);
}</span><pre id='rust-example-rendered-68' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Type something!&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>input</span> <span class='op'>=</span> <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>().<span class='ident'>ok</span>().<span class='ident'>expect</span>(<span class='string'>&quot;Failed to read line&quot;</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>input</span>);
}
</pre>

<p>Next up:</p>
<span id='rust-example-raw-69' class='rusttest'>fn main() {
    .read_line()
}</span><pre id='rust-example-rendered-69' class='rust '>
.<span class='ident'>read_line</span>()
</pre>

<p>The <code>read_line()</code> method can be called on the result of <code>stdin()</code> to return
a full line of input. Nice and easy.</p>
<span id='rust-example-raw-70' class='rusttest'>fn main() {
    .ok().expect(&quot;Failed to read line&quot;);
}</span><pre id='rust-example-rendered-70' class='rust '>
.<span class='ident'>ok</span>().<span class='ident'>expect</span>(<span class='string'>&quot;Failed to read line&quot;</span>);
</pre>

<p>Do you remember this code? </p>
<span id='rust-example-raw-71' class='rusttest'>enum OptionalInt {
    Value(int),
    Missing,
}

fn main() {
    let x = Value(5);
    let y = Missing;

    match x {
        Value(n) =&gt; println!(&quot;x is {:d}&quot;, n),
        Missing  =&gt; println!(&quot;x is missing!&quot;),
    }

    match y {
        Value(n) =&gt; println!(&quot;y is {:d}&quot;, n),
        Missing  =&gt; println!(&quot;y is missing!&quot;),
    }
}</span><pre id='rust-example-rendered-71' class='rust '>
<span class='kw'>enum</span> <span class='ident'>OptionalInt</span> {
    <span class='ident'>Value</span>(<span class='ident'>int</span>),
    <span class='ident'>Missing</span>,
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Value</span>(<span class='number'>5</span>);
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='ident'>Missing</span>;

    <span class='kw'>match</span> <span class='ident'>x</span> {
        <span class='ident'>Value</span>(<span class='ident'>n</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x is {:d}&quot;</span>, <span class='ident'>n</span>),
        <span class='ident'>Missing</span>  <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x is missing!&quot;</span>),
    }

    <span class='kw'>match</span> <span class='ident'>y</span> {
        <span class='ident'>Value</span>(<span class='ident'>n</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;y is {:d}&quot;</span>, <span class='ident'>n</span>),
        <span class='ident'>Missing</span>  <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;y is missing!&quot;</span>),
    }
}
</pre>

<p>We had to match each time, to see if we had a value or not. In this case,
though, we <em>know</em> that <code>x</code> has a <code>Value</code>. But <code>match</code> forces us to handle
the <code>missing</code> case. This is what we want 99% of the time, but sometimes, we
know better than the compiler.</p>

<p>Likewise, <code>read_line()</code> does not return a line of input. It <em>might</em> return a
line of input. It might also fail to do so. This could happen if our program
isn&#39;t running in a terminal, but as part of a cron job, or some other context
where there&#39;s no standard input. Because of this, <code>read_line</code> returns a type
very similar to our <code>OptionalInt</code>: an <code>IoResult&lt;T&gt;</code>. We haven&#39;t talked about
<code>IoResult&lt;T&gt;</code> yet because it is the <strong>generic</strong> form of our <code>OptionalInt</code>.
Until then, you can think of it as being the same thing, just for any type, not
just <code>int</code>s.</p>

<p>Rust provides a method on these <code>IoResult&lt;T&gt;</code>s called <code>ok()</code>, which does the
same thing as our <code>match</code> statement, but assuming that we have a valid value.
If we don&#39;t, it will terminate our program. In this case, if we can&#39;t get
input, our program doesn&#39;t work, so we&#39;re okay with that. In most cases, we
would want to handle the error case explicitly. The result of <code>ok()</code> has a
method, <code>expect()</code>, which allows us to give an error message if this crash
happens.</p>

<p>We will cover the exact details of how all of this works later in the Guide.
For now, this gives you enough of a basic understanding to work with.</p>

<p>Back to the code we were working on! Here&#39;s a refresher:</p>
<span id='rust-example-raw-72' class='rusttest'>use std::io;

fn main() {
    println!(&quot;Type something!&quot;);

    let input = io::stdin().read_line().ok().expect(&quot;Failed to read line&quot;);

    println!(&quot;{}&quot;, input);
}</span><pre id='rust-example-rendered-72' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Type something!&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>input</span> <span class='op'>=</span> <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>().<span class='ident'>ok</span>().<span class='ident'>expect</span>(<span class='string'>&quot;Failed to read line&quot;</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>input</span>);
}
</pre>

<p>With long lines like this, Rust gives you some flexibility with the whitespace.
We <em>could</em> write the example like this:</p>
<span id='rust-example-raw-73' class='rusttest'>use std::io;

fn main() {
    println!(&quot;Type something!&quot;);

    let input = io::stdin()
                  .read_line()
                  .ok()
                  .expect(&quot;Failed to read line&quot;);

    println!(&quot;{}&quot;, input);
}</span><pre id='rust-example-rendered-73' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Type something!&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>input</span> <span class='op'>=</span> <span class='ident'>io</span>::<span class='ident'>stdin</span>()
                  .<span class='ident'>read_line</span>()
                  .<span class='ident'>ok</span>()
                  .<span class='ident'>expect</span>(<span class='string'>&quot;Failed to read line&quot;</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>input</span>);
}
</pre>

<p>Sometimes, this makes things more readable. Sometimes, less. Use your judgement
here.</p>

<p>That&#39;s all you need to get basic input from the standard input! It&#39;s not too
complicated, but there are a number of small parts.</p>

<h1 id="guessing-game" class='section-header'><a
                           href="#guessing-game">13 Guessing Game</a></h1>
<p>Okay! We&#39;ve got the basics of Rust down. Let&#39;s write a bigger program.</p>

<p>For our first project, we&#39;ll implement a classic beginner programming problem:
the guessing game. Here&#39;s how it works: Our program will generate a random
integer between one and a hundred. It will then prompt us to enter a guess.
Upon entering our guess, it will tell us if we&#39;re too low or too high. Once we
guess correctly, it will congratulate us, and print the number of guesses we&#39;ve
taken to the screen. Sound good?</p>

<h2 id="set-up" class='section-header'><a
                           href="#set-up">13.1 Set up</a></h2>
<p>Let&#39;s set up a new project. Go to your projects directory, and make a new
directory for the project, as well as a <code>src</code> directory for our code:</p>

<pre><code class="language-{bash}">$ cd ~/projects
$ mkdir guessing_game
$ cd guessing_game
$ mkdir src</code></pre>

<p>Great. Next, let&#39;s make a <code>Cargo.toml</code> file so Cargo knows how to build our
project:</p>
<span id='rust-example-raw-74' class='rusttest'>fn main() {
    [package]
    
    name = &quot;guessing_game&quot;
    version = &quot;0.1.0&quot;
    authors = [ &quot;someone@example.com&quot; ]
    
    [[bin]]
    
    name = &quot;guessing_game&quot;
}</span><pre id='rust-example-rendered-74' class='rust '>
[<span class='ident'>package</span>]

<span class='ident'>name</span> <span class='op'>=</span> <span class='string'>&quot;guessing_game&quot;</span>
<span class='ident'>version</span> <span class='op'>=</span> <span class='string'>&quot;0.1.0&quot;</span>
<span class='ident'>authors</span> <span class='op'>=</span> [ <span class='string'>&quot;someone@example.com&quot;</span> ]

[[<span class='ident'>bin</span>]]

<span class='ident'>name</span> <span class='op'>=</span> <span class='string'>&quot;guessing_game&quot;</span>
</pre>

<p>Finally, we need our source file. Let&#39;s just make it hello world for now, so we
can check that our setup works. In <code>src/guessing_game.rs</code>:</p>
<span id='rust-example-raw-75' class='rusttest'>fn main() {
    println!(&quot;Hello world!&quot;);
}</span><pre id='rust-example-rendered-75' class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello world!&quot;</span>);
}
</pre>

<p>Let&#39;s make sure that worked:</p>

<pre><code class="language-{bash}">$ cargo build
   Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)
$</code></pre>

<p>Excellent! Open up your <code>src/guessing_game.rs</code> again. We&#39;ll be writing all of
our code in this file. We&#39;ll talk about multiple-file projects later on in the
guide.</p>

<h2 id="processing-a-guess" class='section-header'><a
                           href="#processing-a-guess">13.2 Processing a Guess</a></h2>
<p>Let&#39;s get to it! The first thing we need to do for our guessing game is
allow our player to input a guess. Put this in your <code>src/guessing_game.rs</code>:</p>
<span id='rust-example-raw-76' class='rusttest'>use std::io;

fn main() {
    println!(&quot;Guess the number!&quot;);

    println!(&quot;Please input your guess.&quot;);

    let input = io::stdin().read_line()
                           .ok()
                           .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, input);
}</span><pre id='rust-example-rendered-76' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Guess the number!&quot;</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Please input your guess.&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>input</span> <span class='op'>=</span> <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>()
                           .<span class='ident'>ok</span>()
                           .<span class='ident'>expect</span>(<span class='string'>&quot;Failed to read line&quot;</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You guessed: {}&quot;</span>, <span class='ident'>input</span>);
}
</pre>

<p>You&#39;ve seen this code before, when we talked about standard input. We
import the <code>std::io</code> module with <code>use</code>, and then our <code>main</code> function contains
our program&#39;s logic. We print a little message announcing the game, ask the
user to input a guess, get their input, and then print it out.</p>

<p>Because we talked about this in the section on standard I/O, I won&#39;t go into
more details here. If you need a refresher, go re-read that section.</p>

<h2 id="generating-a-secret-number" class='section-header'><a
                           href="#generating-a-secret-number">13.3 Generating a secret number</a></h2>
<p>Next, we need to generate a secret number. To do that, we need to use Rust&#39;s
random number generation, which we haven&#39;t talked about yet. Rust includes a
bunch of interesting functions in its standard library. If you need a bit of
code, it&#39;s possible that it&#39;s already been written for you! In this case,
we do know that Rust has random number generation, but we don&#39;t know how to
use it.</p>

<p>Enter the docs. Rust has a page specifically to document the standard library.
You can find that page <a href="std/index.html">here</a>. There&#39;s a lot of information on
that page, but the best part is the search bar. Right up at the top, there&#39;s
a box that you can enter in a search term. The search is pretty primitive
right now, but is getting better all the time. If you type &#39;random&#39; in that
box, the page will update to <a href="http://doc.rust-lang.org/std/index.html?search=random">this
one</a>. The very first
result is a link to
<a href="http://doc.rust-lang.org/std/rand/fn.random.html">std::rand::random</a>. If we
click on that result, we&#39;ll be taken to its documentation page.</p>

<p>This page shows us a few things: the type signature of the function, some
explanatory text, and then an example. Let&#39;s modify our code to add in the
<code>random</code> function:</p>
<span id='rust-example-raw-77' class='rusttest'>use std::io;
use std::rand;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = (rand::random() % 100i) + 1i;

    println!(&quot;The secret number is: {}&quot;, secret_number);

    println!(&quot;Please input your guess.&quot;);

    let input = io::stdin().read_line()
                           .ok()
                           .expect(&quot;Failed to read line&quot;);


    println!(&quot;You guessed: {}&quot;, input);
}</span><pre id='rust-example-rendered-77' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>rand</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Guess the number!&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>secret_number</span> <span class='op'>=</span> (<span class='ident'>rand</span>::<span class='ident'>random</span>() <span class='op'>%</span> <span class='number'>100i</span>) <span class='op'>+</span> <span class='number'>1i</span>;

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The secret number is: {}&quot;</span>, <span class='ident'>secret_number</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Please input your guess.&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>input</span> <span class='op'>=</span> <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>()
                           .<span class='ident'>ok</span>()
                           .<span class='ident'>expect</span>(<span class='string'>&quot;Failed to read line&quot;</span>);


    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You guessed: {}&quot;</span>, <span class='ident'>input</span>);
}
</pre>

<p>The first thing we changed was to <code>use std::rand</code>, as the docs
explained.  We then added in a <code>let</code> expression to create a variable binding
named <code>secret_number</code>, and we printed out its result. Let&#39;s try to compile
this using <code>cargo build</code>:</p>

<pre><code class="language-{notrust,no_run}">$ cargo build
   Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)
src/guessing_game.rs:7:26: 7:34 error: the type of this value must be known in this context
src/guessing_game.rs:7     let secret_number = (rand::random() % 100i) + 1i;
                                                ^~~~~~~~
error: aborting due to previous error</code></pre>

<p>It didn&#39;t work! Rust says &quot;the type of this value must be known in this
context.&quot; What&#39;s up with that? Well, as it turns out, <code>rand::random()</code> can
generate many kinds of random values, not just integers. And in this case, Rust
isn&#39;t sure what kind of value <code>random()</code> should generate. So we have to help
it. With number literals, we just add an <code>i</code> onto the end to tell Rust they&#39;re
integers, but that does not work with functions. There&#39;s a different syntax,
and it looks like this:</p>
<span id='rust-example-raw-78' class='rusttest'>fn main() {
    rand::random::&lt;int&gt;();
}</span><pre id='rust-example-rendered-78' class='rust '>
<span class='ident'>rand</span>::<span class='ident'>random</span>::<span class='op'>&lt;</span><span class='ident'>int</span><span class='op'>&gt;</span>();
</pre>

<p>This says &quot;please give me a random <code>int</code> value.&quot; We can change our code to use
this hint...</p>
<span id='rust-example-raw-79' class='rusttest'>use std::io;
use std::rand;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = (rand::random::&lt;int&gt;() % 100i) + 1i;

    println!(&quot;The secret number is: {}&quot;, secret_number);

    println!(&quot;Please input your guess.&quot;);

    let input = io::stdin().read_line()
                           .ok()
                           .expect(&quot;Failed to read line&quot;);


    println!(&quot;You guessed: {}&quot;, input);
}</span><pre id='rust-example-rendered-79' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>rand</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Guess the number!&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>secret_number</span> <span class='op'>=</span> (<span class='ident'>rand</span>::<span class='ident'>random</span>::<span class='op'>&lt;</span><span class='ident'>int</span><span class='op'>&gt;</span>() <span class='op'>%</span> <span class='number'>100i</span>) <span class='op'>+</span> <span class='number'>1i</span>;

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The secret number is: {}&quot;</span>, <span class='ident'>secret_number</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Please input your guess.&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>input</span> <span class='op'>=</span> <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>()
                           .<span class='ident'>ok</span>()
                           .<span class='ident'>expect</span>(<span class='string'>&quot;Failed to read line&quot;</span>);


    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You guessed: {}&quot;</span>, <span class='ident'>input</span>);
}
</pre>

<p>... and then recompile:</p>

<pre><code class="language-{notrust,ignore}">$ cargo build
  Compiling guessing_game v0.1.0 (file:/home/steve/tmp/guessing_game)
$</code></pre>

<p>Excellent! Try running our new program a few times:</p>

<pre><code class="language-{notrust,ignore}">$ ./target/guessing_game 
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4
$ ./target/guessing_game 
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
$ ./target/guessing_game 
Guess the number!
The secret number is: -29
Please input your guess.
42
You guessed: 42</code></pre>

<p>Wait. Negative 29? We wanted a number between one and a hundred! We have two
options here: we can either ask <code>random()</code> to generate an unsigned integer, which
can only be positive, or we can use the <code>abs()</code> function. Let&#39;s go with the
unsigned integer approach. If we want a random positive number, we should ask for
a random positive number. Our code looks like this now:</p>
<span id='rust-example-raw-80' class='rusttest'>use std::io;
use std::rand;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = (rand::random::&lt;uint&gt;() % 100u) + 1u;

    println!(&quot;The secret number is: {}&quot;, secret_number);

    println!(&quot;Please input your guess.&quot;);

    let input = io::stdin().read_line()
                           .ok()
                           .expect(&quot;Failed to read line&quot;);


    println!(&quot;You guessed: {}&quot;, input);
}</span><pre id='rust-example-rendered-80' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>rand</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Guess the number!&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>secret_number</span> <span class='op'>=</span> (<span class='ident'>rand</span>::<span class='ident'>random</span>::<span class='op'>&lt;</span><span class='ident'>uint</span><span class='op'>&gt;</span>() <span class='op'>%</span> <span class='number'>100u</span>) <span class='op'>+</span> <span class='number'>1u</span>;

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The secret number is: {}&quot;</span>, <span class='ident'>secret_number</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Please input your guess.&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>input</span> <span class='op'>=</span> <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>()
                           .<span class='ident'>ok</span>()
                           .<span class='ident'>expect</span>(<span class='string'>&quot;Failed to read line&quot;</span>);


    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You guessed: {}&quot;</span>, <span class='ident'>input</span>);
}
</pre>

<p>And trying it out:</p>

<pre><code class="language-{notrust,ignore}">$ cargo build
   Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)
$ ./target/guessing_game 
Guess the number!
The secret number is: 57
Please input your guess.
3
You guessed: 3</code></pre>

<p>Great! Next up: let&#39;s compare our guess to the secret guess.</p>

<h2 id="comparing-guesses" class='section-header'><a
                           href="#comparing-guesses">13.4 Comparing guesses</a></h2>
<p>If you remember, earlier in the tutorial, we made a <code>cmp</code> function that compared
two numbers. Let&#39;s add that in, along with a <code>match</code> statement to compare the
guess to the secret guess:</p>
<span id='rust-example-raw-81' class='rusttest'>use std::io;
use std::rand;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = (rand::random::&lt;uint&gt;() % 100u) + 1u;

    println!(&quot;The secret number is: {}&quot;, secret_number);

    println!(&quot;Please input your guess.&quot;);

    let input = io::stdin().read_line()
                           .ok()
                           .expect(&quot;Failed to read line&quot;);


    println!(&quot;You guessed: {}&quot;, input);

    match cmp(input, secret_number) { 
        Less    =&gt; println!(&quot;Too small!&quot;),
        Greater =&gt; println!(&quot;Too big!&quot;),
        Equal   =&gt; { println!(&quot;You win!&quot;); },
    }
}

fn cmp(a: int, b: int) -&gt; Ordering {
    if a &lt; b { Less }
    else if a &gt; b { Greater }
    else { Equal }
}</span><pre id='rust-example-rendered-81' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>rand</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Guess the number!&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>secret_number</span> <span class='op'>=</span> (<span class='ident'>rand</span>::<span class='ident'>random</span>::<span class='op'>&lt;</span><span class='ident'>uint</span><span class='op'>&gt;</span>() <span class='op'>%</span> <span class='number'>100u</span>) <span class='op'>+</span> <span class='number'>1u</span>;

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The secret number is: {}&quot;</span>, <span class='ident'>secret_number</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Please input your guess.&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>input</span> <span class='op'>=</span> <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>()
                           .<span class='ident'>ok</span>()
                           .<span class='ident'>expect</span>(<span class='string'>&quot;Failed to read line&quot;</span>);


    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You guessed: {}&quot;</span>, <span class='ident'>input</span>);

    <span class='kw'>match</span> <span class='ident'>cmp</span>(<span class='ident'>input</span>, <span class='ident'>secret_number</span>) { 
        <span class='ident'>Less</span>    <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Too small!&quot;</span>),
        <span class='ident'>Greater</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Too big!&quot;</span>),
        <span class='ident'>Equal</span>   <span class='op'>=&gt;</span> { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You win!&quot;</span>); },
    }
}

<span class='kw'>fn</span> <span class='ident'>cmp</span>(<span class='ident'>a</span>: <span class='ident'>int</span>, <span class='ident'>b</span>: <span class='ident'>int</span>) <span class='op'>-&gt;</span> <span class='ident'>Ordering</span> {
    <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&lt;</span> <span class='ident'>b</span> { <span class='ident'>Less</span> }
    <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&gt;</span> <span class='ident'>b</span> { <span class='ident'>Greater</span> }
    <span class='kw'>else</span> { <span class='ident'>Equal</span> }
}
</pre>

<p>If we try to compile, we&#39;ll get some errors:</p>

<pre><code class="language-{notrust,ignore}">$ cargo build
$ cargo build
   Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)
src/guessing_game.rs:20:15: 20:20 error: mismatched types: expected `int` but found `collections::string::String` (expected int but found struct collections::string::String)
src/guessing_game.rs:20     match cmp(input, secret_number) {
                                      ^~~~~
src/guessing_game.rs:20:22: 20:35 error: mismatched types: expected `int` but found `uint` (expected int but found uint)
src/guessing_game.rs:20     match cmp(input, secret_number) {
                                             ^~~~~~~~~~~~~
error: aborting due to 2 previous errors</code></pre>

<p>This often happens when writing Rust programs, and is one of Rust&#39;s greatest
strengths. You try out some code, see if it compiles, and Rust tells you that
you&#39;ve done something wrong. In this case, our <code>cmp</code> function works on integers,
but we&#39;ve given it unsigned integers. In this case, the fix is easy, because
we wrote the <code>cmp</code> function! Let&#39;s change it to take <code>uint</code>s:</p>
<span id='rust-example-raw-82' class='rusttest'>use std::io;
use std::rand;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = (rand::random::&lt;uint&gt;() % 100u) + 1u;

    println!(&quot;The secret number is: {}&quot;, secret_number);

    println!(&quot;Please input your guess.&quot;);

    let input = io::stdin().read_line()
                           .ok()
                           .expect(&quot;Failed to read line&quot;);


    println!(&quot;You guessed: {}&quot;, input);

    match cmp(input, secret_number) {
        Less    =&gt; println!(&quot;Too small!&quot;),
        Greater =&gt; println!(&quot;Too big!&quot;),
        Equal   =&gt; { println!(&quot;You win!&quot;); },
    }
}

fn cmp(a: uint, b: uint) -&gt; Ordering {
    if a &lt; b { Less }
    else if a &gt; b { Greater }
    else { Equal }
}</span><pre id='rust-example-rendered-82' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>rand</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Guess the number!&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>secret_number</span> <span class='op'>=</span> (<span class='ident'>rand</span>::<span class='ident'>random</span>::<span class='op'>&lt;</span><span class='ident'>uint</span><span class='op'>&gt;</span>() <span class='op'>%</span> <span class='number'>100u</span>) <span class='op'>+</span> <span class='number'>1u</span>;

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The secret number is: {}&quot;</span>, <span class='ident'>secret_number</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Please input your guess.&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>input</span> <span class='op'>=</span> <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>()
                           .<span class='ident'>ok</span>()
                           .<span class='ident'>expect</span>(<span class='string'>&quot;Failed to read line&quot;</span>);


    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You guessed: {}&quot;</span>, <span class='ident'>input</span>);

    <span class='kw'>match</span> <span class='ident'>cmp</span>(<span class='ident'>input</span>, <span class='ident'>secret_number</span>) {
        <span class='ident'>Less</span>    <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Too small!&quot;</span>),
        <span class='ident'>Greater</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Too big!&quot;</span>),
        <span class='ident'>Equal</span>   <span class='op'>=&gt;</span> { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You win!&quot;</span>); },
    }
}

<span class='kw'>fn</span> <span class='ident'>cmp</span>(<span class='ident'>a</span>: <span class='ident'>uint</span>, <span class='ident'>b</span>: <span class='ident'>uint</span>) <span class='op'>-&gt;</span> <span class='ident'>Ordering</span> {
    <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&lt;</span> <span class='ident'>b</span> { <span class='ident'>Less</span> }
    <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&gt;</span> <span class='ident'>b</span> { <span class='ident'>Greater</span> }
    <span class='kw'>else</span> { <span class='ident'>Equal</span> }
}
</pre>

<p>And try compiling again:</p>

<pre><code class="language-{notrust,ignore}">$ cargo build
   Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)
src/guessing_game.rs:20:15: 20:20 error: mismatched types: expected `uint` but found `collections::string::String` (expected uint but found struct collections::string::String)
src/guessing_game.rs:20     match cmp(input, secret_number) {
                                      ^~~~~
error: aborting due to previous error</code></pre>

<p>This error is similar to the last one: we expected to get a <code>uint</code>, but we got
a <code>String</code> instead! That&#39;s because our <code>input</code> variable is coming from the
standard input, and you can guess anything. Try it:</p>

<pre><code class="language-{notrust,ignore}">$ ./target/guessing_game 
Guess the number!
The secret number is: 73
Please input your guess.
hello
You guessed: hello</code></pre>

<p>Oops! Also, you&#39;ll note that we just ran our program even though it didn&#39;t compile.
This works because the older version we did successfully compile was still lying
around. Gotta be careful!</p>

<p>Anyway, we have a <code>String</code>, but we need a <code>uint</code>. What to do? Well, there&#39;s
a function for that:</p>
<span id='rust-example-raw-83' class='rusttest'>fn main() {
    let input = io::stdin().read_line()
                           .ok()
                           .expect(&quot;Failed to read line&quot;);
    let guess: Option&lt;uint&gt; = from_str(input.as_slice());
}</span><pre id='rust-example-rendered-83' class='rust '>
<span class='kw'>let</span> <span class='ident'>input</span> <span class='op'>=</span> <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>()
                       .<span class='ident'>ok</span>()
                       .<span class='ident'>expect</span>(<span class='string'>&quot;Failed to read line&quot;</span>);
<span class='kw'>let</span> <span class='ident'>guess</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>uint</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>from_str</span>(<span class='ident'>input</span>.<span class='ident'>as_slice</span>());
</pre>

<p>The <code>from_str</code> function takes in a <code>&amp;str</code> value and converts it into something.
We tell it what kind of something with a type hint. Remember our type hint with
<code>random()</code>? It looked like this:</p>
<span id='rust-example-raw-84' class='rusttest'>fn main() {
    rand::random::&lt;uint&gt;();
}</span><pre id='rust-example-rendered-84' class='rust '>
<span class='ident'>rand</span>::<span class='ident'>random</span>::<span class='op'>&lt;</span><span class='ident'>uint</span><span class='op'>&gt;</span>();
</pre>

<p>There&#39;s an alternate way of providing a hint too, and that&#39;s declaring the type
in a <code>let</code>:</p>
<span id='rust-example-raw-85' class='rusttest'>fn main() {
    let x: uint = rand::random();
}</span><pre id='rust-example-rendered-85' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>uint</span> <span class='op'>=</span> <span class='ident'>rand</span>::<span class='ident'>random</span>();
</pre>

<p>In this case, we say <code>x</code> is a <code>uint</code> explicitly, so Rust is able to properly
tell <code>random()</code> what to generate. In a similar fashion, both of these work:</p>
<span id='rust-example-raw-86' class='rusttest'>fn main() {
    let guess = from_str::&lt;Option&lt;uint&gt;&gt;(&quot;5&quot;);
    let guess: Option&lt;uint&gt; = from_str(&quot;5&quot;);
}</span><pre id='rust-example-rendered-86' class='rust '>
<span class='kw'>let</span> <span class='ident'>guess</span> <span class='op'>=</span> <span class='ident'>from_str</span>::<span class='op'>&lt;</span><span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>uint</span><span class='op'>&gt;&gt;</span>(<span class='string'>&quot;5&quot;</span>);
<span class='kw'>let</span> <span class='ident'>guess</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>uint</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>from_str</span>(<span class='string'>&quot;5&quot;</span>);
</pre>

<p>In this case, I happen to prefer the latter, and in the <code>random()</code> case, I prefer
the former. I think the nested <code>&lt;&gt;</code>s make the first option especially ugly and
a bit harder to read.</p>

<p>Anyway, with us now convering our input to a number, our code looks like this:</p>
<span id='rust-example-raw-87' class='rusttest'>use std::io;
use std::rand;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = (rand::random::&lt;uint&gt;() % 100u) + 1u;

    println!(&quot;The secret number is: {}&quot;, secret_number);

    println!(&quot;Please input your guess.&quot;);

    let input = io::stdin().read_line()
                           .ok()
                           .expect(&quot;Failed to read line&quot;);
    let input_num: Option&lt;uint&gt; = from_str(input.as_slice());



    println!(&quot;You guessed: {}&quot;, input_num);

    match cmp(input_num, secret_number) {
        Less    =&gt; println!(&quot;Too small!&quot;),
        Greater =&gt; println!(&quot;Too big!&quot;),
        Equal   =&gt; { println!(&quot;You win!&quot;); },
    }
}

fn cmp(a: uint, b: uint) -&gt; Ordering {
    if a &lt; b { Less }
    else if a &gt; b { Greater }
    else { Equal }
}</span><pre id='rust-example-rendered-87' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>rand</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Guess the number!&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>secret_number</span> <span class='op'>=</span> (<span class='ident'>rand</span>::<span class='ident'>random</span>::<span class='op'>&lt;</span><span class='ident'>uint</span><span class='op'>&gt;</span>() <span class='op'>%</span> <span class='number'>100u</span>) <span class='op'>+</span> <span class='number'>1u</span>;

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The secret number is: {}&quot;</span>, <span class='ident'>secret_number</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Please input your guess.&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>input</span> <span class='op'>=</span> <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>()
                           .<span class='ident'>ok</span>()
                           .<span class='ident'>expect</span>(<span class='string'>&quot;Failed to read line&quot;</span>);
    <span class='kw'>let</span> <span class='ident'>input_num</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>uint</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>from_str</span>(<span class='ident'>input</span>.<span class='ident'>as_slice</span>());



    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You guessed: {}&quot;</span>, <span class='ident'>input_num</span>);

    <span class='kw'>match</span> <span class='ident'>cmp</span>(<span class='ident'>input_num</span>, <span class='ident'>secret_number</span>) {
        <span class='ident'>Less</span>    <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Too small!&quot;</span>),
        <span class='ident'>Greater</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Too big!&quot;</span>),
        <span class='ident'>Equal</span>   <span class='op'>=&gt;</span> { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You win!&quot;</span>); },
    }
}

<span class='kw'>fn</span> <span class='ident'>cmp</span>(<span class='ident'>a</span>: <span class='ident'>uint</span>, <span class='ident'>b</span>: <span class='ident'>uint</span>) <span class='op'>-&gt;</span> <span class='ident'>Ordering</span> {
    <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&lt;</span> <span class='ident'>b</span> { <span class='ident'>Less</span> }
    <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&gt;</span> <span class='ident'>b</span> { <span class='ident'>Greater</span> }
    <span class='kw'>else</span> { <span class='ident'>Equal</span> }
}
</pre>

<p>Let&#39;s try it out!</p>

<pre><code class="language-{notrust,ignore}">$ cargo build
   Compiling guessing_game v0.1.0 (file:/home/steve/tmp/guessing_game)
src/guessing_game.rs:22:15: 22:24 error: mismatched types: expected `uint` but found `core::option::Option&lt;uint&gt;` (expected uint but found enum core::option::Option)
src/guessing_game.rs:22     match cmp(input_num, secret_number) {
                                      ^~~~~~~~~
error: aborting due to previous error</code></pre>

<p>Oh yeah! Our <code>input_num</code> has the type <code>Option&lt;uint&gt;</code>, rather than <code>uint</code>. We
need to unwrap the Option. If you remember from before, <code>match</code> is a great way
to do that. Try this code:</p>
<span id='rust-example-raw-88' class='rusttest'>use std::io;
use std::rand;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = (rand::random::&lt;uint&gt;() % 100u) + 1u;

    println!(&quot;The secret number is: {}&quot;, secret_number);

    println!(&quot;Please input your guess.&quot;);

    let input = io::stdin().read_line()
                           .ok()
                           .expect(&quot;Failed to read line&quot;);
    let input_num: Option&lt;uint&gt; = from_str(input.as_slice());

    let num = match input_num {
        Some(num) =&gt; num,
        None      =&gt; {
            println!(&quot;Please input a number!&quot;);
            return;
        }
    };


    println!(&quot;You guessed: {}&quot;, num);

    match cmp(num, secret_number) {
        Less    =&gt; println!(&quot;Too small!&quot;),
        Greater =&gt; println!(&quot;Too big!&quot;),
        Equal   =&gt; { println!(&quot;You win!&quot;); },
    }
}

fn cmp(a: uint, b: uint) -&gt; Ordering {
    if a &lt; b { Less }
    else if a &gt; b { Greater }
    else { Equal }
}</span><pre id='rust-example-rendered-88' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>rand</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Guess the number!&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>secret_number</span> <span class='op'>=</span> (<span class='ident'>rand</span>::<span class='ident'>random</span>::<span class='op'>&lt;</span><span class='ident'>uint</span><span class='op'>&gt;</span>() <span class='op'>%</span> <span class='number'>100u</span>) <span class='op'>+</span> <span class='number'>1u</span>;

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The secret number is: {}&quot;</span>, <span class='ident'>secret_number</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Please input your guess.&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>input</span> <span class='op'>=</span> <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>()
                           .<span class='ident'>ok</span>()
                           .<span class='ident'>expect</span>(<span class='string'>&quot;Failed to read line&quot;</span>);
    <span class='kw'>let</span> <span class='ident'>input_num</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>uint</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>from_str</span>(<span class='ident'>input</span>.<span class='ident'>as_slice</span>());

    <span class='kw'>let</span> <span class='ident'>num</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>input_num</span> {
        <span class='prelude-val'>Some</span>(<span class='ident'>num</span>) <span class='op'>=&gt;</span> <span class='ident'>num</span>,
        <span class='prelude-val'>None</span>      <span class='op'>=&gt;</span> {
            <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Please input a number!&quot;</span>);
            <span class='kw'>return</span>;
        }
    };


    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You guessed: {}&quot;</span>, <span class='ident'>num</span>);

    <span class='kw'>match</span> <span class='ident'>cmp</span>(<span class='ident'>num</span>, <span class='ident'>secret_number</span>) {
        <span class='ident'>Less</span>    <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Too small!&quot;</span>),
        <span class='ident'>Greater</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Too big!&quot;</span>),
        <span class='ident'>Equal</span>   <span class='op'>=&gt;</span> { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You win!&quot;</span>); },
    }
}

<span class='kw'>fn</span> <span class='ident'>cmp</span>(<span class='ident'>a</span>: <span class='ident'>uint</span>, <span class='ident'>b</span>: <span class='ident'>uint</span>) <span class='op'>-&gt;</span> <span class='ident'>Ordering</span> {
    <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&lt;</span> <span class='ident'>b</span> { <span class='ident'>Less</span> }
    <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&gt;</span> <span class='ident'>b</span> { <span class='ident'>Greater</span> }
    <span class='kw'>else</span> { <span class='ident'>Equal</span> }
}
</pre>

<p>We use a <code>match</code> to either give us the <code>uint</code> inside of the <code>Option</code>, or we
print an error message and return. Let&#39;s give this a shot:</p>

<pre><code class="language-{notrust,ignore}">$ cargo build
   Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)
$ ./target/guessing_game 
Guess the number!
The secret number is: 17
Please input your guess.
5
Please input a number!
$</code></pre>

<p>Uh, what? But we did!</p>

<p>... actually, we didn&#39;t. See, when you get a line of input from <code>stdin()</code>,
you get all the input. Including the <code>\n</code> character from you pressing Enter.
So, <code>from_str()</code> sees the string <code>&quot;5\n&quot;</code> and says &quot;nope, that&#39;s not a number,
there&#39;s non-number stuff in there!&quot; Luckily for us, <code>&amp;str</code>s have an easy
method we can use defined on them: <code>trim()</code>. One small modification, and our
code looks like this:</p>
<span id='rust-example-raw-89' class='rusttest'>use std::io;
use std::rand;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = (rand::random::&lt;uint&gt;() % 100u) + 1u;

    println!(&quot;The secret number is: {}&quot;, secret_number);

    println!(&quot;Please input your guess.&quot;);

    let input = io::stdin().read_line()
                           .ok()
                           .expect(&quot;Failed to read line&quot;);
    let input_num: Option&lt;uint&gt; = from_str(input.as_slice().trim());

    let num = match input_num {
        Some(num) =&gt; num,
        None      =&gt; {
            println!(&quot;Please input a number!&quot;);
            return;
        }
    };


    println!(&quot;You guessed: {}&quot;, num);

    match cmp(num, secret_number) {
        Less    =&gt; println!(&quot;Too small!&quot;),
        Greater =&gt; println!(&quot;Too big!&quot;),
        Equal   =&gt; { println!(&quot;You win!&quot;); },
    }
}

fn cmp(a: uint, b: uint) -&gt; Ordering {
    if a &lt; b { Less }
    else if a &gt; b { Greater }
    else { Equal }
}</span><pre id='rust-example-rendered-89' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>rand</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Guess the number!&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>secret_number</span> <span class='op'>=</span> (<span class='ident'>rand</span>::<span class='ident'>random</span>::<span class='op'>&lt;</span><span class='ident'>uint</span><span class='op'>&gt;</span>() <span class='op'>%</span> <span class='number'>100u</span>) <span class='op'>+</span> <span class='number'>1u</span>;

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The secret number is: {}&quot;</span>, <span class='ident'>secret_number</span>);

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Please input your guess.&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>input</span> <span class='op'>=</span> <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>()
                           .<span class='ident'>ok</span>()
                           .<span class='ident'>expect</span>(<span class='string'>&quot;Failed to read line&quot;</span>);
    <span class='kw'>let</span> <span class='ident'>input_num</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>uint</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>from_str</span>(<span class='ident'>input</span>.<span class='ident'>as_slice</span>().<span class='ident'>trim</span>());

    <span class='kw'>let</span> <span class='ident'>num</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>input_num</span> {
        <span class='prelude-val'>Some</span>(<span class='ident'>num</span>) <span class='op'>=&gt;</span> <span class='ident'>num</span>,
        <span class='prelude-val'>None</span>      <span class='op'>=&gt;</span> {
            <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Please input a number!&quot;</span>);
            <span class='kw'>return</span>;
        }
    };


    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You guessed: {}&quot;</span>, <span class='ident'>num</span>);

    <span class='kw'>match</span> <span class='ident'>cmp</span>(<span class='ident'>num</span>, <span class='ident'>secret_number</span>) {
        <span class='ident'>Less</span>    <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Too small!&quot;</span>),
        <span class='ident'>Greater</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Too big!&quot;</span>),
        <span class='ident'>Equal</span>   <span class='op'>=&gt;</span> { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You win!&quot;</span>); },
    }
}

<span class='kw'>fn</span> <span class='ident'>cmp</span>(<span class='ident'>a</span>: <span class='ident'>uint</span>, <span class='ident'>b</span>: <span class='ident'>uint</span>) <span class='op'>-&gt;</span> <span class='ident'>Ordering</span> {
    <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&lt;</span> <span class='ident'>b</span> { <span class='ident'>Less</span> }
    <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&gt;</span> <span class='ident'>b</span> { <span class='ident'>Greater</span> }
    <span class='kw'>else</span> { <span class='ident'>Equal</span> }
}
</pre>

<p>Let&#39;s try it!</p>

<pre><code class="language-{notrust,ignore}">$ cargo build
   Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)
$ ./target/guessing_game 
Guess the number!
The secret number is: 58
Please input your guess.
  76  
You guessed: 76
Too big!
$</code></pre>

<p>Nice! You can see I even added spaces before my guess, and it still figured
out that I guessed 76. Run the program a few times, and verify that guessing
the number works, as well as guessing a number too small.</p>

<p>The Rust compiler helped us out quite a bit there! This technique is called
&quot;lean on the compiler,&quot; and it&#39;s often useful when working on some code. Let
the error messages help guide you towards the correct types.</p>

<p>Now we&#39;ve got most of the game working, but we can only make one guess. Let&#39;s
change that by adding loops!</p>

<h2 id="looping-1" class='section-header'><a
                           href="#looping-1">13.5 Looping</a></h2>
<p>As we already discussed, the <code>loop</code> key word gives us an infinite loop. So
let&#39;s add that in:</p>
<span id='rust-example-raw-90' class='rusttest'>use std::io;
use std::rand;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = (rand::random::&lt;uint&gt;() % 100u) + 1u;

    println!(&quot;The secret number is: {}&quot;, secret_number);

    loop {

        println!(&quot;Please input your guess.&quot;);

        let input = io::stdin().read_line()
                               .ok()
                               .expect(&quot;Failed to read line&quot;);
        let input_num: Option&lt;uint&gt; = from_str(input.as_slice().trim());

        let num = match input_num {
            Some(num) =&gt; num,
            None      =&gt; {
                println!(&quot;Please input a number!&quot;);
                return;
            }
        };


        println!(&quot;You guessed: {}&quot;, num);

        match cmp(num, secret_number) {
            Less    =&gt; println!(&quot;Too small!&quot;),
            Greater =&gt; println!(&quot;Too big!&quot;),
            Equal   =&gt; { println!(&quot;You win!&quot;); },
        }
    }
}

fn cmp(a: uint, b: uint) -&gt; Ordering {
    if a &lt; b { Less }
    else if a &gt; b { Greater }
    else { Equal }
}</span><pre id='rust-example-rendered-90' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>rand</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Guess the number!&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>secret_number</span> <span class='op'>=</span> (<span class='ident'>rand</span>::<span class='ident'>random</span>::<span class='op'>&lt;</span><span class='ident'>uint</span><span class='op'>&gt;</span>() <span class='op'>%</span> <span class='number'>100u</span>) <span class='op'>+</span> <span class='number'>1u</span>;

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The secret number is: {}&quot;</span>, <span class='ident'>secret_number</span>);

    <span class='kw'>loop</span> {

        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Please input your guess.&quot;</span>);

        <span class='kw'>let</span> <span class='ident'>input</span> <span class='op'>=</span> <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>()
                               .<span class='ident'>ok</span>()
                               .<span class='ident'>expect</span>(<span class='string'>&quot;Failed to read line&quot;</span>);
        <span class='kw'>let</span> <span class='ident'>input_num</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>uint</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>from_str</span>(<span class='ident'>input</span>.<span class='ident'>as_slice</span>().<span class='ident'>trim</span>());

        <span class='kw'>let</span> <span class='ident'>num</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>input_num</span> {
            <span class='prelude-val'>Some</span>(<span class='ident'>num</span>) <span class='op'>=&gt;</span> <span class='ident'>num</span>,
            <span class='prelude-val'>None</span>      <span class='op'>=&gt;</span> {
                <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Please input a number!&quot;</span>);
                <span class='kw'>return</span>;
            }
        };


        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You guessed: {}&quot;</span>, <span class='ident'>num</span>);

        <span class='kw'>match</span> <span class='ident'>cmp</span>(<span class='ident'>num</span>, <span class='ident'>secret_number</span>) {
            <span class='ident'>Less</span>    <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Too small!&quot;</span>),
            <span class='ident'>Greater</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Too big!&quot;</span>),
            <span class='ident'>Equal</span>   <span class='op'>=&gt;</span> { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You win!&quot;</span>); },
        }
    }
}

<span class='kw'>fn</span> <span class='ident'>cmp</span>(<span class='ident'>a</span>: <span class='ident'>uint</span>, <span class='ident'>b</span>: <span class='ident'>uint</span>) <span class='op'>-&gt;</span> <span class='ident'>Ordering</span> {
    <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&lt;</span> <span class='ident'>b</span> { <span class='ident'>Less</span> }
    <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&gt;</span> <span class='ident'>b</span> { <span class='ident'>Greater</span> }
    <span class='kw'>else</span> { <span class='ident'>Equal</span> }
}
</pre>

<p>And try it out. But wait, didn&#39;t we just add an infinite loop? Yup. Remember
that <code>return</code>? If we give a non-number answer, we&#39;ll <code>return</code> and quit. Observe:</p>

<pre><code class="language-{notrust,ignore}">$ cargo build
   Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)
steve@computer:~/tmp/guessing_game$ ./target/guessing_game 
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
Please input a number!
$</code></pre>

<p>Ha! <code>quit</code> actually quits. As does any other non-number input. Well, this is
suboptimal to say the least. First, let&#39;s actually quit when you win the game:</p>
<span id='rust-example-raw-91' class='rusttest'>use std::io;
use std::rand;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = (rand::random::&lt;uint&gt;() % 100u) + 1u;

    println!(&quot;The secret number is: {}&quot;, secret_number);

    loop {

        println!(&quot;Please input your guess.&quot;);

        let input = io::stdin().read_line()
                               .ok()
                               .expect(&quot;Failed to read line&quot;);
        let input_num: Option&lt;uint&gt; = from_str(input.as_slice().trim());

        let num = match input_num {
            Some(num) =&gt; num,
            None      =&gt; {
                println!(&quot;Please input a number!&quot;);
                return;
            }
        };


        println!(&quot;You guessed: {}&quot;, num);

        match cmp(num, secret_number) {
            Less    =&gt; println!(&quot;Too small!&quot;),
            Greater =&gt; println!(&quot;Too big!&quot;),
            Equal   =&gt; {
                println!(&quot;You win!&quot;);
                return;
            },
        }
    }
}

fn cmp(a: uint, b: uint) -&gt; Ordering {
    if a &lt; b { Less }
    else if a &gt; b { Greater }
    else { Equal }
}</span><pre id='rust-example-rendered-91' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>rand</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Guess the number!&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>secret_number</span> <span class='op'>=</span> (<span class='ident'>rand</span>::<span class='ident'>random</span>::<span class='op'>&lt;</span><span class='ident'>uint</span><span class='op'>&gt;</span>() <span class='op'>%</span> <span class='number'>100u</span>) <span class='op'>+</span> <span class='number'>1u</span>;

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The secret number is: {}&quot;</span>, <span class='ident'>secret_number</span>);

    <span class='kw'>loop</span> {

        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Please input your guess.&quot;</span>);

        <span class='kw'>let</span> <span class='ident'>input</span> <span class='op'>=</span> <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>()
                               .<span class='ident'>ok</span>()
                               .<span class='ident'>expect</span>(<span class='string'>&quot;Failed to read line&quot;</span>);
        <span class='kw'>let</span> <span class='ident'>input_num</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>uint</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>from_str</span>(<span class='ident'>input</span>.<span class='ident'>as_slice</span>().<span class='ident'>trim</span>());

        <span class='kw'>let</span> <span class='ident'>num</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>input_num</span> {
            <span class='prelude-val'>Some</span>(<span class='ident'>num</span>) <span class='op'>=&gt;</span> <span class='ident'>num</span>,
            <span class='prelude-val'>None</span>      <span class='op'>=&gt;</span> {
                <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Please input a number!&quot;</span>);
                <span class='kw'>return</span>;
            }
        };


        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You guessed: {}&quot;</span>, <span class='ident'>num</span>);

        <span class='kw'>match</span> <span class='ident'>cmp</span>(<span class='ident'>num</span>, <span class='ident'>secret_number</span>) {
            <span class='ident'>Less</span>    <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Too small!&quot;</span>),
            <span class='ident'>Greater</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Too big!&quot;</span>),
            <span class='ident'>Equal</span>   <span class='op'>=&gt;</span> {
                <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You win!&quot;</span>);
                <span class='kw'>return</span>;
            },
        }
    }
}

<span class='kw'>fn</span> <span class='ident'>cmp</span>(<span class='ident'>a</span>: <span class='ident'>uint</span>, <span class='ident'>b</span>: <span class='ident'>uint</span>) <span class='op'>-&gt;</span> <span class='ident'>Ordering</span> {
    <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&lt;</span> <span class='ident'>b</span> { <span class='ident'>Less</span> }
    <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&gt;</span> <span class='ident'>b</span> { <span class='ident'>Greater</span> }
    <span class='kw'>else</span> { <span class='ident'>Equal</span> }
}
</pre>

<p>By adding the <code>return</code> line after the <code>You win!</code>, we&#39;ll exit the program when
we win. We have just one more tweak to make: when someone inputs a non-number,
we don&#39;t want to quit, we just want to ignore it. Change that <code>return</code> to
<code>continue</code>:</p>
<span id='rust-example-raw-92' class='rusttest'>use std::io;
use std::rand;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = (rand::random::&lt;uint&gt;() % 100u) + 1u;

    println!(&quot;The secret number is: {}&quot;, secret_number);

    loop {

        println!(&quot;Please input your guess.&quot;);

        let input = io::stdin().read_line()
                               .ok()
                               .expect(&quot;Failed to read line&quot;);
        let input_num: Option&lt;uint&gt; = from_str(input.as_slice().trim());

        let num = match input_num {
            Some(num) =&gt; num,
            None      =&gt; {
                println!(&quot;Please input a number!&quot;);
                continue;
            }
        };


        println!(&quot;You guessed: {}&quot;, num);

        match cmp(num, secret_number) {
            Less    =&gt; println!(&quot;Too small!&quot;),
            Greater =&gt; println!(&quot;Too big!&quot;),
            Equal   =&gt; {
                println!(&quot;You win!&quot;);
                return;
            },
        }
    }
}

fn cmp(a: uint, b: uint) -&gt; Ordering {
    if a &lt; b { Less }
    else if a &gt; b { Greater }
    else { Equal }
}</span><pre id='rust-example-rendered-92' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>rand</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Guess the number!&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>secret_number</span> <span class='op'>=</span> (<span class='ident'>rand</span>::<span class='ident'>random</span>::<span class='op'>&lt;</span><span class='ident'>uint</span><span class='op'>&gt;</span>() <span class='op'>%</span> <span class='number'>100u</span>) <span class='op'>+</span> <span class='number'>1u</span>;

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The secret number is: {}&quot;</span>, <span class='ident'>secret_number</span>);

    <span class='kw'>loop</span> {

        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Please input your guess.&quot;</span>);

        <span class='kw'>let</span> <span class='ident'>input</span> <span class='op'>=</span> <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>()
                               .<span class='ident'>ok</span>()
                               .<span class='ident'>expect</span>(<span class='string'>&quot;Failed to read line&quot;</span>);
        <span class='kw'>let</span> <span class='ident'>input_num</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>uint</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>from_str</span>(<span class='ident'>input</span>.<span class='ident'>as_slice</span>().<span class='ident'>trim</span>());

        <span class='kw'>let</span> <span class='ident'>num</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>input_num</span> {
            <span class='prelude-val'>Some</span>(<span class='ident'>num</span>) <span class='op'>=&gt;</span> <span class='ident'>num</span>,
            <span class='prelude-val'>None</span>      <span class='op'>=&gt;</span> {
                <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Please input a number!&quot;</span>);
                <span class='kw'>continue</span>;
            }
        };


        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You guessed: {}&quot;</span>, <span class='ident'>num</span>);

        <span class='kw'>match</span> <span class='ident'>cmp</span>(<span class='ident'>num</span>, <span class='ident'>secret_number</span>) {
            <span class='ident'>Less</span>    <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Too small!&quot;</span>),
            <span class='ident'>Greater</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Too big!&quot;</span>),
            <span class='ident'>Equal</span>   <span class='op'>=&gt;</span> {
                <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You win!&quot;</span>);
                <span class='kw'>return</span>;
            },
        }
    }
}

<span class='kw'>fn</span> <span class='ident'>cmp</span>(<span class='ident'>a</span>: <span class='ident'>uint</span>, <span class='ident'>b</span>: <span class='ident'>uint</span>) <span class='op'>-&gt;</span> <span class='ident'>Ordering</span> {
    <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&lt;</span> <span class='ident'>b</span> { <span class='ident'>Less</span> }
    <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&gt;</span> <span class='ident'>b</span> { <span class='ident'>Greater</span> }
    <span class='kw'>else</span> { <span class='ident'>Equal</span> }
}
</pre>

<p>Now we should be good! Let&#39;s try:</p>
<span id='rust-example-raw-93' class='rusttest'>fn main() {
    $ cargo build
       Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)
    $ ./target/guessing_game 
    Guess the number!
    The secret number is: 61
    Please input your guess.
    10
    You guessed: 10
    Too small!
    Please input your guess.
    99
    You guessed: 99
    Too big!
    Please input your guess.
    foo
    Please input a number!
    Please input your guess.
    61
    You guessed: 61
    You win!
}</span><pre id='rust-example-rendered-93' class='rust '>
$ <span class='ident'>cargo</span> <span class='ident'>build</span>
   <span class='ident'>Compiling</span> <span class='ident'>guessing_game</span> <span class='ident'>v0</span>.<span class='number'>1.0</span> (<span class='ident'>file</span>:<span class='op'>/</span><span class='ident'>home</span><span class='op'>/</span><span class='ident'>you</span><span class='op'>/</span><span class='ident'>projects</span><span class='op'>/</span><span class='ident'>guessing_game</span>)
$ .<span class='op'>/</span><span class='ident'>target</span><span class='op'>/</span><span class='ident'>guessing_game</span> 
<span class='ident'>Guess</span> <span class='ident'>the</span> <span class='macro'>number</span><span class='macro'>!</span>
<span class='ident'>The</span> <span class='ident'>secret</span> <span class='ident'>number</span> <span class='ident'>is</span>: <span class='number'>61</span>
<span class='ident'>Please</span> <span class='ident'>input</span> <span class='ident'>your</span> <span class='ident'>guess</span>.
<span class='number'>10</span>
<span class='ident'>You</span> <span class='ident'>guessed</span>: <span class='number'>10</span>
<span class='ident'>Too</span> <span class='macro'>small</span><span class='macro'>!</span>
<span class='ident'>Please</span> <span class='ident'>input</span> <span class='ident'>your</span> <span class='ident'>guess</span>.
<span class='number'>99</span>
<span class='ident'>You</span> <span class='ident'>guessed</span>: <span class='number'>99</span>
<span class='ident'>Too</span> <span class='macro'>big</span><span class='macro'>!</span>
<span class='ident'>Please</span> <span class='ident'>input</span> <span class='ident'>your</span> <span class='ident'>guess</span>.
<span class='ident'>foo</span>
<span class='ident'>Please</span> <span class='ident'>input</span> <span class='ident'>a</span> <span class='macro'>number</span><span class='macro'>!</span>
<span class='ident'>Please</span> <span class='ident'>input</span> <span class='ident'>your</span> <span class='ident'>guess</span>.
<span class='number'>61</span>
<span class='ident'>You</span> <span class='ident'>guessed</span>: <span class='number'>61</span>
<span class='ident'>You</span> <span class='macro'>win</span><span class='macro'>!</span>
</pre>

<p>Awesome! With one tiny last tweak, we have finished the guessing game. Can you
think of what it is? That&#39;s right, we don&#39;t want to print out the secret number.
It was good for testing, but it kind of ruins the game. Here&#39;s our final source:</p>
<span id='rust-example-raw-94' class='rusttest'>use std::io;
use std::rand;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = (rand::random::&lt;uint&gt;() % 100u) + 1u;

    loop {

        println!(&quot;Please input your guess.&quot;);

        let input = io::stdin().read_line()
                               .ok()
                               .expect(&quot;Failed to read line&quot;);
        let input_num: Option&lt;uint&gt; = from_str(input.as_slice().trim());

        let num = match input_num {
            Some(num) =&gt; num,
            None      =&gt; {
                println!(&quot;Please input a number!&quot;);
                continue;
            }
        };


        println!(&quot;You guessed: {}&quot;, num);

        match cmp(num, secret_number) {
            Less    =&gt; println!(&quot;Too small!&quot;),
            Greater =&gt; println!(&quot;Too big!&quot;),
            Equal   =&gt; {
                println!(&quot;You win!&quot;);
                return;
            },
        }
    }
}

fn cmp(a: uint, b: uint) -&gt; Ordering {
    if a &lt; b { Less }
    else if a &gt; b { Greater }
    else { Equal }
}</span><pre id='rust-example-rendered-94' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>rand</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Guess the number!&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>secret_number</span> <span class='op'>=</span> (<span class='ident'>rand</span>::<span class='ident'>random</span>::<span class='op'>&lt;</span><span class='ident'>uint</span><span class='op'>&gt;</span>() <span class='op'>%</span> <span class='number'>100u</span>) <span class='op'>+</span> <span class='number'>1u</span>;

    <span class='kw'>loop</span> {

        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Please input your guess.&quot;</span>);

        <span class='kw'>let</span> <span class='ident'>input</span> <span class='op'>=</span> <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>read_line</span>()
                               .<span class='ident'>ok</span>()
                               .<span class='ident'>expect</span>(<span class='string'>&quot;Failed to read line&quot;</span>);
        <span class='kw'>let</span> <span class='ident'>input_num</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>uint</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>from_str</span>(<span class='ident'>input</span>.<span class='ident'>as_slice</span>().<span class='ident'>trim</span>());

        <span class='kw'>let</span> <span class='ident'>num</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>input_num</span> {
            <span class='prelude-val'>Some</span>(<span class='ident'>num</span>) <span class='op'>=&gt;</span> <span class='ident'>num</span>,
            <span class='prelude-val'>None</span>      <span class='op'>=&gt;</span> {
                <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Please input a number!&quot;</span>);
                <span class='kw'>continue</span>;
            }
        };


        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You guessed: {}&quot;</span>, <span class='ident'>num</span>);

        <span class='kw'>match</span> <span class='ident'>cmp</span>(<span class='ident'>num</span>, <span class='ident'>secret_number</span>) {
            <span class='ident'>Less</span>    <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Too small!&quot;</span>),
            <span class='ident'>Greater</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Too big!&quot;</span>),
            <span class='ident'>Equal</span>   <span class='op'>=&gt;</span> {
                <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;You win!&quot;</span>);
                <span class='kw'>return</span>;
            },
        }
    }
}

<span class='kw'>fn</span> <span class='ident'>cmp</span>(<span class='ident'>a</span>: <span class='ident'>uint</span>, <span class='ident'>b</span>: <span class='ident'>uint</span>) <span class='op'>-&gt;</span> <span class='ident'>Ordering</span> {
    <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&lt;</span> <span class='ident'>b</span> { <span class='ident'>Less</span> }
    <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&gt;</span> <span class='ident'>b</span> { <span class='ident'>Greater</span> }
    <span class='kw'>else</span> { <span class='ident'>Equal</span> }
}
</pre>

<h2 id="complete!" class='section-header'><a
                           href="#complete!">13.6 Complete!</a></h2>
<p>At this point, you have successfully built the Guessing Game! Congratulations!</p>

<p>You&#39;ve now learned the basic syntax of Rust. All of this is relatively close to
various other programming languages you have used in the past. These
fundamental syntactical and semantic elements will form the foundation for the
rest of your Rust education.</p>

<p>Now that you&#39;re an expert at the basics, it&#39;s time to learn about some of
Rust&#39;s more unique features.</p>

<h1 id="iterators" class='section-header'><a
                           href="#iterators">14 iterators</a></h1>
<h1 id="lambdas" class='section-header'><a
                           href="#lambdas">15 Lambdas</a></h1>
<h1 id="testing" class='section-header'><a
                           href="#testing">16 Testing</a></h1>
<p>attributes</p>

<p>stability markers</p>

<h1 id="crates-and-modules" class='section-header'><a
                           href="#crates-and-modules">17 Crates and Modules</a></h1>
<p>visibility</p>

<h1 id="generics" class='section-header'><a
                           href="#generics">18 Generics</a></h1>
<h1 id="traits" class='section-header'><a
                           href="#traits">19 Traits</a></h1>
<h1 id="operators-and-built-in-traits" class='section-header'><a
                           href="#operators-and-built-in-traits">20 Operators and built-in Traits</a></h1>
<h1 id="ownership-and-lifetimes" class='section-header'><a
                           href="#ownership-and-lifetimes">21 Ownership and Lifetimes</a></h1>
<p>Move vs. Copy</p>

<p>Allocation</p>

<h1 id="tasks" class='section-header'><a
                           href="#tasks">22 Tasks</a></h1>
<h1 id="macros" class='section-header'><a
                           href="#macros">23 Macros</a></h1>
<h1 id="unsafe" class='section-header'><a
                           href="#unsafe">24 Unsafe</a></h1>
    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org/";
    </script>
    <footer><p>
Copyright &copy; 2011-2014 The Rust Project Developers. Licensed under the
<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a>
or the <a href="http://opensource.org/licenses/MIT">MIT license</a>, at your option.
</p><p>
This file may not be copied, modified, or distributed except according to those terms.
</p></footer>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="playpen.js"></script>


</body>
</html>