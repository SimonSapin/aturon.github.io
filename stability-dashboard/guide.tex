\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{€}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
\newcommand{\RegionMarkerTok}[1]{{#1}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
\newcommand{\NormalTok}[1]{{#1}}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={},
            pdftitle={The Rust Guide},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{5}

\title{The Rust Guide}

\begin{document}
\maketitle

0.12.0-pre (2c50add48 2014-07-27 23:03:52 -0700)

Copyright © 2011-2014 The Rust Project Developers. Licensed under the
\href{http://www.apache.org/licenses/LICENSE-2.0}{Apache License,
Version 2.0} or the \href{http://opensource.org/licenses/MIT}{MIT
license}, at your option.

This file may not be copied, modified, or distributed except according
to those terms.

{
\hypersetup{linkcolor=black}
\setcounter{tocdepth}{3}
\tableofcontents
}
This guide is a work in progress. Until it is ready, we highly recommend
that you read the Tutorial instead. This work-in-progress Guide is being
displayed here in line with Rust's open development policy. Please open
any issues you find as usual.

\section{Welcome!}\label{welcome}

Hey there! Welcome to the Rust guide. This is the place to be if you'd
like to learn how to program in Rust. Rust is a systems programming
language with a focus on ``high-level, bare-metal programming'': the
lowest level control a programming language can give you, but with
zero-cost, higher level abstractions, because people aren't computers.
We really think Rust is something special, and we hope you do too.

To show you how to get going with Rust, we're going to write the
traditional ``Hello, World!'' program. Next, we'll introduce you to a
tool that's useful for writing real-world Rust programs and libraries:
``Cargo.'' After that, we'll talk about the basics of Rust, write a
little program to try them out, and then learn more advanced things.

Sound good? Let's go!

\section{Installing Rust}\label{installing-rust}

The first step to using Rust is to install it! There are a number of
ways to install Rust, but the easiest is to use the the \texttt{rustup}
script. If you're on Linux or a Mac, all you need to do is this (note
that you don't need to type in the \texttt{\$}s, they just indicate the
start of each command):

\texttt{\{ignore\} \$ curl -s http://www.rust-lang.org/rustup.sh \textbar{} sudo sh}

(If you're concerned about \texttt{curl \textbar{} sudo sh}, please keep
reading. Disclaimer below.)

If you're on Windows, please
\href{http://static.rust-lang.org/dist/rust-nightly-install.exe}{download
this .exe and run it}.

If you decide you don't want Rust anymore, we'll be a bit sad, but
that's okay. Not every programming language is great for everyone. Just
pass an argument to the script:

\texttt{\{ignore\} \$ curl -s http://www.rust-lang.org/rustup.sh \textbar{} sudo sh -s -\/- -\/-uninstall}

If you used the Windows installer, just re-run the \texttt{.exe} and it
will give you an uninstall option.

You can re-run this script any time you want to update Rust. Which, at
this point, is often. Rust is still pre-1.0, and so people assume that
you're using a very recent Rust.

This brings me to one other point: some people, and somewhat rightfully
so, get very upset when we tell you to \texttt{curl \textbar{} sudo sh}.
And they should be! Basically, when you do this, you are trusting that
the good people who maintain Rust aren't going to hack your computer and
do bad things. That's a good instinct! If you're one of those people,
please check out the documentation on
\href{https://github.com/rust-lang/rust\#building-from-source}{building
Rust from Source}, or \href{http://www.rust-lang.org/install.html}{the
official binary downloads}. And we promise that this method will not be
the way to install Rust forever: it's just the easiest way to keep
people updated while Rust is in its alpha state.

Oh, we should also mention the officially supported platforms:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Windows (7, 8, Server 2008 R2), x86 only
\item
  Linux (2.6.18 or later, various distributions), x86 and x86-64
\item
  OSX 10.7 (Lion) or greater, x86 and x86-64
\end{itemize}

We extensively test Rust on these platforms, and a few others, too, like
Android. But these are the ones most likely to work, as they have the
most testing.

Finally, a comment about Windows. Rust considers Windows to be a
first-class platform upon release, but if we're honest, the Windows
experience isn't as integrated as the Linux/OS X experience is. We're
working on it! If anything does not work, it is a bug. Please let us
know if that happens. Each and every commit is tested against Windows
just like any other platform.

If you've got Rust installed, you can open up a shell, and type this:

\texttt{\{ignore\} \$ rustc -\/-version}

You should see some output that looks something like this:

\texttt{\{ignore\} rustc 0.12.0-pre (443a1cd 2014-06-08 14:56:52 -0700)}

If you did, Rust has been installed successfully! Congrats!

If not, there are a number of places where you can get help. The easiest
is \href{irc://irc.mozilla.org/\#rust}{the \#rust IRC channel on
irc.mozilla.org}, which you can access through
\href{http://chat.mibbit.com/?server=irc.mozilla.org\&channel=\%23rust}{Mibbit}.
Click that link, and you'll be chatting with other Rustaceans (a silly
nickname we call ourselves), and we can help you out. Other great
resources include \href{https://mail.mozilla.org/listinfo/rust-dev}{our
mailing list}, \href{http://www.reddit.com/r/rust}{the /r/rust
subreddit}, and
\href{http://stackoverflow.com/questions/tagged/rust}{Stack Overflow}.

\section{Hello, world!}\label{hello-world}

Now that you have Rust installed, let's write your first Rust program.
It's traditional to make your first program in any new language one that
prints the text ``Hello, world!'' to the screen. The nice thing about
starting with such a simple program is that you can verify that your
compiler isn't just installed, but also working properly. And printing
information to the screen is a pretty common thing to do.

The first thing that we need to do is make a file to put our code in. I
like to make a projects directory in my home directory, and keep all my
projects there. Rust does not care where your code lives.

This actually leads to one other concern we should address: this
tutorial will assume that you have basic familiarity with the
command-line. Rust does not require that you know a whole ton about the
command line, but until the language is in a more finished state, IDE
support is spotty. Rust makes no specific demands on your editing
tooling, or where your code lives.

With that said, let's make a directory in our projects directory.

\texttt{\{bash\} \$ mkdir \textasciitilde{}/projects \$ cd \textasciitilde{}/projects \$ mkdir hello\_world \$ cd hello\_world}

If you're on Windows and not using PowerShell, the
\texttt{\textasciitilde{}} may not work. Consult the documentation for
your shell for more details.

Let's make a new source file next. I'm going to use the syntax
\texttt{editor filename} to represent editing a file in these examples,
but you should use whatever method you want. We'll call our file
\texttt{hello\_world.rs}:

\texttt{\{bash\} \$ editor hello\_world.rs}

Rust files always end in a \texttt{.rs} extension. If you're using more
than one word in your file name, use an underscore.
\texttt{hello\_world.rs} versus \texttt{goodbye.rs}.

Now that you've got your file open, type this in:

\begin{verbatim}
fn main() {
    println!("Hello, world");
}
\end{verbatim}

Save the file, and then type this into your terminal window:

\texttt{\{bash\} \$ rustc hello\_world.rs \$ ./hello\_world \# or hello\_world.exe on Windows Hello, world}

Success! Let's go over what just happened in detail.

\begin{verbatim}
fn main() {

}
\end{verbatim}

These two lines define a \textbf{function} in Rust. The \texttt{main}
function is special: it's the beginning of every Rust program. The first
line says ``I'm declaring a function named \texttt{main}, which takes no
arguments and returns nothing.'' If there were arguments, they would go
inside the parentheses (\texttt{(} and \texttt{)}), and because we
aren't returning anything from this function, we've dropped that
notation entirely. We'll get to it later.

You'll also note that the function is wrapped in curly braces
(\texttt{\{} and \texttt{\}}). Rust requires these around all function
bodies. It is also considered good style to put the opening curly brace
on the same line as the function declaration, with one space in between.

Next up is this line:

\begin{verbatim}
    println!("Hello, world");
\end{verbatim}

This line does all of the work in our little program. There are a number
of details that are important here. The first is that it's indented with
four spaces, not tabs. Please configure your editor of choice to insert
four spaces with the tab key. We provide some sample configurations for
various editors
\href{https://github.com/rust-lang/rust/tree/master/src/etc}{here}.

The second point is the \texttt{println!()} part. This is calling a Rust
\textbf{macro}, which is how metaprogramming is done in Rust. If it were
a function instead, it would look like this: \texttt{println()}. For our
purposes, we don't need to worry about this difference. Just know that
sometimes, you'll see a \texttt{!}, and that means that you're calling a
macro instead of a normal function. One last thing to mention: Rust's
macros are significantly different than C macros, if you've used those.
Don't be scared of using macros. We'll get to the details eventually,
you'll just have to trust us for now.

Next, \texttt{"Hello, world"} is a \textbf{string}. Strings are a
surprisingly complicated topic in a systems programming language, and
this is a \textbf{statically allocated} string. We will talk more about
different kinds of allocation later. We pass this string as an argument
to \texttt{println!}, which prints the string to the screen. Easy
enough!

Finally, the line ends with a semicolon (\texttt{;}). Rust is an
\textbf{expression oriented} language, which means that most things are
expressions. The \texttt{;} is used to indicate that this expression is
over, and the next one is ready to begin. Most lines of Rust code end
with a \texttt{;}. We will cover this in-depth later in the tutorial.

Finally, actually \textbf{compiling} and \textbf{running} our program.
We can compile with our compiler, \texttt{rustc}, by passing it the name
of our source file:

\texttt{\{bash\} \$ rustc hello\_world.rs}

This is similar to \texttt{gcc} or \texttt{clang}, if you come from a C
or C++ background. Rust will output a binary executable. You can see it
with \texttt{ls}:

\texttt{\{bash\} \$ ls hello\_world  hello\_world.rs}

Or on Windows:

\texttt{\{bash\} \$ dir hello\_world.exe  hello\_world.rs}

There are now two files: our source code, with the \texttt{.rs}
extension, and the executable (\texttt{hello\_world.exe} on Windows,
\texttt{hello\_world} everywhere else)

\texttt{\{bash\} \$ ./hello\_world  \# or hello\_world.exe on Windows}

This prints out our \texttt{Hello, world!} text to our terminal.

If you come from a dynamically typed language like Ruby, Python, or
JavaScript, you may not be used to these two steps being separate. Rust
is an \textbf{ahead-of-time compiled language}, which means that you can
compile a program, give it to someone else, and they don't need to have
Rust installed. If you give someone a \texttt{.rb} or \texttt{.py} or
\texttt{.js} file, they need to have Ruby/Python/JavaScript installed,
but you just need one command to both compile and run your program.
Everything is a tradeoff in language design, and Rust has made its
choice.

Congratulations! You have officially written a Rust program. That makes
you a Rust programmer! Welcome.

Next, I'd like to introduce you to another tool, Cargo, which is used to
write real-world Rust programs. Just using \texttt{rustc} is nice for
simple things, but as your project grows, you'll want something to help
you manage all of the options that it has, and to make it easy to share
your code with other people and projects.

\section{Hello, Cargo!}\label{hello-cargo}

\href{http://crates.io}{Cargo} is a tool that Rustaceans use to help
manage their Rust projects. Cargo is currently in an alpha state, just
like Rust, and so it is still a work in progress. However, it is already
good enough to use for many Rust projects, and so it is assumed that
Rust projects will use Cargo from the beginning.

Cargo manages three things: building your code, downloading the
dependencies your code needs, and building the dependencies your code
needs. At first, your program doesn't have any dependencies, so we'll
only be using the first part of its functionality. Eventually, we'll add
more. Since we started off by using Cargo, it'll be easy to add later.

Let's convert Hello World to Cargo. The first thing we need to do to
begin using Cargo is to install Cargo. Luckily for us, the script we ran
to install Rust includes Cargo by default. If you installed Rust some
other way, you may want to
\href{https://github.com/rust-lang/cargo\#installing-cargo-from-nightlies}{check
the Cargo README} for specific instructions about installing it.

To Cargo-ify our project, we need to do two things: Make a
\texttt{Cargo.toml} configuration file, and put our source file in the
right place. Let's do that part first:

\texttt{\{bash\} \$ mkdir src \$ mv hello\_world.rs src/hello\_world.rs}

Cargo expects your source files to live inside a \texttt{src} directory.
That leaves the top level for other things, like READMEs, licence
information, and anything not related to your code. Cargo helps us keep
our projects nice and tidy. A place for everything, and everything in
its place.

Next, our configuration file:

\texttt{\{bash\} \$ editor Cargo.toml}

Make sure to get this name right: you need the capital \texttt{C}!

Put this inside:

```\{ignore\} {[}package{]}

name = ``hello\_world'' version = ``0.1.0'' authors = {[}
``someone@example.com'' {]}

{[}{[}bin{]}{]}

name = ``hello\_world'' ```

This file is in the \href{https://github.com/toml-lang/toml}{TOML}
format. Let's let it explain itself to you:

\begin{quote}
TOML aims to be a minimal configuration file format that's easy to read
due to obvious semantics. TOML is designed to map unambiguously to a
hash table. TOML should be easy to parse into data structures in a wide
variety of languages.
\end{quote}

TOML is very similar to INI, but with some extra goodies.

Anyway, there are two \textbf{table}s in this file: \texttt{package} and
\texttt{bin}. The first tells Cargo metadata about your package. The
second tells Cargo that we're interested in building a binary, not a
library (though we could do both!), as well as what it is named.

Once you have this file in place, we should be ready to build! Try this:

\texttt{\{bash\} \$ cargo build    Compiling hello\_world v0.1.0 (file:/home/yourname/projects/hello\_world) \$ ./target/hello\_world Hello, world!}

Bam! We build our project with \texttt{cargo build}, and run it with
\texttt{./target/hello\_world}. This hasn't bought us a whole lot over
our simple use of \texttt{rustc}, but think about the future: when our
project has more than one file, we would need to call \texttt{rustc}
twice, and pass it a bunch of options to tell it to build everything
together. With Cargo, as our project grows, we can just
\texttt{cargo build} and it'll work the right way.

That's it! We've successfully built \texttt{hello\_world} with Cargo.
Even though our program is simple, it's using much of the real tooling
that you'll use for the rest of your Rust career.

Now that you've got the tools down, let's actually learn more about the
Rust language itself. These are the basics that will serve you well
through the rest of your time with Rust.

\section{Variable bindings}\label{variable-bindings}

The first thing we'll learn about are `variable bindings.' They look
like this:

\texttt{\{rust\} let x = 5i;}

In many languages, this is called a `variable.' But Rust's variable
bindings have a few tricks up their sleeves. Rust has a very powerful
feature called `pattern matching' that we'll get into detail with later,
but the left hand side of a \texttt{let} expression is a full pattern,
not just a variable name. This means we can do things like:

\texttt{\{rust\} let (x, y) = (1i, 2i);}

After this expression is evaluated, \texttt{x} will be one, and
\texttt{y} will be two. Patterns are really powerful, but this is about
all we can do with them so far. So let's just keep this in the back of
our minds as we go forward.

By the way, in these examples, \texttt{i} indicates that the number is
an integer.

Rust is a statically typed language, which means that we specify our
types up front. So why does our first example compile? Well, Rust has
this thing called
``\href{http://en.wikipedia.org/wiki/Hindley\%E2\%80\%93Milner_type_system}{Hindley-Milner
type inference}'', named after some really smart type theorists. If you
clicked that link, don't be scared: what this means for you is that Rust
will attempt to infer the types in your program, and it's pretty good at
it. If it can infer the type, Rust doesn't require you to actually type
it out.

We can add the type if we want to. Types come after a colon
(\texttt{:}):

\texttt{\{rust\} let x: int = 5;}

If I asked you to read this out loud to the rest of the class, you'd say
``\texttt{x} is a binding with the type \texttt{int} and the value
\texttt{five}.''

By default, bindings are \textbf{immutable}. This code will not compile:

\texttt{\{ignore\} let x = 5i; x = 10i;}

It will give you this error:

\texttt{\{ignore,notrust\} error: re-assignment of immutable variable `x`      x = 10i;      \^{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}}

If you want a binding to be mutable, you can use \texttt{mut}:

\texttt{\{rust\} let mut x = 5i; x = 10i;}

There is no single reason that bindings are immutable by default, but we
can think about it through one of Rust's primary focuses: safety. If you
forget to say \texttt{mut}, the compiler will catch it, and let you know
that you have mutated something you may not have cared to mutate. If
bindings were mutable by default, the compiler would not be able to tell
you this. If you \emph{did} intend mutation, then the solution is quite
easy: add \texttt{mut}.

There are other good reasons to avoid mutable state when possible, but
they're out of the scope of this guide. In general, you can often avoid
explicit mutation, and so it is preferable in Rust. That said,
sometimes, mutation is what you need, so it's not verboten.

Let's get back to bindings. Rust variable bindings have one more aspect
that differs from other languages: bindings are required to be
initialized with a value before you're allowed to use it. If we
try\ldots{}

\texttt{\{ignore\} let x;}

\ldots{}we'll get an error:

\texttt{\{ignore\} src/guessing\_game.rs:2:9: 2:10 error: cannot determine a type for this local variable: unconstrained type src/guessing\_game.rs:2     let x;                                \^{}}

Giving it a type will compile, though:

\texttt{\{ignore\} let x: int;}

Let's try it out. Change your \texttt{src/guessing\_game.rs} file to
look like this:

```\{rust\} fn main() \{ let x: int;

\begin{verbatim}
println!("Hello world!");
\end{verbatim}

\} ```

You can use \texttt{cargo build} on the command line to build it. You'll
get a warning, but it will still print ``Hello, world!'':

\texttt{\{ignore,notrust\}    Compiling guessing\_game v0.1.0 (file:/home/you/projects/guessing\_game) src/guessing\_game.rs:2:9: 2:10 warning: unused variable: `x`, \#{[}warn(unused\_variable){]} on by default src/guessing\_game.rs:2     let x: int;                                \^{}}

Rust warns us that we never use the variable binding, but since we never
use it, no harm, no foul. Things change if we try to actually use this
\texttt{x}, however. Let's do that. Change your program to look like
this:

```\{rust,ignore\} fn main() \{ let x: int;

\begin{verbatim}
println!("The value of x is: {}", x);
\end{verbatim}

\} ```

And try to build it. You'll get an error:

\texttt{\{bash\} \$ cargo build    Compiling guessing\_game v0.1.0 (file:/home/you/projects/guessing\_game) src/guessing\_game.rs:4:39: 4:40 error: use of possibly uninitialized variable: `x` src/guessing\_game.rs:4     println!("The value of x is: \{\}", x);                                                              \^{} note: in expansion of format\_args! \textless{}std macros\textgreater{}:2:23: 2:77 note: expansion site \textless{}std macros\textgreater{}:1:1: 3:2 note: in expansion of println! src/guessing\_game.rs:4:5: 4:42 note: expansion site error: aborting due to previous error Could not execute process `rustc src/guessing\_game.rs -\/-crate-type bin -\/-out-dir /home/you/projects/guessing\_game/target -L /home/you/projects/guessing\_game/target -L /home/you/projects/guessing\_game/target/deps` (status=101)}

Rust will not let us use a value that has not been initialized. So why
let us declare a binding without initializing it? You'd think our first
example would have errored. Well, Rust is smarter than that. Before we
get to that, let's talk about this stuff we've added to
\texttt{println!}.

If you include two curly braces (\texttt{\{\}}, some call them
moustaches\ldots{}) in your string to print, Rust will interpret this as
a request to interpolate some sort of value. \textbf{String
interpolation} is a computer science term that means ``stick in the
middle of a string.'' We add a comma, and then \texttt{x}, to indicate
that we want \texttt{x} to be the value we're interpolating. The comma
is used to separate arguments we pass to functions and macros, if you're
passing more than one.

When you just use the double curly braces, Rust will attempt to display
the value in a meaningful way by checking out its type. If you want to
specify the format in a more detailed manner, there are a
\href{/std/fmt/index.html}{wide number of options available}. For now,
we'll just stick to the default: integers aren't very complicated to
print.

So, we've cleared up all of the confusion around bindings, with one
exception: why does Rust let us declare a variable binding without an
initial value if we must initialize the binding before we use it? And
how does it know that we have or have not initialized the binding? For
that, we need to learn our next concept: \texttt{if}.

\section{If}\label{if}

Rust's take on \texttt{if} is not particularly complex, but it's much
more like the \texttt{if} you'll find in a dynamically typed language
than in a more traditional systems language. So let's talk about it, to
make sure you grasp the nuances.

\texttt{if} is a specific form of a more general concept, the `branch.'
The name comes from a branch in a tree: a decision point, where
depending on a choice, multiple paths can be taken.

In the case of \texttt{if}, there is one choice that leads down two
paths:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x = }\DecValTok{5i}\NormalTok{;}

\KeywordTok{if} \NormalTok{x == }\DecValTok{5i} \NormalTok{\{}
    \OtherTok{println!}\NormalTok{(}\StringTok{"x is five!"}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

If we changed the value of \texttt{x} to something else, this line would
not print. More specifically, if the expression after the \texttt{if}
evaluates to \texttt{true}, then the block is executed. If it's
\texttt{false}, then it is not.

If you want something to happen in the \texttt{false} case, use an
\texttt{else}:

\begin{verbatim}
let x = 5i;

if x == 5i {
    println!("x is five!");
} else {
    println!("x is not five :(");
}
\end{verbatim}

This is all pretty standard. However, you can also do this:

\begin{verbatim}
let x = 5i;

let y = if x == 5i {
    10i
} else {
    15i
};
\end{verbatim}

Which we can (and probably should) write like this:

\begin{verbatim}
let x = 5i;

let y = if x == 5i { 10i } else { 15i };
\end{verbatim}

This reveals two interesting things about Rust: it is an
expression-based language, and semicolons are different than in other
`curly brace and semicolon'-based languages. These two things are
related.

\subsection{Expressions vs.~Statements}\label{expressions-vs.statements}

Rust is primarily an expression based language. There are only two kinds
of statements, and everything else is an expression.

So what's the difference? Expressions return a value, and statements do
not. In many languages, \texttt{if} is a statement, and therefore,
\texttt{let x = if ...} would make no sense. But in Rust, \texttt{if} is
an expression, which means that it returns a value. We can then use this
value to initialize the binding.

Speaking of which, bindings are a kind of the first of Rust's two
statements. The proper name is a \textbf{declaration statement}. So far,
\texttt{let} is the only kind of declaration statement we've seen. Let's
talk about that some more.

In some languages, variable bindings can be written as expressions, not
just statements. Like Ruby:

\texttt{\{ruby\} x = y = 5}

In Rust, however, using \texttt{let} to introduce a binding is
\emph{not} an expression. The following will produce a compile-time
error:

\texttt{\{ignore\} let x = (let y = 5i); // found `let` in ident position}

The compiler is telling us here that it was expecting to see the
beginning of an expression, and a \texttt{let} can only begin a
statement, not an expression.

Note that assigning to an already-bound variable (e.g. \texttt{y = 5i})
is still an expression, although its value is not particularly useful.
Unlike C, where an assignment evaluates to the assigned value (e.g.
\texttt{5i} in the previous example), in Rust the value of an assignment
is the unit type \texttt{()} (which we'll cover later).

The second kind of statement in Rust is the \textbf{expression
statement}. Its purpose is to turn any expression into a statement. In
practical terms, Rust's grammar expects statements to follow other
statements. This means that you use semicolons to separate expressions
from each other. This means that Rust looks a lot like most other
languages that require you to use semicolons at the end of every line,
and you will see semicolons at the end of almost every line of Rust code
you see.

What is this exception that makes us say `almost?' You saw it already,
in this code:

\begin{verbatim}
let x = 5i;

let y: int = if x == 5i { 10i } else { 15i };
\end{verbatim}

Note that I've added the type annotation to \texttt{y}, to specify
explicitly that I want \texttt{y} to be an integer.

This is not the same as this, which won't compile:

```\{ignore\} let x = 5i;

let y: int = if x == 5 \{ 10i; \} else \{ 15i; \}; ```

Note the semicolons after the 10 and 15. Rust will give us the following
error:

\texttt{\{ignore,notrust\} error: mismatched types: expected `int` but found `()` (expected int but found ())}

We expected an integer, but we got \texttt{()}. \texttt{()} is
pronounced `unit', and is a special type in Rust's type system.
\texttt{()} is different than \texttt{null} in other languages, because
\texttt{()} is distinct from other types. For example, in C,
\texttt{null} is a valid value for a variable of type \texttt{int}. In
Rust, \texttt{()} is \emph{not} a valid value for a variable of type
\texttt{int}. It's only a valid value for variables of the type
\texttt{()}, which aren't very useful. Remember how we said statements
don't return a value? Well, that's the purpose of unit in this case. The
semicolon turns any expression into a statement by throwing away its
value and returning unit instead.

There's one more time in which you won't see a semicolon at the end of a
line of Rust code. For that, we'll need our next concept: functions.

\section{Functions}\label{functions}

You've already seen one function so far, the \texttt{main} function:

\texttt{\{rust\} fn main() \{ \}}

This is the simplest possible function declaration. As we mentioned
before, \texttt{fn} says `this is a function,' followed by the name,
some parenthesis because this function takes no arguments, and then some
curly braces to indicate the body. Here's a function named \texttt{foo}:

\texttt{\{rust\} fn foo() \{ \}}

So, what about taking arguments? Here's a function that prints a number:

\texttt{\{rust\} fn print\_number(x: int) \{     println!("x is: \{\}", x); \}}

Here's a complete program that uses \texttt{print\_number}:

```\{rust\} fn main() \{ print\_number(5); \}

fn print\_number(x: int) \{ println!(``x is: \{\}'', x); \} ```

As you can see, function arguments work very similar to \texttt{let}
declarations: you add a type to the argument name, after a colon.

Here's a complete program that adds two numbers together and prints
them:

```\{rust\} fn main() \{ print\_sum(5, 6); \}

fn print\_sum(x: int, y: int) \{ println!(``sum is: \{\}'', x + y); \}
```

You separate arguments with a comma, both when you call the function, as
well as when you declare it.

Unlike \texttt{let}, you \emph{must} declare the types of function
arguments. This does not work:

\texttt{\{ignore\} fn print\_number(x, y) \{     println!("x is: \{\}", x + y); \}}

You get this error:

\texttt{\{ignore,notrust\} hello.rs:5:18: 5:19 error: expected `:` but found `,` hello.rs:5 fn print\_number(x, y) \{}

This is a deliberate design decision. While full-program inference is
possible, languages which have it, like Haskell, often suggest that
documenting your types explicitly is a best-practice. We agree that
forcing functions to declare types while allowing for inference inside
of function bodies is a wonderful compromise between full inference and
no inference.

What about returning a value? Here's a function that adds one to an
integer:

\texttt{\{rust\} fn add\_one(x: int) -\textgreater{} int \{     x + 1 \}}

Rust functions return exactly one value, and you declare the type after
an `arrow', which is a dash (\texttt{-}) followed by a greater-than sign
(\texttt{\textgreater{}}).

You'll note the lack of a semicolon here. If we added it in:

\texttt{\{ignore\} fn add\_one(x: int) -\textgreater{} int \{     x + 1; \}}

We would get an error:

```\{ignore,notrust\} error: not all control paths return a value fn
add\_one(x: int) -\textgreater{} int \{ x + 1; \}

note: consider removing this semicolon: x + 1; \^{} ```

Remember our earlier discussions about semicolons and \texttt{()}? Our
function claims to return an \texttt{int}, but with a semicolon, it
would return \texttt{()} instead. Rust realizes this probably isn't what
we want, and suggests removing the semicolon.

This is very much like our \texttt{if} statement before: the result of
the block (\texttt{\{\}}) is the value of the expression. Other
expression-oriented languages, such as Ruby, work like this, but it's a
bit unusual in the systems programming world. When people first learn
about this, they usually assume that it introduces bugs. But because
Rust's type system is so strong, and because unit is its own unique
type, we have never seen an issue where adding or removing a semicolon
in a return position would cause a bug.

But what about early returns? Rust does have a keyword for that,
\texttt{return}:

```\{rust\} fn foo(x: int) -\textgreater{} int \{ if x \textless{} 5 \{
return x; \}

\begin{verbatim}
x + 1
\end{verbatim}

\} ```

Using a \texttt{return} as the last line of a function works, but is
considered poor style:

```\{rust\} fn foo(x: int) -\textgreater{} int \{ if x \textless{} 5 \{
return x; \}

\begin{verbatim}
return x + 1;
\end{verbatim}

\} ```

There are some additional ways to define functions, but they involve
features that we haven't learned about yet, so let's just leave it at
that for now.

\section{Comments}\label{comments}

Now that we have some functions, it's a good idea to learn about
comments. Comments are notes that you leave to other programmers to help
explain things about your code. The compiler mostly ignores them.

Rust has two kinds of comments that you should care about: \textbf{line
comment}s and \textbf{doc comment}s.

```\{rust\} // Line comments are anything after `//' and extend to the
end of the line.

let x = 5i; // this is also a line comment.

// If you have a long explanation for something, you can put line
comments next // to each other. Put a space between the // and your
comment so that it's // more readable. ```

The other kind of comment is a doc comment. Doc comments use
\texttt{///} instead of \texttt{//}, and support Markdown notation
inside:

\texttt{\{rust\} /// `hello` is a function that prints a greeting that is personalized based on /// the name given. /// /// \# Arguments /// /// * `name` - The name of the person you'd like to greet. /// /// \# Example /// ///}rust
/// let name = ``Steve''; /// hello(name); // prints ``Hello, Steve!''
///
\texttt{fn hello(name: \&str) \{     println!("Hello, \{\}!", name); \}}

When writing doc comments, adding sections for any arguments, return
values, and providing some examples of usage is very, very helpful.

You can use the \texttt{rustdoc} tool to generate HTML documentation
from these doc comments. We will talk more about \texttt{rustdoc} when
we get to modules, as generally, you want to export documentation for a
full module.

\section{Compound Data Types}\label{compound-data-types}

Rust, like many programming languages, has a number of different data
types that are built-in. You've already done some simple work with
integers and strings, but next, let's talk about some more complicated
ways of storing data.

\subsection{Tuples}\label{tuples}

The first compound data type we're going to talk about are called
\textbf{tuple}s. Tuples are an ordered list of a fixed size. Like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x = (}\DecValTok{1i}\NormalTok{, }\StringTok{"hello"}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

The parenthesis and commas form this two-length tuple. Here's the same
code, but with the type annotated:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x: (}\KeywordTok{int}\NormalTok{, &}\KeywordTok{str}\NormalTok{) = (}\DecValTok{1}\NormalTok{, }\StringTok{"hello"}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

As you can see, the type of a tuple looks just like the tuple, but with
each position having a type name rather than the value. Careful readers
will also note that tuples are heterogeneous: we have an \texttt{int}
and a \texttt{\&str} in this tuple. You haven't seen \texttt{\&str} as a
type before, and we'll discuss the details of strings later. In systems
programming languages, strings are a bit more complex than in other
languages. For now, just read \texttt{\&str} as ``a string slice,'' and
we'll learn more soon.

You can access the fields in a tuple through a \textbf{destructuring
let}. Here's an example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{(x, y, z) = (}\DecValTok{1i}\NormalTok{, }\DecValTok{2i}\NormalTok{, }\DecValTok{3i}\NormalTok{);}

\OtherTok{println!}\NormalTok{(}\StringTok{"x is \{\}"}\NormalTok{, x);}
\end{Highlighting}
\end{Shaded}

Remember before when I said the left hand side of a \texttt{let}
statement was more powerful than just assigning a binding? Here we are.
We can put a pattern on the left hand side of the \texttt{let}, and if
it matches up to the right hand side, we can assign multiple bindings at
once. In this case, \texttt{let} `destructures,' or `breaks up,' the
tuple, and assigns the bits to three bindings.

This pattern is very powerful, and we'll see it repeated more later.

The last thing to say about tuples is that they are only equivalent if
the arity, types, and values are all identical.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x = (}\DecValTok{1i}\NormalTok{, }\DecValTok{2i}\NormalTok{, }\DecValTok{3i}\NormalTok{);}
\KeywordTok{let} \NormalTok{y = (}\DecValTok{2i}\NormalTok{, }\DecValTok{3i}\NormalTok{, }\DecValTok{4i}\NormalTok{);}

\KeywordTok{if} \NormalTok{x == y \{}
    \OtherTok{println!}\NormalTok{(}\StringTok{"yes"}\NormalTok{);}
\NormalTok{\} }\KeywordTok{else} \NormalTok{\{}
    \OtherTok{println!}\NormalTok{(}\StringTok{"no"}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This will print \texttt{no}, as the values aren't equal.

One other use of tuples is to return multiple values from a function:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{next_two(x: }\KeywordTok{int}\NormalTok{) -> (}\KeywordTok{int}\NormalTok{, }\KeywordTok{int}\NormalTok{) \{ (x + }\DecValTok{1i}\NormalTok{, x + }\DecValTok{2i}\NormalTok{) \}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{(x, y) = next_two(}\DecValTok{5i}\NormalTok{);}
    \OtherTok{println!}\NormalTok{(}\StringTok{"x, y = \{\}, \{\}"}\NormalTok{, x, y);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Even though Rust functions can only return one value, a tuple \emph{is}
one value, that happens to be made up of two. You can also see in this
example how you can destructure a pattern returned by a function, as
well.

Tuples are a very simple data structure, and so are not often what you
want. Let's move on to their bigger sibling, structs.

\subsection{Structs}\label{structs}

A struct is another form of a `record type,' just like a tuple. There's
a difference: structs give each element that they contain a name, called
a `field' or a `member.' Check it out:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Point \{}
    \NormalTok{x: }\KeywordTok{int}\NormalTok{,}
    \NormalTok{y: }\KeywordTok{int}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{origin = Point \{ x: }\DecValTok{0i}\NormalTok{, y:  }\DecValTok{0i} \NormalTok{\};}

    \OtherTok{println!}\NormalTok{(}\StringTok{"The origin is at (\{\}, \{\})"}\NormalTok{, origin.x, origin.y);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

There's a lot going on here, so let's break it down. We declare a struct
with the \texttt{struct} keyword, and then with a name. By convention,
structs begin with a capital letter and are also camel cased:
\texttt{PointInSpace}, not \texttt{Point\_In\_Space}.

We can create an instance of our struct via \texttt{let}, as usual, but
we use a \texttt{key: value} style syntax to set each field. The order
doesn't need to be the same as in the original declaration.

Finally, because fields have names, we can access the field through dot
notation: \texttt{origin.x}.

The values in structs are immutable, like other bindings in Rust.
However, you can use \texttt{mut} to make them mutable:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Point \{}
    \NormalTok{x: }\KeywordTok{int}\NormalTok{,}
    \NormalTok{y: }\KeywordTok{int}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \KeywordTok{mut} \NormalTok{point = Point \{ x: }\DecValTok{0i}\NormalTok{, y:  }\DecValTok{0i} \NormalTok{\};}

    \NormalTok{point.x = }\DecValTok{5}\NormalTok{;}

    \OtherTok{println!}\NormalTok{(}\StringTok{"The point is at (\{\}, \{\})"}\NormalTok{, point.x, point.y);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This will print \texttt{The point is at (5, 0)}.

\subsection{Tuple Structs and
Newtypes}\label{tuple-structs-and-newtypes}

Rust has another data type that's like a hybrid between a tuple and a
struct, called a \textbf{tuple struct}. Tuple structs do have a name,
but their fields don't:

\begin{verbatim}
struct Color(int, int, int);
struct Point(int, int, int);
\end{verbatim}

These two will not be equal, even if they have the same values:

\texttt{\{rust,ignore\} let black  = Color(0, 0, 0); let origin = Point(0, 0, 0);}

It is almost always better to use a struct than a tuple struct. We would
write \texttt{Color} and \texttt{Point} like this instead:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{Color \{}
    \NormalTok{red: }\KeywordTok{int}\NormalTok{,}
    \NormalTok{blue: }\KeywordTok{int}\NormalTok{,}
    \NormalTok{green: }\KeywordTok{int}\NormalTok{,}
\NormalTok{\}}

\KeywordTok{struct} \NormalTok{Point \{}
    \NormalTok{x: }\KeywordTok{int}\NormalTok{,}
    \NormalTok{y: }\KeywordTok{int}\NormalTok{,}
    \NormalTok{z: }\KeywordTok{int}\NormalTok{,}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Now, we have actual names, rather than positions. Good names are
important, and with a struct, we have actual names.

There \emph{is} one case when a tuple struct is very useful, though, and
that's a tuple struct with only one element. We call this a `newtype,'
because it lets you create a new type that's a synonym for another one:

\begin{verbatim}
struct Inches(int);
struct Centimeters(int);

let length = Inches(10);

let Inches(integer_length) = length;
println!("length is {} inches", integer_length);
\end{verbatim}

As you can see here, you can extract the inner integer type through a
destructuring \texttt{let}.

\subsection{Enums}\label{enums}

Finally, Rust has a ``sum type'', an \textbf{enum}. Enums are an
incredibly useful feature of Rust, and are used throughout the standard
library. Enums look like this:

\begin{verbatim}
enum Ordering {
    Less,
    Equal,
    Greater,
}
\end{verbatim}

This is an enum that is provided by the Rust standard library. An
\texttt{Ordering} can only be \emph{one} of \texttt{Less},
\texttt{Equal}, or \texttt{Greater} at any given time. Here's an
example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn} \NormalTok{cmp(a: }\KeywordTok{int}\NormalTok{, b: }\KeywordTok{int}\NormalTok{) -> Ordering \{}
    \KeywordTok{if} \NormalTok{a < b \{ Less \}}
    \KeywordTok{else} \KeywordTok{if} \NormalTok{a > b \{ Greater \}}
    \KeywordTok{else} \NormalTok{\{ Equal \}}
\NormalTok{\}}

\KeywordTok{fn} \NormalTok{main() \{}
    \KeywordTok{let} \NormalTok{x = }\DecValTok{5i}\NormalTok{;}
    \KeywordTok{let} \NormalTok{y = }\DecValTok{10i}\NormalTok{;}

    \KeywordTok{let} \NormalTok{ordering = cmp(x, y);}

    \KeywordTok{if} \NormalTok{ordering == Less \{}
        \OtherTok{println!}\NormalTok{(}\StringTok{"less"}\NormalTok{);}
    \NormalTok{\} }\KeywordTok{else} \KeywordTok{if} \NormalTok{ordering == Greater \{}
        \OtherTok{println!}\NormalTok{(}\StringTok{"greater"}\NormalTok{);}
    \NormalTok{\} }\KeywordTok{else} \KeywordTok{if} \NormalTok{ordering == Equal \{}
        \OtherTok{println!}\NormalTok{(}\StringTok{"equal"}\NormalTok{);}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{cmp} is a function that compares two things, and returns an
\texttt{Ordering}. We return either \texttt{Less}, \texttt{Greater}, or
\texttt{Equal}, depending on if the two values are greater, less, or
equal.

The \texttt{ordering} variable has the type \texttt{Ordering}, and so
contains one of the three values. We can then do a bunch of
\texttt{if}/\texttt{else} comparisons to check which one it is.

However, repeated \texttt{if}/\texttt{else} comparisons get quite
tedious. Rust has a feature that not only makes them nicer to read, but
also makes sure that you never miss a case. Before we get to that,
though, let's talk about another kind of enum: one with values.

This enum has two variants, one of which has a value:

```\{rust\} enum OptionalInt \{ Value(int), Missing, \}

fn main() \{ let x = Value(5); let y = Missing;

\begin{verbatim}
match x {
    Value(n) => println!("x is {:d}", n),
    Missing  => println!("x is missing!"),
}

match y {
    Value(n) => println!("y is {:d}", n),
    Missing  => println!("y is missing!"),
}
\end{verbatim}

\}

\begin{verbatim}

This enum represents an `int` that we may or may not have. In the `Missing`
case, we have no value, but in the `Value` case, we do. This enum is specific
to `int`s, though. We can make it usable by any type, but we haven't quite
gotten there yet!

You can have any number of values in an enum:
\end{verbatim}

enum OptionalColor \{ Color(int, int, int), Missing \} ```

Enums with values are quite useful, but as I mentioned, they're even
more useful when they're generic across types. But before we get to
generics, let's talk about how to fix this big \texttt{if}/\texttt{else}
statements we've been writing. We'll do that with \texttt{match}.

\section{Match}\label{match}

Often, a simple \texttt{if}/\texttt{else} isn't enough, because you have
more than two possible options. And \texttt{else} conditions can get
incredibly complicated. So what's the solution?

Rust has a keyword, \texttt{match}, that allows you to replace
complicated \texttt{if}/\texttt{else} groupings with something more
powerful. Check it out:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let} \NormalTok{x = }\DecValTok{5i}\NormalTok{;}

\KeywordTok{match} \NormalTok{x \{}
    \DecValTok{1} \NormalTok{=> }\OtherTok{println!}\NormalTok{(}\StringTok{"one"}\NormalTok{),}
    \DecValTok{2} \NormalTok{=> }\OtherTok{println!}\NormalTok{(}\StringTok{"two"}\NormalTok{),}
    \DecValTok{3} \NormalTok{=> }\OtherTok{println!}\NormalTok{(}\StringTok{"three"}\NormalTok{),}
    \DecValTok{4} \NormalTok{=> }\OtherTok{println!}\NormalTok{(}\StringTok{"four"}\NormalTok{),}
    \DecValTok{5} \NormalTok{=> }\OtherTok{println!}\NormalTok{(}\StringTok{"five"}\NormalTok{),}
    \NormalTok{_ => }\OtherTok{println!}\NormalTok{(}\StringTok{"something else"}\NormalTok{),}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{match} takes an expression, and then branches based on its
value. Each `arm' of the branch is of the form
\texttt{val =\textgreater{} expression}. When the value matches, that
arm's expression will be evaluated. It's called \texttt{match} because
of the term `pattern matching,' which \texttt{match} is an
implementation of.

So what's the big advantage here? Well, there are a few. First of all,
\texttt{match} does `exhaustiveness checking.' Do you see that last arm,
the one with the underscore (\texttt{\_})? If we remove that arm, Rust
will give us an error:

\texttt{\{ignore,notrust\} error: non-exhaustive patterns: `\_` not covered}

In other words, Rust is trying to tell us we forgot a value. Because
\texttt{x} is an integer, Rust knows that it can have a number of
different values. For example, \texttt{6i}. But without the \texttt{\_},
there is no arm that could match, and so Rust refuses to compile.
\texttt{\_} is sort of like a catch-all arm. If none of the other arms
match, the arm with \texttt{\_} will. And since we have this catch-all
arm, we now have an arm for every possible value of \texttt{x}, and so
our program will now compile.

\texttt{match} statements also destructure enums, as well. Remember this
code from the section on enums?

```\{rust\} fn cmp(a: int, b: int) -\textgreater{} Ordering \{ if a
\textless{} b \{ Less \} else if a \textgreater{} b \{ Greater \} else
\{ Equal \} \}

fn main() \{ let x = 5i; let y = 10i;

\begin{verbatim}
let ordering = cmp(x, y);

if ordering == Less {
    println!("less");
} else if ordering == Greater {
    println!("greater");
} else if ordering == Equal {
    println!("equal");
}
\end{verbatim}

\} ```

We can re-write this as a \texttt{match}:

```\{rust\} fn cmp(a: int, b: int) -\textgreater{} Ordering \{ if a
\textless{} b \{ Less \} else if a \textgreater{} b \{ Greater \} else
\{ Equal \} \}

fn main() \{ let x = 5i; let y = 10i;

\begin{verbatim}
match cmp(x, y) {
    Less    => println!("less"),
    Greater => println!("greater"),
    Equal   => println!("equal"),
}
\end{verbatim}

\} ```

This version has way less noise, and it also checks exhaustively to make
sure that we have covered all possible variants of \texttt{Ordering}.
With our \texttt{if}/\texttt{else} version, if we had forgotten the
\texttt{Greater} case, for example, our program would have happily
compiled. If we forget in the \texttt{match}, it will not. Rust helps us
make sure to cover all of our bases.

\texttt{match} is also an expression, which means we can use it on the
right hand side of a \texttt{let} binding. We could also implement the
previous line like this:

```\{rust\} fn cmp(a: int, b: int) -\textgreater{} Ordering \{ if a
\textless{} b \{ Less \} else if a \textgreater{} b \{ Greater \} else
\{ Equal \} \}

fn main() \{ let x = 5i; let y = 10i;

\begin{verbatim}
let result = match cmp(x, y) {
    Less    => "less",
    Greater => "greater",
    Equal   => "equal",
};

println!("{}", result);
\end{verbatim}

\} ```

In this case, it doesn't make a lot of sense, as we are just making a
temporary string where we don't need to, but sometimes, it's a nice
pattern.

\section{Looping}\label{looping}

Looping is the last basic construct that we haven't learned yet in Rust.
Rust has two main looping constructs: \texttt{for} and \texttt{while}.

\subsection{\texttt{for}}\label{for}

The \texttt{for} loop is used to loop a particular number of times.
Rust's \texttt{for} loops work a bit differently than in other systems
languages, however. Rust's \texttt{for} loop doesn't look like this C
\texttt{for} loop:

\texttt{\{ignore,c\} for (x = 0; x \textless{} 10; x++) \{     printf( "\%d\textbackslash{}n", x ); \}}

It looks like this:

\texttt{\{rust\} for x in range(0i, 10i) \{     println!("\{:d\}", x); \}}

In slightly more abstract terms,

\texttt{\{ignore,notrust\} for var in expression \{     code \}}

The expression is an iterator, which we will discuss in more depth later
in the guide. The iterator gives back a series of elements. Each element
is one iteration of the loop. That value is then bound to the name
\texttt{var}, which is valid for the loop body. Once the body is over,
the next value is fetched from the iterator, and we loop another time.
When there are no more values, the \texttt{for} loop is over.

In our example, the \texttt{range} function is a function, provided by
Rust, that takes a start and an end position, and gives an iterator over
those values. The upper bound is exclusive, though, so our loop will
print \texttt{0} through \texttt{9}, not \texttt{10}.

Rust does not have the ``C style'' \texttt{for} loop on purpose.
Manually controlling each element of the loop is complicated and error
prone, even for experienced C developers. There's an old joke that goes,
``There are two hard problems in computer science: naming things, cache
invalidation, and off-by-one errors.'' The joke, of course, being that
the setup says ``two hard problems'' but then lists three things. This
happens quite a bit with ``C style'' \texttt{for} loops.

We'll talk more about \texttt{for} when we cover \textbf{vector}s, later
in the Guide.

\subsection{\texttt{while}}\label{while}

The other kind of looping construct in Rust is the \texttt{while} loop.
It looks like this:

```\{rust\} let mut x = 5u; let mut done = false;

while !done \{ x += x - 3; println!(``\{\}'', x); if x \% 5 == 0 \{ done
= true; \} \} ```

\texttt{while} loops are the correct choice when you're not sure how
many times you need to loop.

If you need an infinite loop, you may be tempted to write this:

\texttt{\{rust,ignore\} while true \{}

Rust has a dedicated keyword, \texttt{loop}, to handle this case:

\texttt{\{rust,ignore\} loop \{}

Rust's control-flow analysis treats this construct differently than a
\texttt{while true}, since we know that it will always loop. The details
of what that \emph{means} aren't super important to understand at this
stage, but in general, the more information we can give to the compiler,
the better it can do with safety and code generation. So you should
always prefer \texttt{loop} when you plan to loop infinitely.

\subsection{Ending iteration early}\label{ending-iteration-early}

Let's take a look at that \texttt{while} loop we had earlier:

```\{rust\} let mut x = 5u; let mut done = false;

while !done \{ x += x - 3; println!(``\{\}'', x); if x \% 5 == 0 \{ done
= true; \} \} ```

We had to keep a dedicated \texttt{mut} boolean variable binding,
\texttt{done}, to know when we should skip out of the loop. Rust has two
keywords to help us with modifying iteration: \texttt{break} and
\texttt{continue}.

In this case, we can write the loop in a better way with \texttt{break}:

```\{rust\} let mut x = 5u;

loop \{ x += x - 3; println!(``\{\}'', x); if x \% 5 == 0 \{ break; \}
\}

\begin{verbatim}

We now loop forever with `loop`, and use `break` to break out early.

`continue` is similar, but instead of ending the loop, goes to the next
iteration: This will only print the odd numbers:
\end{verbatim}

for x in range(0i, 10i) \{ if x \% 2 == 0 \{ continue; \}

\begin{verbatim}
println!("{:d}", x);
\end{verbatim}

\} ```

Both \texttt{continue} and \texttt{break} are valid in both kinds of
loops.

We have now learned all of the most basic Rust concepts. We're ready to
start building our guessing game, but we need to know how to do one last
thing first: get input from the keyboard. You can't have a guessing game
without the ability to guess!

\section{Standard Input}\label{standard-input}

Getting input from the keyboard is pretty easy, but uses some things we
haven't seen before. Here's a simple program that reads some input, and
then prints it back out:

```\{rust,ignore\} use std::io;

fn main() \{ println!(``Type something!'');

\begin{verbatim}
let input = std::io::stdin().read_line().ok().expect("Failed to read line");

println!("{}", input);
\end{verbatim}

\} ```

Let's go over these chunks, one by one:

\texttt{\{rust,ignore\} std::io::stdin();}

This calls a function, \texttt{stdin()}, that lives inside the
\texttt{std::io} module. As you can imagine, everything in \texttt{std}
is provided by Rust, the `standard library.' We'll talk more about the
module system later.

Since writing the fully qualified name all the time is annoying, we can
use the \texttt{use} statement to import it in:

```\{rust\} use std::io::stdin;

stdin(); ```

However, it's considered better practice to not import individual
functions, but to import the module, and only use one level of
qualification:

```\{rust\} use std::io;

io::stdin(); ```

Let's update our example to use this style:

```\{rust,ignore\} use std::io;

fn main() \{ println!(``Type something!'');

\begin{verbatim}
let input = io::stdin().read_line().ok().expect("Failed to read line");

println!("{}", input);
\end{verbatim}

\} ```

Next up:

\texttt{\{rust,ignore\} .read\_line()}

The \texttt{read\_line()} method can be called on the result of
\texttt{stdin()} to return a full line of input. Nice and easy.

\texttt{\{rust,ignore\} .ok().expect("Failed to read line");}

Do you remember this code?

\begin{verbatim}
enum OptionalInt {
    Value(int),
    Missing,
}

fn main() {
    let x = Value(5);
    let y = Missing;

    match x {
        Value(n) => println!("x is {:d}", n),
        Missing  => println!("x is missing!"),
    }

    match y {
        Value(n) => println!("y is {:d}", n),
        Missing  => println!("y is missing!"),
    }
}
\end{verbatim}

We had to match each time, to see if we had a value or not. In this
case, though, we \emph{know} that \texttt{x} has a \texttt{Value}. But
\texttt{match} forces us to handle the \texttt{missing} case. This is
what we want 99\% of the time, but sometimes, we know better than the
compiler.

Likewise, \texttt{read\_line()} does not return a line of input. It
\emph{might} return a line of input. It might also fail to do so. This
could happen if our program isn't running in a terminal, but as part of
a cron job, or some other context where there's no standard input.
Because of this, \texttt{read\_line} returns a type very similar to our
\texttt{OptionalInt}: an \texttt{IoResult\textless{}T\textgreater{}}. We
haven't talked about \texttt{IoResult\textless{}T\textgreater{}} yet
because it is the \textbf{generic} form of our \texttt{OptionalInt}.
Until then, you can think of it as being the same thing, just for any
type, not just \texttt{int}s.

Rust provides a method on these
\texttt{IoResult\textless{}T\textgreater{}}s called \texttt{ok()}, which
does the same thing as our \texttt{match} statement, but assuming that
we have a valid value. If we don't, it will terminate our program. In
this case, if we can't get input, our program doesn't work, so we're
okay with that. In most cases, we would want to handle the error case
explicitly. The result of \texttt{ok()} has a method, \texttt{expect()},
which allows us to give an error message if this crash happens.

We will cover the exact details of how all of this works later in the
Guide. For now, this gives you enough of a basic understanding to work
with.

Back to the code we were working on! Here's a refresher:

```\{rust,ignore\} use std::io;

fn main() \{ println!(``Type something!'');

\begin{verbatim}
let input = io::stdin().read_line().ok().expect("Failed to read line");

println!("{}", input);
\end{verbatim}

\} ```

With long lines like this, Rust gives you some flexibility with the
whitespace. We \emph{could} write the example like this:

```\{rust,ignore\} use std::io;

fn main() \{ println!(``Type something!'');

\begin{verbatim}
let input = io::stdin()
              .read_line()
              .ok()
              .expect("Failed to read line");

println!("{}", input);
\end{verbatim}

\} ```

Sometimes, this makes things more readable. Sometimes, less. Use your
judgement here.

That's all you need to get basic input from the standard input! It's not
too complicated, but there are a number of small parts.

\section{Guessing Game}\label{guessing-game}

Okay! We've got the basics of Rust down. Let's write a bigger program.

For our first project, we'll implement a classic beginner programming
problem: the guessing game. Here's how it works: Our program will
generate a random integer between one and a hundred. It will then prompt
us to enter a guess. Upon entering our guess, it will tell us if we're
too low or too high. Once we guess correctly, it will congratulate us,
and print the number of guesses we've taken to the screen. Sound good?

\subsection{Set up}\label{set-up}

Let's set up a new project. Go to your projects directory, and make a
new directory for the project, as well as a \texttt{src} directory for
our code:

\texttt{\{bash\} \$ cd \textasciitilde{}/projects \$ mkdir guessing\_game \$ cd guessing\_game \$ mkdir src}

Great. Next, let's make a \texttt{Cargo.toml} file so Cargo knows how to
build our project:

```\{ignore\} {[}package{]}

name = ``guessing\_game'' version = ``0.1.0'' authors = {[}
``someone@example.com'' {]}

{[}{[}bin{]}{]}

name = ``guessing\_game'' ```

Finally, we need our source file. Let's just make it hello world for
now, so we can check that our setup works. In
\texttt{src/guessing\_game.rs}:

\texttt{\{rust\} fn main() \{     println!("Hello world!"); \}}

Let's make sure that worked:

\texttt{\{bash\} \$ cargo build    Compiling guessing\_game v0.1.0 (file:/home/you/projects/guessing\_game) \$}

Excellent! Open up your \texttt{src/guessing\_game.rs} again. We'll be
writing all of our code in this file. We'll talk about multiple-file
projects later on in the guide.

\subsection{Processing a Guess}\label{processing-a-guess}

Let's get to it! The first thing we need to do for our guessing game is
allow our player to input a guess. Put this in your
\texttt{src/guessing\_game.rs}:

```\{rust,no\_run\} use std::io;

fn main() \{ println!(``Guess the number!'');

\begin{verbatim}
println!("Please input your guess.");

let input = io::stdin().read_line()
                       .ok()
                       .expect("Failed to read line");

println!("You guessed: {}", input);
\end{verbatim}

\} ```

You've seen this code before, when we talked about standard input. We
import the \texttt{std::io} module with \texttt{use}, and then our
\texttt{main} function contains our program's logic. We print a little
message announcing the game, ask the user to input a guess, get their
input, and then print it out.

Because we talked about this in the section on standard I/O, I won't go
into more details here. If you need a refresher, go re-read that
section.

\subsection{Generating a secret
number}\label{generating-a-secret-number}

Next, we need to generate a secret number. To do that, we need to use
Rust's random number generation, which we haven't talked about yet. Rust
includes a bunch of interesting functions in its standard library. If
you need a bit of code, it's possible that it's already been written for
you! In this case, we do know that Rust has random number generation,
but we don't know how to use it.

Enter the docs. Rust has a page specifically to document the standard
library. You can find that page \href{std/index.html}{here}. There's a
lot of information on that page, but the best part is the search bar.
Right up at the top, there's a box that you can enter in a search term.
The search is pretty primitive right now, but is getting better all the
time. If you type `random' in that box, the page will update to
\href{http://doc.rust-lang.org/std/index.html?search=random}{this one}.
The very first result is a link to
\href{http://doc.rust-lang.org/std/rand/fn.random.html}{std::rand::random}.
If we click on that result, we'll be taken to its documentation page.

This page shows us a few things: the type signature of the function,
some explanatory text, and then an example. Let's modify our code to add
in the \texttt{random} function:

```\{rust,ignore\} use std::io; use std::rand;

fn main() \{ println!(``Guess the number!'');

\begin{verbatim}
let secret_number = (rand::random() % 100i) + 1i;

println!("The secret number is: {}", secret_number);

println!("Please input your guess.");

let input = io::stdin().read_line()
                       .ok()
                       .expect("Failed to read line");


println!("You guessed: {}", input);
\end{verbatim}

\} ```

The first thing we changed was to \texttt{use std::rand}, as the docs
explained. We then added in a \texttt{let} expression to create a
variable binding named \texttt{secret\_number}, and we printed out its
result. Let's try to compile this using \texttt{cargo build}:

\texttt{\{notrust,no\_run\} \$ cargo build    Compiling guessing\_game v0.1.0 (file:/home/you/projects/guessing\_game) src/guessing\_game.rs:7:26: 7:34 error: the type of this value must be known in this context src/guessing\_game.rs:7     let secret\_number = (rand::random() \% 100i) + 1i;                                                 \^{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{} error: aborting due to previous error}

It didn't work! Rust says ``the type of this value must be known in this
context.'' What's up with that? Well, as it turns out,
\texttt{rand::random()} can generate many kinds of random values, not
just integers. And in this case, Rust isn't sure what kind of value
\texttt{random()} should generate. So we have to help it. With number
literals, we just add an \texttt{i} onto the end to tell Rust they're
integers, but that does not work with functions. There's a different
syntax, and it looks like this:

\texttt{\{rust,ignore\} rand::random::\textless{}int\textgreater{}();}

This says ``please give me a random \texttt{int} value.'' We can change
our code to use this hint\ldots{}

```\{rust,no\_run\} use std::io; use std::rand;

fn main() \{ println!(``Guess the number!'');

\begin{verbatim}
let secret_number = (rand::random::<int>() % 100i) + 1i;

println!("The secret number is: {}", secret_number);

println!("Please input your guess.");

let input = io::stdin().read_line()
                       .ok()
                       .expect("Failed to read line");


println!("You guessed: {}", input);
\end{verbatim}

\} ```

\ldots{} and then recompile:

\texttt{\{notrust,ignore\} \$ cargo build   Compiling guessing\_game v0.1.0 (file:/home/steve/tmp/guessing\_game) \$}

Excellent! Try running our new program a few times:

\texttt{\{notrust,ignore\} \$ ./target/guessing\_game  Guess the number! The secret number is: 7 Please input your guess. 4 You guessed: 4 \$ ./target/guessing\_game  Guess the number! The secret number is: 83 Please input your guess. 5 You guessed: 5 \$ ./target/guessing\_game  Guess the number! The secret number is: -29 Please input your guess. 42 You guessed: 42}

Wait. Negative 29? We wanted a number between one and a hundred! We have
two options here: we can either ask \texttt{random()} to generate an
unsigned integer, which can only be positive, or we can use the
\texttt{abs()} function. Let's go with the unsigned integer approach. If
we want a random positive number, we should ask for a random positive
number. Our code looks like this now:

```\{rust,no\_run\} use std::io; use std::rand;

fn main() \{ println!(``Guess the number!'');

\begin{verbatim}
let secret_number = (rand::random::<uint>() % 100u) + 1u;

println!("The secret number is: {}", secret_number);

println!("Please input your guess.");

let input = io::stdin().read_line()
                       .ok()
                       .expect("Failed to read line");


println!("You guessed: {}", input);
\end{verbatim}

\} ```

And trying it out:

\texttt{\{notrust,ignore\} \$ cargo build    Compiling guessing\_game v0.1.0 (file:/home/you/projects/guessing\_game) \$ ./target/guessing\_game  Guess the number! The secret number is: 57 Please input your guess. 3 You guessed: 3}

Great! Next up: let's compare our guess to the secret guess.

\subsection{Comparing guesses}\label{comparing-guesses}

If you remember, earlier in the tutorial, we made a \texttt{cmp}
function that compared two numbers. Let's add that in, along with a
\texttt{match} statement to compare the guess to the secret guess:

```\{rust,ignore\} use std::io; use std::rand;

fn main() \{ println!(``Guess the number!'');

\begin{verbatim}
let secret_number = (rand::random::<uint>() % 100u) + 1u;

println!("The secret number is: {}", secret_number);

println!("Please input your guess.");

let input = io::stdin().read_line()
                       .ok()
                       .expect("Failed to read line");


println!("You guessed: {}", input);

match cmp(input, secret_number) { 
    Less    => println!("Too small!"),
    Greater => println!("Too big!"),
    Equal   => { println!("You win!"); },
}
\end{verbatim}

\}

fn cmp(a: int, b: int) -\textgreater{} Ordering \{ if a \textless{} b \{
Less \} else if a \textgreater{} b \{ Greater \} else \{ Equal \} \} ```

If we try to compile, we'll get some errors:

\texttt{\{notrust,ignore\} \$ cargo build \$ cargo build    Compiling guessing\_game v0.1.0 (file:/home/you/projects/guessing\_game) src/guessing\_game.rs:20:15: 20:20 error: mismatched types: expected `int` but found `collections::string::String` (expected int but found struct collections::string::String) src/guessing\_game.rs:20     match cmp(input, secret\_number) \{                                       \^{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{} src/guessing\_game.rs:20:22: 20:35 error: mismatched types: expected `int` but found `uint` (expected int but found uint) src/guessing\_game.rs:20     match cmp(input, secret\_number) \{                                              \^{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{} error: aborting due to 2 previous errors}

This often happens when writing Rust programs, and is one of Rust's
greatest strengths. You try out some code, see if it compiles, and Rust
tells you that you've done something wrong. In this case, our
\texttt{cmp} function works on integers, but we've given it unsigned
integers. In this case, the fix is easy, because we wrote the
\texttt{cmp} function! Let's change it to take \texttt{uint}s:

```\{rust,ignore\} use std::io; use std::rand;

fn main() \{ println!(``Guess the number!'');

\begin{verbatim}
let secret_number = (rand::random::<uint>() % 100u) + 1u;

println!("The secret number is: {}", secret_number);

println!("Please input your guess.");

let input = io::stdin().read_line()
                       .ok()
                       .expect("Failed to read line");


println!("You guessed: {}", input);

match cmp(input, secret_number) {
    Less    => println!("Too small!"),
    Greater => println!("Too big!"),
    Equal   => { println!("You win!"); },
}
\end{verbatim}

\}

fn cmp(a: uint, b: uint) -\textgreater{} Ordering \{ if a \textless{} b
\{ Less \} else if a \textgreater{} b \{ Greater \} else \{ Equal \} \}
```

And try compiling again:

\texttt{\{notrust,ignore\} \$ cargo build    Compiling guessing\_game v0.1.0 (file:/home/you/projects/guessing\_game) src/guessing\_game.rs:20:15: 20:20 error: mismatched types: expected `uint` but found `collections::string::String` (expected uint but found struct collections::string::String) src/guessing\_game.rs:20     match cmp(input, secret\_number) \{                                       \^{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{} error: aborting due to previous error}

This error is similar to the last one: we expected to get a
\texttt{uint}, but we got a \texttt{String} instead! That's because our
\texttt{input} variable is coming from the standard input, and you can
guess anything. Try it:

\texttt{\{notrust,ignore\} \$ ./target/guessing\_game  Guess the number! The secret number is: 73 Please input your guess. hello You guessed: hello}

Oops! Also, you'll note that we just ran our program even though it
didn't compile. This works because the older version we did successfully
compile was still lying around. Gotta be careful!

Anyway, we have a \texttt{String}, but we need a \texttt{uint}. What to
do? Well, there's a function for that:

\texttt{\{rust,ignore\} let input = io::stdin().read\_line()                        .ok()                        .expect("Failed to read line"); let guess: Option\textless{}uint\textgreater{} = from\_str(input.as\_slice());}

The \texttt{from\_str} function takes in a \texttt{\&str} value and
converts it into something. We tell it what kind of something with a
type hint. Remember our type hint with \texttt{random()}? It looked like
this:

\texttt{\{rust,ignore\} rand::random::\textless{}uint\textgreater{}();}

There's an alternate way of providing a hint too, and that's declaring
the type in a \texttt{let}:

\texttt{\{rust,ignore\} let x: uint = rand::random();}

In this case, we say \texttt{x} is a \texttt{uint} explicitly, so Rust
is able to properly tell \texttt{random()} what to generate. In a
similar fashion, both of these work:

\texttt{\{rust,ignore\} let guess = from\_str::\textless{}Option\textless{}uint\textgreater{}\textgreater{}("5"); let guess: Option\textless{}uint\textgreater{} = from\_str("5");}

In this case, I happen to prefer the latter, and in the
\texttt{random()} case, I prefer the former. I think the nested
\texttt{\textless{}\textgreater{}}s make the first option especially
ugly and a bit harder to read.

Anyway, with us now convering our input to a number, our code looks like
this:

```\{rust,ignore\} use std::io; use std::rand;

fn main() \{ println!(``Guess the number!'');

\begin{verbatim}
let secret_number = (rand::random::<uint>() % 100u) + 1u;

println!("The secret number is: {}", secret_number);

println!("Please input your guess.");

let input = io::stdin().read_line()
                       .ok()
                       .expect("Failed to read line");
let input_num: Option<uint> = from_str(input.as_slice());



println!("You guessed: {}", input_num);

match cmp(input_num, secret_number) {
    Less    => println!("Too small!"),
    Greater => println!("Too big!"),
    Equal   => { println!("You win!"); },
}
\end{verbatim}

\}

fn cmp(a: uint, b: uint) -\textgreater{} Ordering \{ if a \textless{} b
\{ Less \} else if a \textgreater{} b \{ Greater \} else \{ Equal \} \}
```

Let's try it out!

\texttt{\{notrust,ignore\} \$ cargo build    Compiling guessing\_game v0.1.0 (file:/home/steve/tmp/guessing\_game) src/guessing\_game.rs:22:15: 22:24 error: mismatched types: expected `uint` but found `core::option::Option\textless{}uint\textgreater{}` (expected uint but found enum core::option::Option) src/guessing\_game.rs:22     match cmp(input\_num, secret\_number) \{                                       \^{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{} error: aborting due to previous error}

Oh yeah! Our \texttt{input\_num} has the type
\texttt{Option\textless{}uint\textgreater{}}, rather than \texttt{uint}.
We need to unwrap the Option. If you remember from before,
\texttt{match} is a great way to do that. Try this code:

```\{rust,no\_run\} use std::io; use std::rand;

fn main() \{ println!(``Guess the number!'');

\begin{verbatim}
let secret_number = (rand::random::<uint>() % 100u) + 1u;

println!("The secret number is: {}", secret_number);

println!("Please input your guess.");

let input = io::stdin().read_line()
                       .ok()
                       .expect("Failed to read line");
let input_num: Option<uint> = from_str(input.as_slice());

let num = match input_num {
    Some(num) => num,
    None      => {
        println!("Please input a number!");
        return;
    }
};


println!("You guessed: {}", num);

match cmp(num, secret_number) {
    Less    => println!("Too small!"),
    Greater => println!("Too big!"),
    Equal   => { println!("You win!"); },
}
\end{verbatim}

\}

fn cmp(a: uint, b: uint) -\textgreater{} Ordering \{ if a \textless{} b
\{ Less \} else if a \textgreater{} b \{ Greater \} else \{ Equal \} \}
```

We use a \texttt{match} to either give us the \texttt{uint} inside of
the \texttt{Option}, or we print an error message and return. Let's give
this a shot:

\texttt{\{notrust,ignore\} \$ cargo build    Compiling guessing\_game v0.1.0 (file:/home/you/projects/guessing\_game) \$ ./target/guessing\_game  Guess the number! The secret number is: 17 Please input your guess. 5 Please input a number! \$}

Uh, what? But we did!

\ldots{} actually, we didn't. See, when you get a line of input from
\texttt{stdin()}, you get all the input. Including the
\texttt{\textbackslash{}n} character from you pressing Enter. So,
\texttt{from\_str()} sees the string \texttt{"5\textbackslash{}n"} and
says ``nope, that's not a number, there's non-number stuff in there!''
Luckily for us, \texttt{\&str}s have an easy method we can use defined
on them: \texttt{trim()}. One small modification, and our code looks
like this:

```\{rust,no\_run\} use std::io; use std::rand;

fn main() \{ println!(``Guess the number!'');

\begin{verbatim}
let secret_number = (rand::random::<uint>() % 100u) + 1u;

println!("The secret number is: {}", secret_number);

println!("Please input your guess.");

let input = io::stdin().read_line()
                       .ok()
                       .expect("Failed to read line");
let input_num: Option<uint> = from_str(input.as_slice().trim());

let num = match input_num {
    Some(num) => num,
    None      => {
        println!("Please input a number!");
        return;
    }
};


println!("You guessed: {}", num);

match cmp(num, secret_number) {
    Less    => println!("Too small!"),
    Greater => println!("Too big!"),
    Equal   => { println!("You win!"); },
}
\end{verbatim}

\}

fn cmp(a: uint, b: uint) -\textgreater{} Ordering \{ if a \textless{} b
\{ Less \} else if a \textgreater{} b \{ Greater \} else \{ Equal \} \}
```

Let's try it!

\texttt{\{notrust,ignore\} \$ cargo build    Compiling guessing\_game v0.1.0 (file:/home/you/projects/guessing\_game) \$ ./target/guessing\_game  Guess the number! The secret number is: 58 Please input your guess.   76   You guessed: 76 Too big! \$}

Nice! You can see I even added spaces before my guess, and it still
figured out that I guessed 76. Run the program a few times, and verify
that guessing the number works, as well as guessing a number too small.

The Rust compiler helped us out quite a bit there! This technique is
called ``lean on the compiler,'' and it's often useful when working on
some code. Let the error messages help guide you towards the correct
types.

Now we've got most of the game working, but we can only make one guess.
Let's change that by adding loops!

\subsection{Looping}\label{looping-1}

As we already discussed, the \texttt{loop} key word gives us an infinite
loop. So let's add that in:

```\{rust,no\_run\} use std::io; use std::rand;

fn main() \{ println!(``Guess the number!'');

\begin{verbatim}
let secret_number = (rand::random::<uint>() % 100u) + 1u;

println!("The secret number is: {}", secret_number);

loop {

    println!("Please input your guess.");

    let input = io::stdin().read_line()
                           .ok()
                           .expect("Failed to read line");
    let input_num: Option<uint> = from_str(input.as_slice().trim());

    let num = match input_num {
        Some(num) => num,
        None      => {
            println!("Please input a number!");
            return;
        }
    };


    println!("You guessed: {}", num);

    match cmp(num, secret_number) {
        Less    => println!("Too small!"),
        Greater => println!("Too big!"),
        Equal   => { println!("You win!"); },
    }
}
\end{verbatim}

\}

fn cmp(a: uint, b: uint) -\textgreater{} Ordering \{ if a \textless{} b
\{ Less \} else if a \textgreater{} b \{ Greater \} else \{ Equal \} \}
```

And try it out. But wait, didn't we just add an infinite loop? Yup.
Remember that \texttt{return}? If we give a non-number answer, we'll
\texttt{return} and quit. Observe:

\texttt{\{notrust,ignore\} \$ cargo build    Compiling guessing\_game v0.1.0 (file:/home/you/projects/guessing\_game) steve@computer:\textasciitilde{}/tmp/guessing\_game\$ ./target/guessing\_game  Guess the number! The secret number is: 59 Please input your guess. 45 You guessed: 45 Too small! Please input your guess. 60 You guessed: 60 Too big! Please input your guess. 59 You guessed: 59 You win! Please input your guess. quit Please input a number! \$}

Ha! \texttt{quit} actually quits. As does any other non-number input.
Well, this is suboptimal to say the least. First, let's actually quit
when you win the game:

```\{rust,no\_run\} use std::io; use std::rand;

fn main() \{ println!(``Guess the number!'');

\begin{verbatim}
let secret_number = (rand::random::<uint>() % 100u) + 1u;

println!("The secret number is: {}", secret_number);

loop {

    println!("Please input your guess.");

    let input = io::stdin().read_line()
                           .ok()
                           .expect("Failed to read line");
    let input_num: Option<uint> = from_str(input.as_slice().trim());

    let num = match input_num {
        Some(num) => num,
        None      => {
            println!("Please input a number!");
            return;
        }
    };


    println!("You guessed: {}", num);

    match cmp(num, secret_number) {
        Less    => println!("Too small!"),
        Greater => println!("Too big!"),
        Equal   => {
            println!("You win!");
            return;
        },
    }
}
\end{verbatim}

\}

fn cmp(a: uint, b: uint) -\textgreater{} Ordering \{ if a \textless{} b
\{ Less \} else if a \textgreater{} b \{ Greater \} else \{ Equal \} \}
```

By adding the \texttt{return} line after the \texttt{You win!}, we'll
exit the program when we win. We have just one more tweak to make: when
someone inputs a non-number, we don't want to quit, we just want to
ignore it. Change that \texttt{return} to \texttt{continue}:

```\{rust,no\_run\} use std::io; use std::rand;

fn main() \{ println!(``Guess the number!'');

\begin{verbatim}
let secret_number = (rand::random::<uint>() % 100u) + 1u;

println!("The secret number is: {}", secret_number);

loop {

    println!("Please input your guess.");

    let input = io::stdin().read_line()
                           .ok()
                           .expect("Failed to read line");
    let input_num: Option<uint> = from_str(input.as_slice().trim());

    let num = match input_num {
        Some(num) => num,
        None      => {
            println!("Please input a number!");
            continue;
        }
    };


    println!("You guessed: {}", num);

    match cmp(num, secret_number) {
        Less    => println!("Too small!"),
        Greater => println!("Too big!"),
        Equal   => {
            println!("You win!");
            return;
        },
    }
}
\end{verbatim}

\}

fn cmp(a: uint, b: uint) -\textgreater{} Ordering \{ if a \textless{} b
\{ Less \} else if a \textgreater{} b \{ Greater \} else \{ Equal \} \}
```

Now we should be good! Let's try:

\texttt{\{rust,ignore\} \$ cargo build    Compiling guessing\_game v0.1.0 (file:/home/you/projects/guessing\_game) \$ ./target/guessing\_game  Guess the number! The secret number is: 61 Please input your guess. 10 You guessed: 10 Too small! Please input your guess. 99 You guessed: 99 Too big! Please input your guess. foo Please input a number! Please input your guess. 61 You guessed: 61 You win!}

Awesome! With one tiny last tweak, we have finished the guessing game.
Can you think of what it is? That's right, we don't want to print out
the secret number. It was good for testing, but it kind of ruins the
game. Here's our final source:

```\{rust,no\_run\} use std::io; use std::rand;

fn main() \{ println!(``Guess the number!'');

\begin{verbatim}
let secret_number = (rand::random::<uint>() % 100u) + 1u;

loop {

    println!("Please input your guess.");

    let input = io::stdin().read_line()
                           .ok()
                           .expect("Failed to read line");
    let input_num: Option<uint> = from_str(input.as_slice().trim());

    let num = match input_num {
        Some(num) => num,
        None      => {
            println!("Please input a number!");
            continue;
        }
    };


    println!("You guessed: {}", num);

    match cmp(num, secret_number) {
        Less    => println!("Too small!"),
        Greater => println!("Too big!"),
        Equal   => {
            println!("You win!");
            return;
        },
    }
}
\end{verbatim}

\}

fn cmp(a: uint, b: uint) -\textgreater{} Ordering \{ if a \textless{} b
\{ Less \} else if a \textgreater{} b \{ Greater \} else \{ Equal \} \}
```

\subsection{Complete!}\label{complete}

At this point, you have successfully built the Guessing Game!
Congratulations!

You've now learned the basic syntax of Rust. All of this is relatively
close to various other programming languages you have used in the past.
These fundamental syntactical and semantic elements will form the
foundation for the rest of your Rust education.

Now that you're an expert at the basics, it's time to learn about some
of Rust's more unique features.

\section{iterators}\label{iterators}

\section{Lambdas}\label{lambdas}

\section{Testing}\label{testing}

attributes

stability markers

\section{Crates and Modules}\label{crates-and-modules}

visibility

\section{Generics}\label{generics}

\section{Traits}\label{traits}

\section{Operators and built-in
Traits}\label{operators-and-built-in-traits}

\section{Ownership and Lifetimes}\label{ownership-and-lifetimes}

Move vs.~Copy

Allocation

\section{Tasks}\label{tasks}

\section{Macros}\label{macros}

\section{Unsafe}\label{unsafe}

\end{document}
